<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Notificações - HVSF</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  
  <style>
    /* Estilos específicos para a página de notificações */
    
    /* LAYOUT RESPONSIVO: Ajuste para garantir que o conteúdo não fique atrás da sidebar */
    .main-content {
        margin-left: 250px; /* Largura padrão da sidebar */
        padding: 20px;
        transition: margin-left 0.3s;
        width: calc(100% - 250px); /* Garante que o conteúdo ocupe o espaço restante */
        box-sizing: border-box; /* Inclui padding na largura total */
    }

    @media (max-width: 768px) {
        .main-content {
            margin-left: 0; /* Em mobile, a sidebar geralmente recolhe */
            width: 100%;
        }
    }

    .notifications-container {
        padding: 0; /* Padding já tratado no main-content */
        max-width: 100%; /* Ocupa toda a largura disponível */
        margin: 0 auto;
    }

    .notification-card {
        background-color: #1e1e1e;
        border-left: 5px solid #ff4d4d; /* Vermelho para pendente */
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        transition: transform 0.2s;
    }

    .notification-card:hover {
        transform: translateY(-2px);
    }

    .notification-card.completed {
        border-left-color: #28a745; /* Verde para concluído */
        opacity: 0.7;
    }

    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .card-header h3 {
        margin: 0;
        color: #fff;
        font-size: 1.2rem;
    }

    .card-meta {
        font-size: 0.9rem;
        color: #aaa;
    }

    .task-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .task-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        background: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
    }

    .task-item input[type="checkbox"] {
        margin-right: 15px;
        transform: scale(1.5);
        cursor: pointer;
    }

    .task-item label {
        color: #ddd;
        cursor: pointer;
        flex-grow: 1;
    }

    .btn-finalize {
        background-color: #d4af37;
        color: #000;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        margin-top: 15px;
        width: 100%;
        transition: background 0.3s;
    }

    .btn-finalize:hover {
        background-color: #f1c40f;
    }

    .btn-finalize:disabled {
        background-color: #555;
        color: #888;
        cursor: not-allowed;
    }

    /* Estilos para a seção Cyclopay */
    .cyclopay-section {
        margin-top: 40px;
        border-top: 1px solid #333;
        padding-top: 20px;
    }

    .cyclopay-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap; /* Permite quebrar linha em telas pequenas */
        gap: 10px;
    }

    .cyclopay-header h2 {
        color: #d4af37;
        font-size: 1.5rem;
        margin: 0;
    }

    .cyclopay-controls {
        display: flex;
        gap: 10px;
    }

    .search-input {
        padding: 8px 12px;
        border-radius: 5px;
        border: 1px solid #444;
        background-color: #2a2a2a;
        color: #fff;
        outline: none;
    }

    .search-input:focus {
        border-color: #d4af37;
    }

    .cyclopay-table th {
        background-color: #2a2a2a;
        color: #d4af37;
        font-weight: bold;
        cursor: pointer; /* Indica que é clicável */
        user-select: none;
    }

    .cyclopay-table th:hover {
        background-color: #333;
    }

    .cyclopay-table th i {
        margin-left: 5px;
        font-size: 0.8rem;
        color: #666;
    }

    .cyclopay-table th.sorted-asc i {
        color: #d4af37;
        transform: rotate(180deg);
    }

    .cyclopay-table th.sorted-desc i {
        color: #d4af37;
    }

    .table-responsive {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch; /* Rolagem suave em mobile */
    }

    .cyclopay-table {
        width: 100%;
        border-collapse: collapse;
        background-color: #1e1e1e;
        border-radius: 8px;
        overflow: hidden;
        min-width: 800px; /* Garante largura mínima para não quebrar colunas */
    }

    .cyclopay-table th, .cyclopay-table td {
        padding: 15px;
        text-align: left;
        border-bottom: 1px solid #333;
        color: #ddd;
        white-space: nowrap; /* Evita quebra de linha indesejada */
    }

    .cyclopay-table th {
        background-color: #2a2a2a;
        color: #d4af37;
        font-weight: bold;
    }

    .cyclopay-table tr:hover {
        background-color: #252525;
    }

    .badge {
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.8rem;
        font-weight: bold;
    }

    .badge-active {
        background-color: rgba(40, 167, 69, 0.2);
        color: #28a745;
    }

    .badge-pending {
        background-color: rgba(255, 193, 7, 0.2);
        color: #ffc107;
    }

    .badge-inactive {
        background-color: rgba(220, 53, 69, 0.2);
        color: #dc3545;
    }

    .btn-import {
        background-color: transparent;
        border: 1px solid #d4af37;
        color: #d4af37;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .btn-import:hover {
        background-color: #d4af37;
        color: #000;
    }

    /* Ícones de Status de Pagamento */
    .status-icon {
        margin-left: 8px;
        font-size: 0.9rem;
    }
    .status-paid { color: #28a745; } /* Verde */
    .status-refused { color: #dc3545; } /* Vermelho */
    .status-pending { color: #ffc107; } /* Amarelo */
    .status-unknown { color: #6c757d; } /* Cinza */

  </style>
</head>
<body>

  <!-- Sidebar será injetada aqui -->
  
  <!-- Conteúdo Principal -->
  <div class="main-content" id="main-content">
    <header>
      <div class="user-info">
        <span>Admin</span>
        <i class="fas fa-user-circle fa-2x"></i>
      </div>
    </header>

    <div class="notifications-container">
      <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
          <i class="fas fa-bell fa-3x" style="color: #d4af37;"></i>
          <div>
              <h1 style="margin: 0; color: #d4af37;">Notificações SITE HVSF</h1>
              <p style="color: #aaa; margin: 5px 0 0 0;">Gerencie aqui as tarefas de onboarding para novos clientes do Plano Financeiro.</p>
          </div>
      </div>

      <div id="notifications-list">
          <p style="color: #888;">Carregando notificações...</p>
      </div>

      <!-- Seção de Teste Manual -->
      <div style="margin-top: 30px; padding: 20px; background: #2a2a2a; border-radius: 8px;">
          <h3 style="color: #d4af37; margin-top: 0;">Simular Nova Venda (Teste)</h3>
          <button onclick="simularVenda()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
              Simular Venda Nível II
          </button>
      </div>

      <!-- Seção de Integração Cyclopay -->
      <div class="cyclopay-section">
        <div class="cyclopay-header">
            <h2><i class="fas fa-sync-alt"></i> Integração Cyclopay (Clientes Recentes)</h2>
            <div class="cyclopay-controls">
                <input type="text" id="searchInput" class="search-input" placeholder="Buscar por nome, email ou CPF..." onkeyup="filterTable()">
                <button onclick="loadCyclopayData()" style="background: transparent; border: 1px solid #d4af37; color: #d4af37; padding: 8px 15px; border-radius: 5px; cursor: pointer;">
                    <i class="fas fa-refresh"></i> Atualizar
                </button>
            </div>
        </div>
        
        <div class="table-responsive">
            <table class="cyclopay-table">
                <thead>
                    <tr>
                        <th onclick="sortTable(0)">Nome <i class="fas fa-sort"></i></th>
                        <th>Plano</th>
                        <th onclick="sortTable(1)">Telefone <i class="fas fa-sort"></i></th>
                        <th onclick="sortTable(2)">CPF <i class="fas fa-sort"></i></th>
                        <th title="Adicionado ao Sistema">ADCS</th>
                        <th title="Formulário Preenchido">FORM</th>
                        <th onclick="sortTable(3)">Data Criação <i class="fas fa-sort"></i></th>
                        <th onclick="sortTable(4)">Última Cobrança <i class="fas fa-sort"></i></th>
                        <th onclick="sortTable(5)">Próxima Cobrança <i class="fas fa-sort"></i></th>
                        <th onclick="sortTable(6)">Status <i class="fas fa-sort"></i></th>
                        <th>Ações</th>
                    </tr>
                </thead>
                <tbody id="cyclopay-list">
                    <tr>
                        <td colspan="7" style="text-align: center; color: #888;">Carregando dados da Cyclopay...</td>
                    </tr>
                </tbody>
            </table>
        </div>
      </div>

    </div>
  </div>

  <!-- Scripts -->
  <!-- Carrega Supabase via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <!-- Carrega Sidebar -->
  <script src="sidebar.js"></script>

  <script>
    // Configuração do Supabase
    const SUPABASE_URL = 'https://vbikskbfkhundhropykf.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZiaWtza2Jma2h1bmRocm9weWtmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU1MTk5NjEsImV4cCI6MjA2MTA5NTk2MX0.-n-Tj_5JnF1NL2ZImWlMeTcobWDl_VD6Vqp0lxRQFFU';
    
    // NOTA: Para evitar conflito com a variável global 'supabase' do CDN, usamos 'supabaseClient'
    let supabaseClient;
    try {
        if (window.supabase && window.supabase.createClient) {
             supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
             console.log('Supabase inicializado com sucesso em admin-notificacoes-hvsf.html');
        } else {
            console.error('Biblioteca Supabase não carregada corretamente.');
        }
    } catch (e) {
        console.error('Erro ao inicializar Supabase:', e);
    }

    // --- INICIALIZAÇÃO ---
    document.addEventListener('DOMContentLoaded', function() {
        // 1. Injeta a Sidebar
        if (typeof injectSidebar === 'function') {
            // Passa o ID do container principal ('main-content') e o contexto do projeto ('Planejamento')
            injectSidebar('main-content', 'Planejamento'); 
        } else {
            console.error('Função injectSidebar não encontrada. Verifique se sidebar.js foi carregado.');
        }
        
        // 2. Carrega Notificações do Supabase (se configurado)
        loadNotifications();
        
        // 3. Carrega Dados da Cyclopay (Clientes + Assinaturas + Transações)
        loadCyclopayData();
    });

    let notifications = [];

    async function loadNotifications() {
        const container = document.getElementById('notifications-list');
        if (!supabaseClient) {
            container.innerHTML = '<p style="color: red;">Erro: Supabase não configurado. Verifique a chave API no código.</p>';
            return;
        }

        const { data, error } = await supabaseClient
            .from('hvsf_tasks')
            .select('*')
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Erro ao carregar:', error);
            container.innerHTML = '<p>Erro ao carregar notificações.</p>';
            return;
        }

        notifications = data;
        renderNotifications();
    }

    function renderNotifications() {
        const container = document.getElementById('notifications-list');
        container.innerHTML = '';

        if (notifications.length === 0) {
            container.innerHTML = '<p>Nenhuma notificação pendente.</p>';
            return;
        }

        notifications.forEach(notif => {
            if (notif.status === 'completed') return; // Opcional: esconder concluídos

            const tasks = typeof notif.tasks === 'string' ? JSON.parse(notif.tasks) : notif.tasks;
            
            const card = document.createElement('div');
            card.className = `notification-card ${notif.status}`;
            card.innerHTML = `
                <div class="card-header">
                    <h3>Novo Cliente: ${notif.client_name}</h3>
                    <span class="badge badge-pending">Pendente</span>
                </div>
                <div class="card-meta">
                    <i class="fas fa-tag"></i> ${notif.plan} | 
                    <i class="fas fa-clock"></i> ${new Date(notif.created_at).toLocaleString()}
                </div>
                <h4 style="color: #d4af37; margin: 15px 0 10px;">Tarefas de Onboarding:</h4>
                <ul class="task-list">
                    ${Object.keys(tasks).map(key => `
                        <li class="task-item">
                            <input type="checkbox" ${tasks[key] ? 'checked' : ''} onchange="updateTask(${notif.id}, '${key}', this.checked)">
                            <label>${formatTaskName(key)}</label>
                        </li>
                    `).join('')}
                </ul>
                <button class="btn-finalize" id="btn-${notif.id}" onclick="finalizeProcess(${notif.id})" ${Object.values(tasks).every(v=>v) ? '' : 'disabled'}>
                    <i class="fas fa-check"></i> Finalizar Processo
                </button>
            `;
            container.appendChild(card);
        });
    }

    function formatTaskName(key) {
        const names = {
            'login': 'Criar Login e Senha no Admin',
            'email': 'Criar E-mail Seguro (@hvsf...)',
            'form': 'Enviar Formulário de Diagnóstico via WhatsApp',
            'meeting': 'Agendar Reunião de Kick-off'
        };
        return names[key] || key;
    }

    async function updateTask(id, key, checked) {
        const notif = notifications.find(n => n.id === id);
        let tasks = typeof notif.tasks === 'string' ? JSON.parse(notif.tasks) : notif.tasks;
        tasks[key] = checked;
        
        await supabaseClient.from('hvsf_tasks').update({ tasks }).eq('id', id);
        
        notif.tasks = tasks;
        const btn = document.getElementById(`btn-${id}`);
        if (btn) btn.disabled = !Object.values(tasks).every(v=>v);
    }

    async function finalizeProcess(id) {
        if(confirm('Tem certeza que deseja finalizar este processo? O cliente será marcado como ativo.')) {
            await supabaseClient.from('hvsf_tasks').update({ status: 'completed' }).eq('id', id);
            loadNotifications(); 
        }
    }

    async function simularVenda() {
        if (!supabaseClient) {
            alert('Supabase não configurado!');
            return;
        }
        const fakeData = {
            client_name: 'Cliente Teste ' + Math.floor(Math.random() * 1000),
            plan: 'Plano Financeiro Nível II',
            tasks: { login: false, email: false, form: false },
            status: 'pending'
        };
        
        const { error } = await supabaseClient.from('hvsf_tasks').insert([fakeData]);
        if (error) alert('Erro ao criar: ' + error.message);
        else loadNotifications();
    }

    // --- LÓGICA CYCLOPAY (REAL) ---
    async function loadCyclopayData() {
        const tbody = document.getElementById('cyclopay-list');
        tbody.innerHTML = '<tr><td colspan="7" style="text-align: center;">Carregando TODOS os dados da Cyclopay... (Isso pode levar alguns segundos)</td></tr>';
        
        const CYCLOPAY_API_KEY = 'ak_aeb26f6be167cc077eb227c128262e731523d492'; 
        const BASE_URL = 'https://api.cyclopay.com/v1';

        try {
            // Função auxiliar para buscar TODAS as páginas
            async function fetchAllPages(endpoint) {
                let allItems = [];
                let page = 1;
                let hasMore = true;
                
                while (hasMore) {
                    const response = await fetch(`${BASE_URL}${endpoint}${endpoint.includes('?') ? '&' : '?'}page=${page}&count=100`, {
                        method: 'GET',
                        headers: { 'api_key': CYCLOPAY_API_KEY, 'Accept': 'application/json' }
                    });
                    
                    if (!response.ok) throw new Error(`Erro ao buscar ${endpoint}: ${response.status}`);
                    
                    const data = await response.json();
                    const items = data.items || [];
                    allItems = allItems.concat(items);
                    
                    // Verifica se há mais páginas (se retornou menos que o limite, acabou)
                    if (items.length < 100) hasMore = false;
                    else page++;
                }
                return allItems;
            }

            // 0. Buscar dados do Supabase para comparação (ADCS e FORM)
            const { data: supabaseClients, error: sbError } = await supabaseClient
                .from('clientes')
                .select('id, nome, whatsapp, projeto'); // Assumindo que não tem CPF, vamos tentar comparar por outros meios se possível, mas o ideal seria ter CPF.
            
            // Buscar formulários (trazendo todos os campos para verificar preenchimento)
            const { data: supabaseForms, error: sbFormError } = await supabaseClient
                .from('formularios_clientes')
                .select('*'); // Traz tudo para inspecionar estrutura

            if (supabaseForms && supabaseForms.length > 0) {
                console.log('Estrutura de formularios_clientes:', supabaseForms[0]);
            }

            // Salva dados do Supabase no escopo global para acesso na renderização
            window.supabaseClients = supabaseClients || [];
            // Mapeia formulários por cliente_id para acesso rápido
            window.formsByClientId = {};
            if (supabaseForms) {
                supabaseForms.forEach(form => {
                    // Se o cliente tiver múltiplos formulários, guarda o mais recente ou uma lista
                    // Aqui vamos guardar uma lista para poder verificar todos
                    if (!window.formsByClientId[form.cliente_id]) {
                        window.formsByClientId[form.cliente_id] = [];
                    }
                    window.formsByClientId[form.cliente_id].push(form);
                });
            }

            // 1. Busca TODOS os Clientes, Assinaturas e Transações em paralelo
            const [customers, subscriptions, transactions] = await Promise.all([
                fetchAllPages('/customers'),
                fetchAllPages('/subscriptions'),
                fetchAllPages('/transactions?orderDir=desc') // Busca transações ordenadas para pegar as recentes
            ]);

            // 4. Cruza os dados
            const mergedData = customers.map(customer => {
                // Encontra a assinatura correspondente ao cliente
                const sub = subscriptions.find(s => s.customer_id === customer.customer_id);
                
                // Encontra a transação mais recente do cliente
                // Como buscamos todas as transações, filtramos pelo cliente e pegamos a primeira (mais recente)
                const clientTransactions = transactions.filter(t => t.customer && t.customer.customer_id === customer.customer_id);
                // Ordena por data decrescente para garantir (caso a API não garanta)
                clientTransactions.sort((a, b) => new Date(b.create_date) - new Date(a.create_date));
                
                const lastTransaction = clientTransactions.length > 0 ? clientTransactions[0] : null;

                // Lógica para Data da Última Cobrança:
                // Prioriza a data da última transação se existir, senão usa a da assinatura
                let lastChargeDate = null;
                if (lastTransaction) {
                    lastChargeDate = lastTransaction.create_date;
                } else if (sub && sub.last_charge_date) {
                    lastChargeDate = sub.last_charge_date;
                }

                return {
                    ...customer,
                    last_charge_date: lastChargeDate,
                    next_charge: sub ? sub.next_charge : null,
                    last_transaction_status: lastTransaction ? lastTransaction.transaction_status : null
                };
            });
            
            // Salva dados globais para filtragem
            window.allCyclopayData = mergedData;

            renderCyclopayTable(mergedData);

        } catch (error) {
            console.error('Erro ao carregar dados da Cyclopay:', error);
            tbody.innerHTML = `<tr><td colspan="7" style="text-align: center; color: #ff4d4d;">Erro ao carregar dados: ${error.message}</td></tr>`;
        }
    }

    function renderCyclopayTable(clients) {
        const tbody = document.getElementById('cyclopay-list');
        tbody.innerHTML = '';
        
        if (!clients || clients.length === 0) {
            tbody.innerHTML = '<tr><td colspan="7" style="text-align: center;">Nenhum cliente encontrado.</td></tr>';
            return;
        }

        clients.forEach(client => {
                const statusClass = client.active ? 'badge-active' : 'badge-inactive';
                const statusLabel = client.active ? 'Ativo' : 'Inativo';
                const createdDate = client.create_date ? new Date(client.create_date).toLocaleDateString('pt-BR') : '-';
                
                // Formata datas de cobrança
                const lastCharge = client.last_charge_date ? new Date(client.last_charge_date).toLocaleDateString('pt-BR') : '-';
                const nextCharge = client.next_charge ? new Date(client.next_charge).toLocaleDateString('pt-BR') : '-';
                
                // Ícone de status da última cobrança
                let statusIcon = '';
                if (client.last_transaction_status) {
                    if (client.last_transaction_status === 'paid' || client.last_transaction_status === 'authorized') {
                        statusIcon = '<i class="fas fa-check-circle status-icon status-paid" title="Pago"></i>';
                    } else if (client.last_transaction_status === 'refused' || client.last_transaction_status === 'failed') {
                        statusIcon = '<i class="fas fa-times-circle status-icon status-refused" title="Falhou"></i>';
                    } else if (client.last_transaction_status === 'pending' || client.last_transaction_status === 'waiting_payment') {
                        statusIcon = '<i class="fas fa-clock status-icon status-pending" title="Pendente"></i>';
                    } else {
                        statusIcon = `<i class="fas fa-question-circle status-icon status-unknown" title="${client.last_transaction_status}"></i>`;
                    }
                }

                // Tratamento do CPF (pode vir como objeto ou string)
                let cpfDisplay = '-';
                let rawDocument = '';
                
                if (client.document) {
                    if (typeof client.document === 'object') {
                        // Tenta pegar 'number', 'value', 'cpf', ou 'cnpj'
                        rawDocument = client.document.number || client.document.value || client.document.cpf || client.document.cnpj || '';
                    } else {
                        rawDocument = String(client.document);
                    }
                }

                // Aplica máscara de CPF ou CNPJ
                let cleanDoc = '';
                if (rawDocument) {
                    cleanDoc = rawDocument.replace(/\D/g, ''); // Remove não-números
                    if (cleanDoc.length === 11) {
                        // CPF: 000.000.000-00
                        cpfDisplay = cleanDoc.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
                    } else if (cleanDoc.length === 14) {
                        // CNPJ: 00.000.000/0000-00
                        cpfDisplay = cleanDoc.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
                    } else {
                        cpfDisplay = rawDocument; // Retorna original se não bater tamanho
                    }
                }

                // Lógica ADCS e FORM
                let isAdcs = false;
                let formStatus = 'none'; // none, created, answered
                
                // Recupera dados do Supabase do escopo global
                const sbClients = window.supabaseClients || [];
                const formsMap = window.formsByClientId || {};

                // Tenta achar cliente no Supabase (por email ou CPF)
                const sbClient = sbClients.find(c => c.email === client.email || (cleanDoc && c.cpf === cleanDoc)); 
                
                if (sbClient) {
                    isAdcs = true;
                    const clientForms = formsMap[sbClient.id];
                    
                    if (clientForms && clientForms.length > 0) {
                        // Verifica se algum formulário foi respondido
                        // Critério: Verifica se existe algum campo de resposta preenchido.
                        // Assumindo campos comuns como 'respostas', 'dados', 'status' ou simplesmente se o objeto não está vazio além dos metadados.
                        // Como não sei a estrutura exata, vou usar uma heurística genérica:
                        // Se tiver um campo 'status' == 'concluido' ou 'respondido'
                        // OU se tiver um campo 'respostas' ou 'dados' que não seja null/vazio
                        
                        const hasAnsweredForm = clientForms.some(f => {
                            // Tenta detectar se foi respondido
                            const hasData = f.respostas || f.dados || f.json_respostas;
                            const isCompleted = f.status === 'concluido' || f.status === 'respondido' || f.status === 'finalizado';
                            
                            // Se não tiver campos explícitos, assume que a existência do registro já indica criação.
                            // Para diferenciar "criado" de "respondido", precisamos saber se o formulário é criado vazio primeiro.
                            // Se o sistema cria o registro APENAS quando o cliente responde, então sempre será "respondido".
                            // Se o sistema cria um "convite" (registro vazio), então precisamos checar preenchimento.
                            
                            // Vou assumir a lógica mais comum em sistemas de "envio de formulário":
                            // 1. Admin envia -> Cria registro (status='enviado' ou dados vazios)
                            // 2. Cliente responde -> Atualiza registro (status='respondido' ou preenche dados)
                            
                            return hasData || isCompleted; 
                        });

                        if (hasAnsweredForm) {
                            formStatus = 'answered';
                        } else {
                            formStatus = 'created';
                        }
                    }
                }

                // Ícone ADCS
                const adcsIcon = isAdcs 
                    ? '<i class="fas fa-check-circle" style="color: #28a745;" title="Cliente encontrado no sistema"></i>' 
                    : '<i class="fas fa-times-circle" style="color: #dc3545;" title="Cliente NÃO encontrado"></i>';

                // Ícone FORM
                let formIcon = '';
                if (!isAdcs) {
                    // Cliente não encontrado -> X Vermelho
                    formIcon = '<i class="fas fa-times-circle" style="color: #dc3545;" title="Cliente não encontrado"></i>';
                } else if (formStatus === 'none') {
                    // Cliente encontrado, mas sem formulário -> X Vermelho
                    formIcon = '<i class="fas fa-times-circle" style="color: #dc3545;" title="Formulário não criado"></i>';
                } else if (formStatus === 'created') {
                    // Formulário criado, mas não respondido -> ! Amarelo
                    formIcon = '<i class="fas fa-exclamation-triangle" style="color: #ffc107;" title="Aguardando resposta"></i>';
                } else {
                    // Formulário respondido -> Check Verde
                    formIcon = '<i class="fas fa-check-circle" style="color: #28a745;" title="Formulário respondido"></i>';
                }

                // Formata Telefone
                let phoneDisplay = '-';
                if (client.phone) {
                    // Se for objeto (mobile_phone) ou string
                    const rawPhone = client.mobile_phone || client.phone || '';
                    // Remove caracteres não numéricos
                    const cleanPhone = String(rawPhone).replace(/\D/g, '');
                    if (cleanPhone.length >= 10) {
                        // Formata (XX) XXXXX-XXXX ou (XX) XXXX-XXXX
                        if (cleanPhone.length === 11) {
                            phoneDisplay = `(${cleanPhone.substring(0,2)}) ${cleanPhone.substring(2,7)}-${cleanPhone.substring(7)}`;
                        } else {
                            phoneDisplay = `(${cleanPhone.substring(0,2)}) ${cleanPhone.substring(2,6)}-${cleanPhone.substring(6)}`;
                        }
                    } else {
                        phoneDisplay = rawPhone;
                    }
                }

                // Obtém nome do Plano (se disponível na assinatura)
                let planName = '-';
                // Tenta pegar da assinatura vinculada
                // Precisamos achar a assinatura correta no array de subscriptions
                // Como já cruzamos os dados, podemos ter salvo o objeto de assinatura no cliente ou buscar novamente
                // No código atual, 'client' já tem dados mesclados, mas não salvamos o objeto de assinatura completo, apenas datas.
                // Vamos ajustar o map lá em cima para incluir o nome do plano ou buscar aqui.
                // Melhor ajustar o map principal para incluir 'plan_name'.
                
                // Ajuste rápido: buscar no array global de subscriptions se disponível, ou usar o que tiver.
                // Como 'client' é um objeto mesclado, vamos ver se tem info do plano.
                // Se não tiver, vamos exibir '-' por enquanto e ajustar o map principal no próximo passo se necessário.
                // Mas espere, o 'mergedData' é criado mapeando 'customers'.
                // Vamos ver se 'subscriptions' tem o nome do plano.
                // A API da Cyclopay retorna 'product_name' ou 'plan_name' na assinatura?
                // Geralmente sim. Vou assumir que precisamos pegar isso no map.
                
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><strong>${client.first_name} ${client.last_name || ''}</strong></td>
                    <td>${client.plan_name || '-'}</td>
                    <td>${phoneDisplay}</td>
                    <td>${cpfDisplay}</td>
                    <td style="text-align: center;">${adcsIcon}</td>
                    <td style="text-align: center;">${formIcon}</td>
                    <td>${createdDate}</td>
                    <td>${lastCharge} ${statusIcon}</td>
                    <td>${nextCharge}</td>
                    <td><span class="badge ${statusClass}">${statusLabel}</span></td>
                    <td>
                        <button class="btn-import" onclick="importarCliente('${client.first_name} ${client.last_name || ''}', '${client.email}')" title="Iniciar Onboarding">
                            <i class="fas fa-file-import"></i> Importar
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
        });
    }

    async function importarCliente(nome, email) {
        if (!supabaseClient) {
            alert('Supabase não configurado! Configure a chave API no código para salvar.');
            return;
        }

        if(confirm(`Deseja iniciar o processo de onboarding para ${nome}?`)) {
            const newTask = {
                client_name: nome,
                plan: 'Importado Cyclopay', 
                tasks: { login: false, email: false, form: false },
                status: 'pending'
            };
            
            const { error } = await supabaseClient.from('hvsf_tasks').insert([newTask]);
            
            if (error) {
                alert('Erro ao importar: ' + error.message);
            } else {
                alert('Cliente importado com sucesso! Verifique a lista de notificações.');
                loadNotifications(); 
            }
        }
    }

    // --- FUNÇÕES DE FILTRO E ORDENAÇÃO ---
    function filterTable() {
        const input = document.getElementById('searchInput');
        const filter = input.value.toLowerCase();
        
        if (!window.allCyclopayData) return;

        const filteredData = window.allCyclopayData.filter(client => {
            const name = (client.first_name + ' ' + (client.last_name || '')).toLowerCase();
            const email = (client.email || '').toLowerCase();
            
            let cpf = '';
            if (client.document) {
                if (typeof client.document === 'object') {
                    cpf = (client.document.number || client.document.value || client.document.cpf || client.document.cnpj || '').toLowerCase();
                } else {
                    cpf = String(client.document).toLowerCase();
                }
            }
            
            return name.includes(filter) || email.includes(filter) || cpf.includes(filter);
        });

        renderCyclopayTable(filteredData);
    }

    let currentSort = { column: null, direction: 'asc' };

    function sortTable(columnIndex) {
        const table = document.querySelector('.cyclopay-table');
        const tbody = document.getElementById('cyclopay-list');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        
        // Remove ícones de ordenação anteriores
        table.querySelectorAll('th').forEach(th => {
            th.classList.remove('sorted-asc', 'sorted-desc');
            const icon = th.querySelector('i');
            if(icon) icon.className = 'fas fa-sort';
        });

        // Define direção
        if (currentSort.column === columnIndex) {
            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            currentSort.column = columnIndex;
            currentSort.direction = 'asc';
        }

        // Atualiza ícone da coluna atual
        const th = table.querySelectorAll('th')[columnIndex];
        th.classList.add(currentSort.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
        th.querySelector('i').className = currentSort.direction === 'asc' ? 'fas fa-sort-up' : 'fas fa-sort-down';

        // Ordena
        rows.sort((a, b) => {
            const aText = a.children[columnIndex].innerText.trim();
            const bText = b.children[columnIndex].innerText.trim();

            // Tenta ordenar como data (DD/MM/YYYY)
            if (aText.match(/^\d{2}\/\d{2}\/\d{4}/)) {
                const dateA = parseDate(aText);
                const dateB = parseDate(bText);
                return currentSort.direction === 'asc' ? dateA - dateB : dateB - dateA;
            }

            return currentSort.direction === 'asc' 
                ? aText.localeCompare(bText) 
                : bText.localeCompare(aText);
        });

        rows.forEach(row => tbody.appendChild(row));
    }

    function parseDate(dateStr) {
        if (!dateStr || dateStr === '-') return 0;
        const parts = dateStr.split(' ')[0].split('/'); // Remove ícones/espaços extras
        return new Date(parts[2], parts[1] - 1, parts[0]).getTime();
    }
  </script>
</body>
</html>
