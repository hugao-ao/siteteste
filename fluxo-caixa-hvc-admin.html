<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluxo de Caixa HVC - Agenda e Pagamentos</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="multi_account_styles.css" />
    
    <!-- Estilos para melhorias do Fluxo de Caixa -->
    <style>
        /* Select com botão de gerenciar */
        .select-with-manage {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .select-with-manage select {
            flex: 1;
        }

        .manage-list-btn {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            color: #ffc107;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .manage-list-btn:hover {
            background: rgba(255, 193, 7, 0.3);
            transform: scale(1.05);
        }

        .manage-list-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Modal de gerenciamento */
        .manage-list-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .manage-list-modal-content {
            background: linear-gradient(135deg, #1a1a4d, #2d1b4e);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .manage-list-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .manage-list-modal-header h3 {
            color: #ffc107;
            margin: 0;
            font-size: 1.5rem;
        }

        .close-modal-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-modal-btn:hover {
            color: #ff4444;
        }

        .add-list-item-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .add-list-item-form {
            display: flex;
            gap: 10px;
        }

        .add-list-item-form input {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
        }

        .add-list-item-btn {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4caf50;
            color: #4caf50;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .add-list-item-btn:hover {
            background: rgba(76, 175, 80, 0.5);
        }

        .manage-list-search input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            margin-bottom: 15px;
        }

        .manage-list-items-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .manage-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .remove-list-item-btn {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            color: #f44336;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        /* Modal de edição */
        .edit-item-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        .edit-item-modal-content {
            background: linear-gradient(135deg, #1a1a4d, #2d1b4e);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            margin: 20px;
        }

        .edit-item-btn {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid #2196f3;
            color: #2196f3;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
        }

        .save-edit-btn {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4caf50;
            color: #4caf50;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .cancel-edit-btn {
            background: rgba(158, 158, 158, 0.2);
            border: 1px solid #9e9e9e;
            color: #9e9e9e;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
        }
    </style>
    
    <style>
        /* Tema específico HVC - Elegante e sofisticado */
        body {
            display: flex;
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #000080, #800080);
            color: #e0e0e0;
        }

        /* Layout responsivo para sidebar */
        #main-content-fluxo-caixa-hvc {
            flex-grow: 1;
            padding: 2rem;
            transition: margin-left 0.3s ease;
            background: linear-gradient(135deg, #000080, #800080);
            margin-left: 250px;
            width: calc(100vw - 250px);
            box-sizing: border-box;
        }

        #main-content-fluxo-caixa-hvc.sidebar-collapsed {
            margin-left: 60px;
            width: calc(100vw - 60px);
        }

        @media (max-width: 768px) {
            #main-content-fluxo-caixa-hvc {
                margin-left: 0;
                width: 100vw;
            }
            
            #main-content-fluxo-caixa-hvc.sidebar-collapsed {
                margin-left: 0;
                width: 100vw;
            }
        }

        .hvc-container {
            background: rgba(25, 25, 112, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 128, 0.3);
            backdrop-filter: blur(10px);
            max-width: 100%;
            box-sizing: border-box;
        }

        .hvc-title {
            color: #ffffff;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            text-align: center;
            word-wrap: break-word;
        }

        /* Seção de Resumo Mensal */
        .monthly-summary {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .monthly-summary h3 {
            color: #ffc107;
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .monthly-total {
            color: #ffffff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .monthly-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            color: #ffc107;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* ✅ NOVO: Estatísticas por Status com Montantes */
        .status-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .status-stat-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
        }

        /* ✅ STATUS DE PAGAMENTOS */
        .status-stat-item.pg {
            border-color: #34a853;
            background: rgba(52, 168, 83, 0.2);
        }

        .status-stat-item.pendente {
            border-color: #ea4335;
            background: rgba(234, 67, 53, 0.2);
        }

        .status-stat-item.recalculado {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.2);
        }

        /* ✅ NOVO: STATUS DE RECEBIMENTOS */
        .status-stat-item.rc {
            border-color: #66bb6a;
            background: rgba(102, 187, 106, 0.2);
        }

        .status-stat-item.aguardando {
            border-color: #03a9f4;
            background: rgba(3, 169, 244, 0.2);
        }

        .status-stat-item.adiado {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.2);
        }

        /* ✅ NOVO: STATUS EM ATRASO */
        .status-stat-item.pendente-atraso {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.2);
        }

        .status-stat-item.aguardando-atraso {
            border-color: #9c27b0;
            background: rgba(156, 39, 176, 0.2);
        }

        .status-stat-value {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-stat-amount {
            color: #ffc107;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .status-stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8rem;
            margin-top: 5px;
        }

        /* ✅ NOVO: Estilos para layout atualizado dos status */
        .status-stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .status-stat-count {
            color: #ffffff;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .status-stat-daily {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
            font-style: italic;
            margin-bottom: 5px;
        }

        /* ✅ NOVO: Estilos para Análise de Saldo */
        .balance-analysis {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid #8a2be2;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .balance-analysis h3 {
            color: #da70d6;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .balance-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .balance-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
        }

        .balance-item.positive {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .balance-item.pending {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .balance-item.overdue {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .balance-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .balance-values {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 8px 0;
        }

        .balance-value {
            display: flex;
            flex-direction: column;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            min-height: 44px;
        }

        .balance-value-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

         .balance-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
            font-weight: 500;
            min-width: 120px;
        }

        .balance-amount {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
            margin-right: 8px;
        }

        .balance-daily {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.85rem;
            font-style: italic;
            text-align: center;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .balance-result {
            margin-top: 16px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-top: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 48px;
        }

        .balance-final {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .balance-final.positive {
            color: #4caf50;
        }

        .balance-final.negative {
            color: #f44336;
        }

        /* Lista de Pagamentos */
        /* ✅ NOVO: Container para resumos mensais */
        .monthly-summary-container {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .monthly-summary-general {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .summaries-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .payments-summary,
        .receivings-summary {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .section-total {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffc107;
            text-align: center;
            margin: 15px 0;
        }

        /* ✅ NOVO: Container para listas lado a lado */
        .lists-container {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .lists-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .payments-list-section,
        .receivings-list-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
        }

        .payments-list-section h3 {
            color: #ffffff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ✅ NOVO: Filtros de Pagamentos e Recebimentos */
        .payments-filters,
        .receivings-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .filter-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #ffffff;
            font-size: 0.9rem;
        }

        .filter-input:focus {
            outline: none;
            border-color: #4285f4;
            background: rgba(255, 255, 255, 0.15);
        }

        .filter-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .filter-select {
            background: rgba(66, 133, 244, 0.8) !important; /* ✅ NOVO: Fundo azul para visibilidade */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #ffffff !important;
            font-size: 0.9rem;
        }

        .filter-select option {
            background: rgba(66, 133, 244, 0.9) !important; /* ✅ NOVO: Fundo azul para opções */
            color: #ffffff !important;
        }

        .clear-filters-btn {
            background: rgba(234, 67, 53, 0.3);
            border: 1px solid #ea4335;
            border-radius: 6px;
            padding: 8px 16px;
            color: #ea4335;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            align-self: flex-end;
        }

        .clear-filters-btn:hover {
            background: rgba(234, 67, 53, 0.5);
            color: #ffffff;
        }

        .payments-list,
        .receivings-list {
            max-height: 500px;
            overflow-y: auto;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .payments-list::-webkit-scrollbar,
        .receivings-list::-webkit-scrollbar {
            width: 8px;
        }

        .payments-list::-webkit-scrollbar-track,
        .receivings-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .payments-list::-webkit-scrollbar-thumb,
        .receivings-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .payment-item,
        .receiving-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .payment-item:hover,
        .receiving-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .payment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .payment-name {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
            flex: 1;
            min-width: 200px;
        }

        .payment-value {
            color: #ffc107;
            font-weight: bold;
            font-size: 1.2rem;
            background: rgba(255, 193, 7, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .payment-details {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .payment-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .payment-status {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .payment-status.pg {
            background: rgba(76, 175, 80, 0.3);
            color: #4caf50;
        }

        .payment-status.pendente {
            background: rgba(255, 152, 0, 0.3);
            color: #ff9800;
        }

        .payment-status.recalculado {
            background: rgba(66, 133, 244, 0.3);
            color: #4285f4;
        }

        /* ✅ NOVO: Estilos para status de recebimentos nas listas */
        .payment-status.rc {
            background: rgba(102, 187, 106, 0.3);
            color: #66bb6a;
        }

        .payment-status.aguardando {
            background: rgba(3, 169, 244, 0.3);
            color: #03a9f4;
        }

        .payment-status.adiado {
            background: rgba(255, 152, 0, 0.3);
            color: #ff9800;
        }

        /* ✅ NOVO: Estilos para status em atraso nas listas */
        .payment-status.pendente.overdue {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        .payment-status.aguardando.overdue {
            background: rgba(156, 39, 176, 0.3);
            color: #9c27b0;
        }

        .payment-type {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(66, 133, 244, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .payment-type.pagamento {
            background: rgba(234, 67, 53, 0.3);
        }

        .payment-type.hvc {
            background: rgba(156, 39, 176, 0.3);
        }

        .no-payments {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.6);
        }

        .no-payments i {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
        }

        /* Google Calendar Section */
        .google-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .google-section h2 {
            color: #ffffff;
            font-size: 1.8rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-size: 16px;
            font-weight: 500;
            flex-wrap: wrap;
        }

        .status-disconnected {
            background: rgba(234, 67, 53, 0.2);
            border: 1px solid rgba(234, 67, 53, 0.4);
            color: #ea4335;
        }

        .status-connected {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            color: #34a853;
        }

        .google-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4285f4, #34a853);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* ✅ NOVO: Estilos para o botão criar evento */
        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* ✅ NOVO: Estilos para criação de eventos */
        .event-creator-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .event-creator-section h3 {
            color: #ffffff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .payment-items-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .payment-items-container h4 {
            color: #ffc107;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .add-item-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 10px 12px;
            color: #ffffff;
            font-size: 0.9rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4285f4;
            background: rgba(255, 255, 255, 0.15);
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .add-item-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-item-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .items-list {
            max-height: 300px;
            overflow-y: auto;
            border-radius: 8px;
        }

        .item-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .item-card:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .item-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .item-details span {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .item-value {
            color: #ffc107;
            font-weight: bold;
            font-size: 1.2rem;
            margin: 0 15px;
        }

        .remove-item-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-item-btn:hover {
            background: #c82333;
        }

        .create-event-form {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .create-event-form h4 {
            color: #4285f4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .create-event-btn {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .create-event-btn:hover {
            background: #3367d6;
            transform: translateY(-1px);
        }

        .cancel-event-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cancel-event-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Calendar View */
        .calendar-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: auto;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .calendar-nav button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .calendar-nav button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* ✅ NOVO: Estilos para campo de saldo da conta corrente */
        .account-balance-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .account-balance-input label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .account-balance-input input {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9rem;
            color: #333;
            width: 120px;
            text-align: right;
        }

        .account-balance-input input:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        .calendar-title {
            color: #ffffff;
            font-size: 1.5rem;
            font-weight: 500;
            text-align: center;
            min-width: 200px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            min-width: 700px;
        }

        .calendar-day-header {
            background: rgba(66, 133, 244, 0.3);
            color: white;
            padding: 15px 5px;
            text-align: center;
            font-weight: 500;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            min-width: 100px;
        }
        .calendar-day {
            background: rgba(255, 255, 255, 0.05);
            min-height: 180px;
            max-height: 180px;
            padding: 6px;
            position: relative;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ✅ NOVO: Estilos para saldo acumulado nos dias */
        .day-accumulated-balance {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            white-space: nowrap;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .calendar-day:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.today {
            background: rgba(66, 133, 244, 0.2) !important;
            border: 2px solid #4285f4 !important;
        }

        /* ✅ NOVO: Header do dia com número e saldo */
        .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
            flex-shrink: 0;
            position: relative;
        }

        .day-number {
            color: white;
            font-weight: 500;
            font-size: 12px;
            flex-shrink: 0;
        }

        .day-balance-inline {
            font-size: 9px;
            font-weight: bold;
            padding: 1px 3px;
            border-radius: 2px;
            flex-shrink: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .day-balance-inline.positive {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        .day-balance-inline.negative {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        .day-total {
            background: rgba(255, 193, 7, 0.8);
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 3px;
            text-align: center;
            flex-shrink: 0;
            word-wrap: break-word;
            line-height: 1.1;
        }

        /* ✅ NOVO: Estilos para totais separados */
        .day-payment-total {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 2px;
            text-align: center;
            flex-shrink: 0;
            word-wrap: break-word;
            line-height: 1.1;
            border: 1px solid #ffc107;
        }

        .day-receiving-total {
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-top: 2px;
            margin-bottom: 2px;
            text-align: center;
            flex-shrink: 0;
            word-wrap: break-word;
            line-height: 1.1;
            border: 1px solid #2196f3;
        }

        .day-balance {
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-top: 2px;
            text-align: center;
            flex-shrink: 0;
            word-wrap: break-word;
            line-height: 1.1;
            border: 1px solid;
        }

        .day-balance.positive {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border-color: #4caf50;
        }

        .day-balance.negative {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            border-color: #f44336;
        }

        /* ✅ NOVO: Totais dos eventos com mesma aparência dos eventões */
        .event-total {
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
            flex-shrink: 0;
            line-height: 1.2;
            margin-bottom: 1px;
            opacity: 0.9;
        }

        /* ✅ NOVO: Cores dos totais iguais aos eventões - PAGAMENTOS */
        .event-total.payment-completed {
            background: #8d6e63; /* MARROM SÓLIDO */
        }

        .event-total.payment-overdue {
            background: linear-gradient(135deg, #f44336, #d32f2f); /* VERMELHO */
        }

        .event-total.payment-upcoming {
            background: linear-gradient(135deg, #ff9800, #f57c00); /* LARANJA */
        }

        /* ✅ NOVO: Cores dos totais iguais aos eventões - RECEBIMENTOS */
        .event-total.receiving-upcoming {
            background: linear-gradient(135deg, #2196f3, #1976d2); /* AZUL */
        }

        .event-total.receiving-overdue {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2); /* ROXO */
        }

        .event-total.receiving-completed {
            background: #2196f3; /* AZUL SÓLIDO */
        }

        .event-total.receiving-default {
            background: linear-gradient(135deg, #4caf50, #388e3c); /* VERDE */
        }

        .day-events {
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }

        .event-item {
            color: white;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
            flex-shrink: 0;
            line-height: 1.2;
        }

        .event-item:hover {
            transform: scale(1.02);
            z-index: 10;
            position: relative;
            white-space: normal;
            word-wrap: break-word;
        }

        /* ✅ CORES PARA PAGAMENTOS */
        /* ✅ REMOVIDO: Estilos antigos que interferiam nos eventos individuais */

        /* ✅ NOVO: Estilos para eventos agrupados por status - PAGAMENTOS */
        .event-item.payment-completed {
            background: #8d6e63; /* MARROM SÓLIDO */
        }

        .event-item.payment-overdue {
            background: linear-gradient(135deg, #f44336, #d32f2f); /* VERMELHO */
        }

        .event-item.payment-upcoming {
            background: linear-gradient(135deg, #ff9800, #f57c00); /* LARANJA */
        }

        /* ✅ NOVO: Estilos para eventos de recebimentos */
        .event-item.receiving-upcoming {
            background: linear-gradient(135deg, #2196f3, #1976d2); /* AZUL */
        }

        .event-item.receiving-overdue {
            background: linear-gradient(135deg, #9c27b0, #7b1fa2); /* ROXO */
        }

        .event-item.receiving-completed {
            background: #2196f3; /* AZUL SÓLIDO */
        }

        .event-item.receiving-default {
            background: linear-gradient(135deg, #4caf50, #388e3c); /* VERDE */
        }

        /* ✅ NOVO: Estilos para modal de eventos agrupados */
        .day-summary {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .day-total-value {
            font-size: 28px;
            font-weight: bold;
            color: #ffc107;
            margin: 10px 0;
        }

        .day-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .day-stats span {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        .grouped-event-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .grouped-event-section h4 {
            color: #ffc107;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .grouped-event-section h5 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        /* Filter Section */
        .filter-section {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .filter-info {
            color: #34a853;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            flex-wrap: wrap;
        }

        .filter-stats {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            word-wrap: break-word;
        }

        /* Event Details Modal */
        .event-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }

        .event-modal-content {
            background: linear-gradient(135deg, #000080, #800080);
            margin: 3% auto;
            padding: 30px;
            border-radius: 20px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            box-sizing: border-box;
            resize: both;
            min-width: 600px;
            min-height: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .event-modal-content .close {
            position: fixed;
            top: calc(5% + 10px);
            right: calc((100% - 90%) / 2 - 15px);
            color: #ffffff;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
            background: rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ffffff;
            transition: all 0.3s ease;
        }
        
        .event-modal-content .close:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }

        .event-total-section {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .event-total-title {
            color: #ffc107;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .event-total-value {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            word-wrap: break-word;
        }

        .event-values-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .event-values-list h4 {
            color: #ffc107;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .value-item {
            background: rgba(255, 193, 7, 0.3);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            margin: 8px 0;
            font-family: monospace;
            font-size: 13px;
            word-wrap: break-word;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .value-item-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .value-item-status.pg {
            background: rgba(52, 168, 83, 0.8);
            color: white;
        }

        .value-item-status.pendente {
            background: rgba(234, 67, 53, 0.8);
            color: white;
        }

        .value-item-status.recalculado {
            background: rgba(66, 133, 244, 0.8);
            color: white;
        }

        /* Estilos para TIPO, SUBTIPO e CATEGORIA */
        .item-metadata {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
            font-style: italic;
        }

        .item-tipo,
        .item-subtipo,
        .item-categoria {
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0 2px;
        }

        .item-tipo.error,
        .item-subtipo.error,
        .item-categoria.error {
            background: rgba(234, 67, 53, 0.3);
            color: #ff6b6b;
        }

        .item-name-main {
            font-size: 14px;
            margin-top: 2px;
        }

        .item-value-line {
            margin-top: 4px;
            color: #ffc107;
        }

        .item-detail {
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #000080, #800080);
            margin: 10% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            box-sizing: border-box;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .modal-header h2 {
            color: #ffffff;
            font-size: 1.5rem;
            word-wrap: break-word;
            flex: 1;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
            min-width: 30px;
            text-align: center;
        }

        .close:hover {
            color: white;
        }

        .modal-body p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 15px;
            word-wrap: break-word;
        }

        .modal-body ul {
            color: #e0e0e0;
            margin-left: 20px;
        }

        .modal-body li {
            margin-bottom: 8px;
            word-wrap: break-word;
        }

        .attachment-link {
            color: #4285f4;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-right: 15px;
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .attachment-link:hover {
            color: #34a853;
            text-decoration: underline;
        }

        /* Messages */
        .message {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 100%;
            box-sizing: border-box;
        }

        .message.success {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            color: #34a853;
        }

        .message.error {
            background: rgba(234, 67, 53, 0.2);
            border: 1px solid rgba(234, 67, 53, 0.4);
            color: #ea4335;
        }

        .message.warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.4);
            color: #ffc107;
        }

        /* ✅ NOVO: Estilos para seleção de tipo de evento */
        .event-type-selector {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .type-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .type-option {
            cursor: pointer;
            display: block;
        }

        .type-option input[type="radio"] {
            display: none;
        }

        .type-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .type-option input[type="radio"]:checked + .type-label.pagamento-type {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.2);
            color: #4285f4;
        }

        .type-option input[type="radio"]:checked + .type-label.recebimento-type {
            border-color: #34a853;
            background: rgba(52, 168, 83, 0.2);
            color: #34a853;
        }

        .type-label:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        /* Loading Spinner */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .calendar-grid {
                min-width: 600px;
            }
            
            .calendar-day {
                min-height: 120px;
                max-height: 120px;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        @media (max-width: 768px) {
            #main-content-fluxo-caixa-hvc {
                padding: 1rem;
                margin-left: 0;
                width: 100vw;
            }
            
            #main-content-fluxo-caixa-hvc.sidebar-collapsed {
                margin-left: 0;
                width: 100vw;
            }
            
            .hvc-container,
            .google-section,
            .calendar-section,
            .filter-section,
            .monthly-summary,
            .payments-list-section {
                padding: 20px;
            }
            
            .hvc-title {
                font-size: 1.5rem;
            }
            
            .google-section h2 {
                font-size: 1.4rem;
            }
            
            .calendar-grid {
                font-size: 12px;
                min-width: 500px;
            }
            
            .calendar-day {
                min-height: 100px;
                max-height: 100px;
                padding: 4px;
            }
            
            .google-controls {
                flex-direction: column;
            }

            .calendar-header {
                flex-direction: column;
                gap: 15px;
            }

            .event-item {
                font-size: 9px;
            }

            .day-total {
                font-size: 8px;
            }
            
            .calendar-title {
                font-size: 1.2rem;
                min-width: auto;
            }
            
            .event-modal-content {
                margin: 2% auto;
                padding: 20px;
                width: 95%;
            }
            
            .modal-content {
                margin: 5% auto;
                padding: 20px;
                width: 95%;
            }

            .monthly-total {
                font-size: 2rem;
            }

            .monthly-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .payment-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .payment-name {
                min-width: auto;
            }

            .payments-filters {
                grid-template-columns: 1fr;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        @media (max-width: 480px) {
            .calendar-grid {
                min-width: 350px;
            }
            
            .calendar-day {
                min-height: 80px;
                max-height: 80px;
                padding: 2px;
            }
            
            .day-total {
                font-size: 7px;
                padding: 1px 2px;
            }
            
            .event-item {
                font-size: 8px;
                padding: 1px 3px;
            }

            .monthly-stats {
                grid-template-columns: 1fr;
            }

            .status-stats {
                grid-template-columns: 1fr;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /* ✅ NOVO: Estilos para criação de eventos */
        .event-creator-section {
            background: rgba(25, 25, 112, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
        }

        .payment-items-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .add-item-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            color: #ffffff;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: #ffffff;
            font-size: 14px;
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        .add-item-btn {
            background: linear-gradient(135deg, #4285f4, #1976d2);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-item-btn:hover {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }

        .items-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .item-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            color: #ffffff;
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .item-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .item-value {
            color: #4285f4;
            font-weight: 500;
            font-size: 16px;
        }

        .remove-item-btn {
            background: rgba(234, 67, 53, 0.8);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-item-btn:hover {
            background: rgba(234, 67, 53, 1);
            transform: scale(1.05);
        }

        .create-event-form {
            background: rgba(52, 168, 83, 0.1);
            border: 1px solid rgba(52, 168, 83, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .create-event-btn {
            background: linear-gradient(135deg, #34a853, #2e7d32);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .create-event-btn:hover {
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
        }

        .cancel-event-btn {
            background: rgba(108, 117, 125, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cancel-event-btn:hover {
            background: rgba(108, 117, 125, 1);
            transform: translateY(-2px);
        }

        /* ✅ NOVO: Estilos para ações de eventos */
        .event-actions {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
        }

        .btn-delete {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-delete:hover {
            background: linear-gradient(135deg, #d33b2c, #b71c1c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .btn-delete:active {
            transform: translateY(0);
        }

        /* ✅ NOVO: Estilos para edição de eventos */
                .edit-description-section {
                    background: rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    padding: 15px;
                    margin: 15px 0;
                }
                
                .edit-description-textarea {
                    width: 100%;
                    min-height: 120px;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    border-radius: 6px;
                    padding: 10px;
                    color: #ffffff;
                    font-size: 14px;
                    font-family: inherit;
                    resize: vertical;
                    box-sizing: border-box;
                }
                
                .edit-description-textarea:focus {
                    outline: none;
                    border-color: #4285f4;
                    background: rgba(255, 255, 255, 0.15);
                }
                
                .edit-description-textarea::placeholder {
                    color: rgba(255, 255, 255, 0.5);
                }
                
                .edit-buttons {
                    display: flex;
                    gap: 10px;
                    margin-top: 10px;
                    flex-wrap: wrap;
                }
                
                .btn-edit {
                    background: rgba(66, 133, 244, 0.3);
                    border: 1px solid #4285f4;
                    color: #4285f4;
                    padding: 8px 16px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                }
                
                .btn-edit:hover {
                    background: rgba(66, 133, 244, 0.5);
                    color: #ffffff;
                }
                
                .btn-save {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                }
                
                .btn-save:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }
                
                .btn-cancel {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                }
                
                .btn-cancel:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }
                
                .btn-edit:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                
                .edit-loading {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 14px;
                }

                /* ✅ NOVO: CSS para seção de criação de eventos */
                .event-creator-section {
                    background: rgba(25, 25, 112, 0.3);
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 15px;
                    padding: 30px;
                    margin-bottom: 30px;
                }

                .event-creator-section h3, .event-creator-section h4 {
                    color: #ffffff;
                    margin-bottom: 20px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .payment-items-container {
                    margin-bottom: 30px;
                }

                .add-item-form {
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 10px;
                    padding: 20px;
                    margin-bottom: 20px;
                }

                .form-row {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 15px;
                    margin-bottom: 15px;
                }

                .form-group {
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                }

                .form-group.full-width {
                    grid-column: 1 / -1;
                }

                .form-group label {
                    color: rgba(255, 255, 255, 0.8);
                    font-size: 0.9rem;
                    font-weight: 500;
                }

                .form-group input, .form-group select {
                    background: rgba(66, 133, 244, 0.8) !important; /* ✅ NOVO: Fundo azul para visibilidade */
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 6px;
                    padding: 10px 12px;
                    color: #ffffff !important;
                    font-size: 0.9rem;
                }

                .form-group input:focus, .form-group select:focus {
                    outline: none;
                    border-color: #4285f4;
                    background: rgba(66, 133, 244, 0.9) !important;
                }

                .form-group input::placeholder {
                    color: rgba(255, 255, 255, 0.7) !important;
                }

                .form-group select option {
                    background: rgba(66, 133, 244, 0.9) !important;
                    color: #ffffff !important;
                }

                .add-item-btn {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .add-item-btn:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }

                .items-list {
                    max-height: 300px;
                    overflow-y: auto;
                    border-radius: 8px;
                    background: rgba(255, 255, 255, 0.05);
                }

                .item-card {
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 10px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    gap: 15px;
                }

                .item-info {
                    flex: 1;
                }

                .item-name {
                    color: #ffffff;
                    font-weight: bold;
                    font-size: 1.1rem;
                    margin-bottom: 5px;
                }

                .item-details {
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 0.9rem;
                }

                .item-value {
                    color: #ffc107;
                    font-weight: bold;
                    font-size: 1.2rem;
                    background: rgba(255, 193, 7, 0.2);
                    padding: 5px 10px;
                    border-radius: 5px;
                }

                .remove-item-btn {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                    padding: 8px;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }

                .remove-item-btn:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }

                .create-event-form {
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 10px;
                    padding: 20px;
                    margin-top: 20px;
                }

                .form-actions {
                    display: flex;
                    gap: 15px;
                    margin-top: 20px;
                    flex-wrap: wrap;
                }

                .create-event-btn {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .create-event-btn:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }

                .cancel-event-btn {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .cancel-event-btn:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }

                .btn-success {
                    background: linear-gradient(135deg, #34a853, #2e7d32);
                    color: white;
                }

                .btn-success:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
                }

                /* =================================================================
                   MODAL DE RECORRÊNCIA - Estilo Google Calendar
                   ================================================================= */
                .recurrence-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                }

                .recurrence-modal-content {
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 16px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    animation: modalSlideIn 0.3s ease-out;
                }

                @keyframes modalSlideIn {
                    from {
                        opacity: 0;
                        transform: translateY(-30px) scale(0.95);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0) scale(1);
                    }
                }

                .recurrence-modal-content h3 {
                    color: #ffffff;
                    font-size: 1.5rem;
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .recurrence-modal-content h3 i {
                    color: #ffc107;
                }

                .recurrence-modal-content p {
                    color: rgba(255, 255, 255, 0.8);
                    margin-bottom: 15px;
                    line-height: 1.5;
                }

                .recurrence-modal-content p strong {
                    color: #ffffff;
                }

                .recurrence-options {
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    margin: 25px 0;
                }

                .recurrence-btn {
                    background: rgba(255, 255, 255, 0.05);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 12px;
                    padding: 18px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: left;
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    color: #ffffff;
                }

                .recurrence-btn:hover {
                    background: rgba(255, 255, 255, 0.1);
                    border-color: rgba(255, 255, 255, 0.4);
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
                }

                .recurrence-btn i {
                    font-size: 1.5rem;
                    color: #4285f4;
                    min-width: 24px;
                }

                .recurrence-btn-content {
                    flex: 1;
                }

                .recurrence-btn span {
                    display: block;
                    font-weight: 600;
                    font-size: 1.1rem;
                    margin-bottom: 5px;
                }

                .recurrence-btn small {
                    display: block;
                    color: rgba(255, 255, 255, 0.6);
                    font-size: 0.9rem;
                }

                .recurrence-actions {
                    display: flex;
                    justify-content: flex-end;
                    gap: 15px;
                    margin-top: 25px;
                    padding-top: 20px;
                    border-top: 1px solid rgba(255, 255, 255, 0.1);
                }

                .recurrence-cancel {
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    color: #ffffff;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                }

                .recurrence-cancel:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                /* Responsividade para o modal */
                @media (max-width: 768px) {
                    .recurrence-modal-content {
                        margin: 20px;
                        padding: 25px;
                        max-width: none;
                        width: calc(100% - 40px);
                    }

                    .recurrence-btn {
                        padding: 15px;
                        gap: 12px;
                    }

                    .recurrence-btn i {
                        font-size: 1.3rem;
                    }

                    .recurrence-btn span {
                        font-size: 1rem;
                    }

                    .recurrence-actions {
                        flex-direction: column;
                    }

                    .recurrence-cancel {
                        width: 100%;
                        text-align: center;
                    }
                }

        /* =================================================================
           MODAL DE RECORRÊNCIA PERSONALIZADA - Estilo Google Calendar
           ================================================================= */
        .custom-recurrence-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            backdrop-filter: blur(5px);
        }

        .custom-recurrence-modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
            max-height: 80vh;
            overflow-y: auto;
        }

        .custom-recurrence-modal-content h3 {
            color: #ffffff;
            font-size: 1.4rem;
            margin-bottom: 25px;
            text-align: center;
        }

        .recurrence-form-group {
            margin-bottom: 20px;
        }

        .recurrence-form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .recurrence-form-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .recurrence-form-row span {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
        }

        .recurrence-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            color: #ffffff;
            font-size: 0.95rem;
            width: 60px;
            text-align: center;
        }

        .recurrence-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            color: #ffffff;
            font-size: 0.95rem;
            min-width: 120px;
        }

        .recurrence-input:focus,
        .recurrence-select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
        }

        .weekdays-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .weekday-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .weekday-btn:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.2);
        }

        .weekday-btn.selected {
            background: #4285f4;
            border-color: #4285f4;
            color: #ffffff;
        }

        .end-options {
            margin-top: 20px;
        }

        .end-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .end-option input[type="radio"] {
            margin: 0;
            transform: scale(1.2);
        }

        .end-option label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .end-date-input,
        .end-count-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px 10px;
            color: #ffffff;
            font-size: 0.9rem;
            width: 120px;
        }

        .custom-recurrence-actions {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .custom-recurrence-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .custom-recurrence-cancel {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }

        .custom-recurrence-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .custom-recurrence-confirm {
            background: #4285f4;
            color: #ffffff;
        }

        .custom-recurrence-confirm:hover {
            background: #3367d6;
            transform: translateY(-1px);
        }

        /* Responsividade para o modal personalizado */
        @media (max-width: 768px) {
            .custom-recurrence-modal-content {
                margin: 20px;
                padding: 25px;
                max-width: none;
                width: calc(100% - 40px);
            }

            .recurrence-form-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .weekdays-selector {
                justify-content: center;
            }

            .custom-recurrence-actions {
                flex-direction: column;
            }

            .custom-recurrence-btn {
                width: 100%;
                text-align: center;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /* ✅ NOVO: Estilos para upload de PDF */
        .pdf-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #fafafa;
            transition: all 0.3s ease;
            position: relative;
        }

        .pdf-upload-container:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .pdf-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .pdf-upload-info {
            pointer-events: none;
            color: #666;
        }

        .pdf-upload-info i {
            font-size: 2em;
            color: #007bff;
            margin-bottom: 10px;
            display: block;
        }

        .pdf-preview-list {
            margin-top: 15px;
            text-align: left;
        }

        .pdf-preview-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .pdf-preview-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .pdf-preview-info i {
            color: #dc3545;
            margin-right: 10px;
            font-size: 1.2em;
        }

        .pdf-preview-details {
            flex: 1;
        }

        .pdf-preview-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 2px;
        }

        .pdf-preview-size {
            font-size: 0.9em;
            color: #666;
        }

        .pdf-preview-actions {
            display: flex;
            gap: 5px;
        }

        .pdf-remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .pdf-remove-btn:hover {
            background: #c82333;
        }

        .pdf-view-btn {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .pdf-view-btn:hover {
            background: #0056b3;
        }

        .pdf-upload-container.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .pdf-upload-error {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .pdf-upload-success {
            color: #28a745;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* ✅ NOVO: Estilos para seção de anexos no modal */
        .event-attachments-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #f9f9f9;
        }

        .event-attachments-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1em;
        }

        .event-attachments-list {
            margin-bottom: 15px;
        }

        .attachment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .attachment-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .attachment-info i {
            color: #dc3545;
            margin-right: 10px;
            font-size: 1.2em;
        }

        .attachment-name {
            font-weight: bold;
            color: #333;
        }

        .attachment-actions {
            display: flex;
            gap: 5px;
        }

        .btn-view-attachment, .btn-remove-attachment {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .btn-remove-attachment {
            background: #dc3545;
        }

        .btn-view-attachment:hover {
            background: #0056b3;
        }

        .btn-remove-attachment:hover {
            background: #c82333;
        }

        .attachment-upload-section {
            text-align: center;
        }

        .btn-add-pdf {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s ease;
        }

        .btn-add-pdf:hover {
            background: #218838;
        }

        .no-attachments {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 10px 0;
        }


    </style>

    <script>
        // =================================================================
        // DEFINIR FUNÇÕES GLOBAIS ANTES DOS SCRIPTS DO GOOGLE
        // =================================================================
        
        // Configurações
        const CLIENT_ID = '314578730498-ghkttnk7g4729g206tk3gsac1qtghhme.apps.googleusercontent.com';
        const DISCOVERY_DOC = ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest', 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
        const SCOPES = 'https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let isGoogleConnected = false;
        let filteredEvents = [];
        let currentDate = new Date();
        let currentYear = currentDate.getFullYear(); // ✅ VARIÁVEL GLOBAL
        let currentMonth = currentDate.getMonth();   // ✅ VARIÁVEL GLOBAL
        let allPaymentsList = []; // ✅ NOVO: Lista completa de pagamentos
        let filteredPaymentsList = []; // ✅ NOVO: Lista filtrada
        let allReceivingsList = []; // ✅ NOVO: Lista completa de recebimentos
        let filteredReceivingsList = []; // ✅ NOVO: Lista filtrada de recebimentos
        // ✅ NOVO: Variáveis para criação de eventos
        let paymentItems = [];
        let currentEditingEvent = null;
        let isEditingDescription = false;
        let originalDescription = '';
        // ✅ REMOVIDO: Declaração duplicada removida
        let allEventAttachments = []; // Todos os anexos do evento

        // ===================================================================
        // FUNÇÃO PARA TRATAR ERROS 401 AUTOMATICAMENTE
        // ===================================================================
        
        /**
         * Faz uma chamada autenticada para a API do Google com tratamento de erro 401
         */
        async function makeAuthenticatedRequest(requestFunction, accountEmail = null) {
            try {
                return await requestFunction();
            } catch (error) {
                console.error('Erro na requisição:', error);
                
                // Se for erro 401 (token expirado)
                if (error.status === 401 || (error.result && error.result.error && error.result.error.code === 401)) {
                    console.log('🔄 Token expirado detectado para:', accountEmail || 'nova autenticação');
                    
                    if (accountEmail && window.connectedAccounts) {
                        // Para contas já conectadas, marcar como erro e pedir reconexão
                        const account = window.connectedAccounts.find(acc => acc.email === accountEmail);
                        if (account) {
                            console.log(`❌ Token expirado para conta existente: ${accountEmail}`);
                            
                            // Marcar conta como com erro
                            if (typeof updateAccountStatus === 'function') {
                                updateAccountStatus(accountEmail, 'error');
                            }
                            
                            const errorMsg = `Token expirado para ${accountEmail}. Clique em "Reconectar" para esta conta.`;
                            if (typeof showMessage === 'function') {
                                showMessage(errorMsg, 'error');
                            }
                            
                            throw new Error(errorMsg);
                        }
                    } else {
                        // Para nova autenticação, apenas repassar o erro
                        console.log('🔄 Erro 401 durante nova autenticação - processo normal');
                        throw error;
                    }
                }
                
                // Se não for erro 401, repassar o erro original
                throw error;
            }
        }

        // ✅ REMOVIDO: Função duplicada removida

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function removePaymentItem(itemId) {
            paymentItems = paymentItems.filter(item => item.id !== itemId);
            renderPaymentItems();
            
            // Esconder formulário de evento se não houver itens
            if (paymentItems.length === 0) {
                document.getElementById('createEventForm').style.display = 'none';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function renderPaymentItems() {
            const itemsList = document.getElementById('itemsList');
            
            if (paymentItems.length === 0) {
                itemsList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Nenhum item adicionado ainda.</p>';
                return;
            }

            itemsList.innerHTML = paymentItems.map(item => `
                <div class="item-card">
                    <div class="item-info">
                        <div class="item-name">${item.nome}</div>
                        <div class="item-details">
                            ${item.tipo ? `<span>Tipo: ${item.tipo}</span>` : ''}
                            ${item.subtipo ? `<span>Subtipo: ${item.subtipo}</span>` : ''}
                            ${item.categoria ? `<span>Categoria: ${item.categoria}</span>` : ''}
                            ${item.status ? `<span>Status: ${item.status}</span>` : ''}
                            ${item.detalhe ? `<span>Detalhe: ${item.detalhe}</span>` : ''}
                            ${item.pdfs && item.pdfs.length > 0 ? `<span><i class="fas fa-file-pdf"></i> ${item.pdfs.length} PDF(s) anexado(s)</span>` : ''}
                        </div>
                    </div>
                    <div class="item-value">${formatCurrency(item.valor)}</div>
                    <button class="edit-item-btn" onclick="openEditItemModal(${item.id})">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="remove-item-btn" onclick="removePaymentItem(${item.id})">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function clearItemForm() {
            document.getElementById('itemTipo').value = '';
            document.getElementById('itemSubtipo').value = '';
            document.getElementById('itemCategoria').value = '';
            document.getElementById('itemNome').value = '';
            document.getElementById('itemValor').value = '';
            document.getElementById('itemStatus').value = '';
            document.getElementById('itemDetalhe').value = '';
        }

        function generateEventDescription() {
            return paymentItems.map(item => {
                const parts = [];
                if (item.tipo) parts.push(item.tipo);
                if (item.subtipo) parts.push(item.subtipo);
                if (item.categoria) parts.push(item.categoria);
                parts.push(item.nome);
                
                // Formatar valor com status (sem hífen entre eles)
                let valorFormatado = formatCurrency(item.valor);
                if (item.status) {
                    valorFormatado += ` (${item.status})`;
                }
                parts.push(valorFormatado);
                
                if (item.detalhe) parts.push(item.detalhe);
                
                return parts.join(' - ');
            }).join('\n');
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function cancelEventCreation() {
            if (paymentItems.length > 0) {
                if (confirm('Tem certeza que deseja cancelar? Todos os itens serão perdidos.')) {
                    paymentItems = [];
                    renderPaymentItems();
                    document.getElementById('createEventForm').style.display = 'none';
                }
            } else {
                document.getElementById('createEventForm').style.display = 'none';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // ✅ NOVO: Função para alternar seção de criação de eventos
        function toggleEventCreator() {
            const eventCreatorSection = document.getElementById('eventCreatorSection');
            const button = document.getElementById('createEventButton');
            
            if (eventCreatorSection.style.display === 'none' || eventCreatorSection.style.display === '') {
                eventCreatorSection.style.display = 'block';
                if (button) {
                    button.innerHTML = '<i class="fas fa-times"></i> Fechar Criador';
                }
                
                // Aguardar um pouco para garantir que o DOM foi atualizado
                setTimeout(async () => {
                    populateAccountSelector();
                }, 100);
                
            } else {
                eventCreatorSection.style.display = 'none';
                if (button) {
                    button.innerHTML = '<i class="fas fa-plus-circle"></i> Criar Evento';
                }
                clearEventForm();
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Atualiza a visibilidade do botão criar evento baseado nas contas conectadas
         */
        function updateCreateEventButtonVisibility() {
            const button = document.getElementById('createEventButton');
            if (!button) return;
            
            const hasConnectedAccounts = window.connectedAccounts && 
                                        window.connectedAccounts.some(account => account.isConnected);
            
            if (hasConnectedAccounts) {
                button.style.display = 'inline-flex';
            } else {
                button.style.display = 'none';
                // Fechar criador se estiver aberto
                const section = document.getElementById('eventCreatorSection');
                if (section && section.style.display === 'block') {
                    toggleEventCreator();
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Popula o seletor de contas com as contas conectadas
         */
        function populateAccountSelector() {
            console.log('🔍 Populando seletor de contas...');
            const selector = document.getElementById('eventAccount');
            if (!selector) {
                console.error('❌ Seletor de conta não encontrado');
                return;
            }
            
            // Limpar opções existentes (exceto a primeira)
            while (selector.children.length > 1) {
                selector.removeChild(selector.lastChild);
            }
            
            // Buscar contas de múltiplas fontes
            let accounts = [];
            
            // Fonte 1: window.connectedAccounts
            if (window.connectedAccounts && Array.isArray(window.connectedAccounts)) {
                console.log('📋 Contas encontradas em window.connectedAccounts:', window.connectedAccounts.length);
                console.log('🔍 Estrutura das contas:', window.connectedAccounts.map(acc => ({
                    email: acc.email,
                    isConnected: acc.isConnected,
                    connected: acc.connected,
                    status: acc.status
                })));
                
                // Verificar múltiplas propriedades de conexão
                accounts = window.connectedAccounts.filter(account => {
                    if (!account || !account.email) return false;
                    
                    // Verificar diferentes formas de indicar conexão
                    return account.isConnected === true || 
                           account.connected === true || 
                           account.status === 'connected' ||
                           account.status === 'active' ||
                           (account.accessToken && account.accessToken.length > 0);
                });
                
                console.log('✅ Contas filtradas como conectadas:', accounts.length);
            }
            
            // Fonte 2: window.accounts (fallback)
            if (accounts.length === 0 && window.accounts && Array.isArray(window.accounts)) {
                console.log('📋 Contas encontradas em window.accounts:', window.accounts.length);
                accounts = window.accounts.filter(account => account && (account.isConnected || account.connected));
            }
            
            // Fonte 3: localStorage (fallback)
            if (accounts.length === 0) {
                try {
                    const storedAccounts = localStorage.getItem('connectedAccounts');
                    if (storedAccounts) {
                        const parsedAccounts = JSON.parse(storedAccounts);
                        console.log('📋 Contas encontradas no localStorage:', parsedAccounts.length);
                        accounts = parsedAccounts.filter(account => account && account.isConnected);
                    }
                } catch (error) {
                    console.warn('⚠️ Erro ao ler contas do localStorage:', error);
                }
            }
            
            // Fonte 4: Buscar no DOM (fallback)
            if (accounts.length === 0) {
                const accountElements = document.querySelectorAll('.account-item[data-email]');
                console.log('📋 Elementos de conta encontrados no DOM:', accountElements.length);
                accountElements.forEach(element => {
                    const email = element.getAttribute('data-email');
                    const isConnected = element.classList.contains('connected') || 
                                      element.querySelector('.status-connected') !== null;
                    if (email && isConnected) {
                        accounts.push({ email: email, isConnected: true });
                    }
                });
            }
            
            // Fallback: Se nenhuma conta foi detectada como conectada, usar todas as contas disponíveis
            if (accounts.length === 0 && window.connectedAccounts && window.connectedAccounts.length > 0) {
                console.log('⚠️ Nenhuma conta detectada como conectada, usando todas as contas disponíveis');
                accounts = window.connectedAccounts.filter(account => account && account.email);
            }
            
            console.log('✅ Total de contas conectadas encontradas:', accounts.length);
            console.log('📧 Contas:', accounts.map(acc => acc.email));
            
            // Adicionar contas ao seletor
            if (accounts.length > 0) {
                accounts.forEach(account => {
                    if (account.email) {
                        const option = document.createElement('option');
                        option.value = account.email;
                        option.textContent = account.email;
                        selector.appendChild(option);
                        console.log('➕ Conta adicionada ao seletor:', account.email);
                    }
                });
                
                // Selecionar a primeira conta por padrão
                if (selector.children.length > 1) {
                    selector.selectedIndex = 1;
                }
            } else {
                console.warn('⚠️ Nenhuma conta conectada encontrada');
                // Adicionar opção informativa
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Nenhuma conta conectada encontrada';
                option.disabled = true;
                selector.appendChild(option);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // ✅ NOVO: Funções para gerenciar itens de pagamento
        window.addPaymentItem = function addPaymentItem() {
            // ✅ NOVO: Validar tipo de evento selecionado
            const eventType = document.querySelector('input[name="eventType"]:checked');
            if (!eventType) {
                alert('Selecione o tipo de evento (PAGAMENTO ou RECEBIMENTO) primeiro!');
                return;
            }

            const tipo = document.getElementById('itemTipo').value.trim();
            const subtipo = document.getElementById('itemSubtipo').value.trim();
            const categoria = document.getElementById('itemCategoria').value.trim();
            const nome = document.getElementById('itemNome').value.trim();
            
            // ✅ NOVO: Parsing correto do valor formatado
            const valorText = document.getElementById('itemValor').value;
            const valor = parseFloat(valorText.replace(/[^\d,]/g, '').replace(',', '.'));
            
            const status = document.getElementById('itemStatus').value;
            const detalhe = document.getElementById('itemDetalhe').value.trim();

            // Validação
            if (!nome) {
                alert('Nome do item é obrigatório!');
                return;
            }
            if (!valor || valor <= 0) {
                alert('Valor deve ser maior que zero!');
                return;
            }
            if (!status) {
                alert('Selecione um status para o item!');
                return;
            }

            // Criar item
            const item = {
                id: Date.now(),
                tipo,
                subtipo,
                categoria,
                nome,
                valor,
                status,
                detalhe
            };

            if (!window.paymentItems) {
                window.paymentItems = [];
            }
            window.paymentItems.push(item);
            renderPaymentItems();
            clearItemForm();
            
            // Mostrar formulário de evento se houver itens
            if (window.paymentItems.length > 0) {
                document.getElementById('createEventForm').style.display = 'block';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function removePaymentItem(itemId) {
            if (!window.paymentItems) return;
            
            window.paymentItems = window.paymentItems.filter(item => item.id !== itemId);
            renderPaymentItems();
            
            // Esconder formulário de evento se não houver itens
            if (window.paymentItems.length === 0) {
                document.getElementById('createEventForm').style.display = 'none';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function renderPaymentItems() {
            const itemsList = document.getElementById('itemsList');
            if (!itemsList) return;
            
            if (!window.paymentItems) {
                window.paymentItems = [];
            }
            
            if (window.paymentItems.length === 0) {
                itemsList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Nenhum item adicionado ainda.</p>';
                return;
            }

            itemsList.innerHTML = window.paymentItems.map(item => `
                <div class="item-card">
                    <div class="item-info">
                        <div class="item-name">${item.nome}</div>
                        <div class="item-details">
                            ${item.tipo ? `<span>Tipo: ${item.tipo}</span>` : ''}
                            ${item.subtipo ? `<span>Subtipo: ${item.subtipo}</span>` : ''}
                            ${item.categoria ? `<span>Categoria: ${item.categoria}</span>` : ''}
                            ${item.status ? `<span>Status: ${item.status}</span>` : ''}
                            ${item.detalhe ? `<span>Detalhe: ${item.detalhe}</span>` : ''}
                        </div>
                    </div>
                    <div class="item-value">${formatCurrency(item.valor)}</div>
                    <button class="edit-item-btn" onclick="openEditItemModal(${item.id})">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="remove-item-btn" onclick="removePaymentItem(${item.id})">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function clearItemForm() {
            const fields = ['itemTipo', 'itemSubtipo', 'itemCategoria', 'itemNome', 'itemValor', 'itemStatus', 'itemDetalhe'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) field.value = '';
            }); // Fechamento do DOMContentLoaded
        }

        function clearEventForm() {
            // Limpar itens de pagamento
            if (window.paymentItems) {
                window.paymentItems = [];
            }
            renderPaymentItems();
            
            // Limpar formulário de item
            clearItemForm();
            
            // Limpar formulário de evento
            const eventDate = document.getElementById('eventDate');
            const eventTime = document.getElementById('eventTime');
            const eventRecurrence = document.getElementById('eventRecurrence');
            const eventAccount = document.getElementById('eventAccount');
            
            if (eventDate) eventDate.value = '';
            if (eventTime) eventTime.value = '09:00';
            if (eventRecurrence) eventRecurrence.value = 'NONE';
            if (eventAccount) eventAccount.value = '';
            
            // Esconder formulário de evento
            const createEventForm = document.getElementById('createEventForm');
            if (createEventForm) {
                createEventForm.style.display = 'none';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function generateEventDescription() {
            if (!window.paymentItems || window.paymentItems.length === 0) return '';
            
            return window.paymentItems.map(item => {
                const parts = [];
                if (item.tipo) parts.push(item.tipo);
                if (item.subtipo) parts.push(item.subtipo);
                if (item.categoria) parts.push(item.categoria);
                parts.push(item.nome);
                
                // Formatar valor com status (sem hífen entre eles)
                let valorFormatado = formatCurrency(item.valor);
                if (item.status) {
                    valorFormatado += ` (${item.status})`;
                }
                parts.push(valorFormatado);
                
                if (item.detalhe) parts.push(item.detalhe);
                
                return parts.join(' - ');
            }).join('\n');
        }

        /**
         * Cria evento de pagamento na conta selecionada
         */
        window.createPaymentEvent = async function createPaymentEvent() {
            // ✅ NOVO: Validar tipo de evento selecionado
            const eventType = document.querySelector('input[name="eventType"]:checked');
            if (!eventType) {
                alert('Selecione o tipo de evento (PAGAMENTO ou RECEBIMENTO) primeiro!');
                return;
            }

            if (!window.paymentItems || window.paymentItems.length === 0) {
                alert(`Adicione pelo menos um item de ${eventType.value.toLowerCase()}!`);
                return;
            }

            const eventDate = document.getElementById('eventDate').value;
            const eventTime = document.getElementById('eventTime').value;
            const recurrence = document.getElementById('eventRecurrence').value;
            const selectedAccount = document.getElementById('eventAccount').value;

            if (!eventDate) {
                alert('Data é obrigatória!');
                return;
            }
            if (!recurrence || recurrence === '') {
                alert('Recorrência é obrigatória!');
                return;
            }
            if (!selectedAccount) {
                alert('Selecione uma conta Google!');
                return;
            }

            try {
                console.log('🔍 Buscando conta selecionada:', selectedAccount);
                console.log('📋 Contas disponíveis:', window.connectedAccounts);
                
                // Encontrar a conta selecionada com múltiplas verificações
                let account = null;
                
                if (window.connectedAccounts && Array.isArray(window.connectedAccounts)) {
                    account = window.connectedAccounts.find(acc => acc && acc.email === selectedAccount);
                }
                
                if (!account) {
                    throw new Error(`Conta ${selectedAccount} não encontrada na lista de contas`);
                }
                
                console.log('✅ Conta encontrada:', account);
                
                // Verificar se a conta tem token de acesso
                let accessToken = account.accessToken || account.access_token || account.token;
                
                if (!accessToken) {
                    console.warn('⚠️ Token não encontrado na conta, tentando usar token global...');
                    // Fallback: usar token global se disponível
                    if (gapi.client.getToken()) {
                        accessToken = gapi.client.getToken().access_token;
                        console.log('✅ Usando token global do GAPI');
                    } else {
                        throw new Error('Nenhum token de acesso disponível para a conta selecionada');
                    }
                }
                
                console.log('🔑 Token de acesso encontrado:', accessToken ? 'Sim' : 'Não');

                // Configurar cliente para a conta selecionada
                if (accessToken) {
                    gapi.client.setToken({ access_token: accessToken });
                    console.log('✅ Token configurado no cliente GAPI');
                }

                // Gerar título e descrição do evento
                const eventTitle = eventType.value; // ✅ NOVO: Usar tipo selecionado
                const eventDescription = generateEventDescription();

                // Configurar data e hora
                const startDateTime = new Date(`${eventDate}T${eventTime}:00`);
                const endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // 1 hora depois

                // Configurar evento
                const event = {
                    summary: eventTitle,
                    description: eventDescription,
                    start: {
                        dateTime: startDateTime.toISOString(),
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    },
                    end: {
                        dateTime: endDateTime.toISOString(),
                        timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                    }
                };

                // Adicionar recorrência se necessário
                const rrule = generateRRule(recurrence, eventDate);
                if (rrule) {
                    event.recurrence = [`RRULE:${rrule}`];
                }

                console.log('🔄 Criando evento na conta:', selectedAccount);
                console.log('📅 Evento:', event);
                console.log('🔑 Token atual do cliente:', gapi.client.getToken());

                // Verificar se o cliente GAPI está pronto
                if (!gapi.client.calendar) {
                    console.error('❌ Cliente do Google Calendar não está inicializado');
                    throw new Error('Cliente do Google Calendar não está disponível');
                }

                // Criar evento
                console.log('📤 Enviando requisição para criar evento...');
                const response = await makeAuthenticatedRequest(
                    () => gapi.client.calendar.events.insert({
                        calendarId: 'primary',
                        resource: event
                    }),
                    selectedAccount
                );

                console.log('📥 Resposta da API:', response);

                if (response.status === 200 || response.status === 201) {
                    console.log('✅ Evento criado com sucesso!');
                    showMessage(`Evento criado com sucesso na conta ${selectedAccount}!`, 'success');
                    
                    // Armazenar informações do evento criado para uso posterior
                    const createdEvent = response.result;
                    window.lastCreatedEvent = {
                        id: createdEvent.id,
                        account: selectedAccount,
                        summary: createdEvent.summary,
                        start: createdEvent.start
                    };
                    
                    console.log('📅 Evento criado:', window.lastCreatedEvent);
                    
                    // Limpar formulário
                    clearEventForm();
                    
                    // Fechar criador de eventos
                    toggleEventCreator();
                    
                    // Sincronizar eventos automaticamente
                    console.log('🔄 Iniciando sincronização automática...');
                    
                    // Tentar múltiplas formas de sincronização
                    let syncSuccess = false;
                    
                    // Método 1: syncAccountEvents
                    if (typeof syncAccountEvents === 'function') {
                        try {
                            console.log('🔄 Método 1: syncAccountEvents...');
                            await syncAccountEvents(account);
                            syncSuccess = true;
                        } catch (error) {
                            console.warn('⚠️ syncAccountEvents falhou:', error);
                        }
                    }
                    
                    // Método 2: syncAllAccounts
                    if (!syncSuccess && typeof syncAllAccounts === 'function') {
                        try {
                            console.log('🔄 Método 2: syncAllAccounts...');
                            await syncAllAccounts();
                            syncSuccess = true;
                        } catch (error) {
                            console.warn('⚠️ syncAllAccounts falhou:', error);
                        }
                    }
                    
                    // Método 3: loadEvents
                    if (!syncSuccess && typeof loadEvents === 'function') {
                        try {
                            console.log('🔄 Método 3: loadEvents...');
                            await loadEvents();
                            syncSuccess = true;
                        } catch (error) {
                            console.warn('⚠️ loadEvents falhou:', error);
                        }
                    }
                    
                    // Método 4: Recarregar eventos manualmente
                    if (!syncSuccess) {
                        console.log('🔄 Método 4: Recarregamento manual...');
                        setTimeout(async () => {
                            // Tentar clicar no botão de sincronização se existir
                            const syncButtons = document.querySelectorAll('[onclick*="sync"], .sync-btn, .sincronizar-btn');
                            if (syncButtons.length > 0) {
                                console.log('🔄 Clicando em botão de sincronização...');
                                syncButtons[0].click();
                            } else {
                                console.log('🔄 Recarregando página em 2 segundos...');
                                setTimeout(async () => {
                                    window.location.reload();
                                }, 2000);
                            }
                        }, 1000);
                    }
                    
                    if (syncSuccess) {
                        console.log('✅ Sincronização automática concluída!');
                    }
                    
                } else {
                    throw new Error(`Erro HTTP ao criar evento: ${response.status} - ${response.statusText}`);
                }

            } catch (error) {
                console.error('❌ Erro ao criar evento:', error);
                showMessage(`Erro ao criar evento: ${error.message}`, 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Gera RRULE baseado na seleção do dropdown
         */
        function generateRRule(recurrenceType, eventDate) {
            const date = new Date(eventDate);
            const dayOfWeek = date.getDay();
            const dayOfMonth = date.getDate();
            const month = date.getMonth() + 1;
            
            // Mapear dias da semana para RRULE
            const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
            const currentDay = rruleDays[dayOfWeek];
            
            switch (recurrenceType) {
                case 'NONE':
                    return null;
                    
                case 'DAILY':
                    return 'FREQ=DAILY';
                    
                case 'WEEKLY':
                    return `FREQ=WEEKLY;BYDAY=${currentDay}`;
                    
                case 'MONTHLY':
                    // Calcular qual semana do mês (primeira, segunda, terceira, etc.)
                    const weekOfMonth = Math.ceil(dayOfMonth / 7);
                    return `FREQ=MONTHLY;BYDAY=${weekOfMonth}${currentDay}`;
                    
                case 'YEARLY':
                    return `FREQ=YEARLY;BYMONTH=${month};BYMONTHDAY=${dayOfMonth}`;
                    
                case 'WEEKDAYS':
                    return 'FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR';
                    
                case 'CUSTOM_GENERATED':
                    return window.customRRule || null;
                    
                default:
                    return null;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // Função para formatar moeda
        function formatCurrency(value) {
            return new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
            }).format(value);
        }

        /**
         * Função interna para exclusão real de eventos (evita loop infinito)
         */
        async function realDeleteCalendarEvent(eventId, accountEmail = null) {
            if (!eventId) {
                showMessage('ID do evento não encontrado', 'error');
                return;
            }

            // Confirmar exclusão
            const confirmDelete = confirm(`Tem certeza que deseja excluir este evento?\n\nEsta ação não pode ser desfeita.`);
            if (!confirmDelete) {
                return;
            }

            try {
                console.log('🗑️ Excluindo evento:', eventId, 'da conta:', accountEmail);

                // Encontrar a conta se especificada
                if (accountEmail && window.connectedAccounts) {
                    const account = window.connectedAccounts.find(acc => acc.email === accountEmail);
                    if (account) {
                        let accessToken = account.accessToken || account.access_token || account.token;
                        if (accessToken) {
                            gapi.client.setToken({ access_token: accessToken });
                            console.log('✅ Token configurado para conta:', accountEmail);
                        }
                    }
                }

                // Verificar se o cliente está inicializado
                if (!gapi.client.calendar) {
                    throw new Error('Cliente do Google Calendar não está disponível');
                }

                // Excluir evento
                console.log('📤 Enviando requisição para excluir evento...');
                const response = await makeAuthenticatedRequest(
                    () => gapi.client.calendar.events.delete({
                        calendarId: 'primary',
                        eventId: eventId
                    }),
                    accountEmail
                );

                console.log('📥 Resposta da exclusão:', response);

                if (response.status === 204 || response.status === 200) {
                    console.log('✅ Evento excluído com sucesso!');
                    showMessage('Evento excluído com sucesso!', 'success');
                    
                    // Recarregar eventos se a função existir
                    if (typeof loadEvents === 'function') {
                        console.log('🔄 Recarregando eventos...');
                        await loadEvents();
                    } else if (typeof syncAllAccounts === 'function') {
                        console.log('🔄 Sincronizando todas as contas...');
                        await syncAllAccounts();
                    } else {
                        // Fallback: recarregar a página após um delay
                        setTimeout(async () => {
                            window.location.reload();
                        }, 1500);
                    }
                    
                } else {
                    throw new Error(`Erro HTTP ao excluir evento: ${response.status}`);
                }

            } catch (error) {
                console.error('❌ Erro ao excluir evento:', error);
                
                let errorMessage = 'Erro ao excluir evento';
                if (error.message.includes('404')) {
                    errorMessage = 'Evento não encontrado (pode já ter sido excluído)';
                } else if (error.message.includes('403')) {
                    errorMessage = 'Sem permissão para excluir este evento';
                } else if (error.message.includes('401')) {
                    errorMessage = 'Token de acesso expirado. Reconecte sua conta.';
                }
                
                showMessage(errorMessage, 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Intercepta o sistema de exclusão de eventos de forma mais direta
         */
        window.overrideDeleteSystem = function overrideDeleteSystem() {
            console.log('🔧 Configurando override do sistema de exclusão...');
            
            // Override de possíveis funções de exclusão existentes
            const originalFunctions = {};
            
            // Lista de possíveis nomes de funções de exclusão
            const deleteFunction = ['deleteEvent', 'excluirEvento', 'removeEvent', 'deleteCalendarEvent'];
            
            deleteFunction.forEach(funcName => {
                if (window[funcName] && typeof window[funcName] === 'function') {
                    console.log(`🔧 Fazendo override da função: ${funcName}`);
                    originalFunctions[funcName] = window[funcName];
                    
                    window[funcName] = function(...args) {
                        console.log(`🗑️ Função ${funcName} interceptada com args:`, args);
                        
                        // Tentar extrair ID do evento dos argumentos
                        let eventId = null;
                        for (const arg of args) {
                            if (typeof arg === 'string' && arg.length > 10) {
                                eventId = arg;
                                break;
                            } else if (typeof arg === 'object' && arg.id) {
                                eventId = arg.id;
                                break;
                            }
                        }
                        
                        if (eventId) {
                            console.log(`🗑️ ID do evento extraído: ${eventId}`);
                            realDeleteCalendarEvent(eventId);
                        } else {
                            console.warn('⚠️ ID do evento não encontrado, executando função original');
                            return originalFunctions[funcName].apply(this, args);
                        }
                    };
                }
            }); // Fechamento do DOMContentLoaded
            
            // Interceptar cliques em elementos com onclick que contenham "delete" ou "excluir"
            document.addEventListener('click', function(e) {
                const element = e.target;
                const onclick = element.getAttribute('onclick') || '';
                
                if (onclick.includes('delete') || onclick.includes('excluir')) {
                    console.log('🗑️ Clique interceptado em elemento com onclick de exclusão:', onclick);
                    
                    // Tentar extrair ID do evento do onclick
                    const matches = onclick.match(/['"]([a-zA-Z0-9_-]{10,})['"]/) || onclick.match(/\(([a-zA-Z0-9_-]{10,})\)/);
                    if (matches && matches[1]) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const eventId = matches[1];
                        console.log(`🗑️ ID do evento extraído do onclick: ${eventId}`);
                        realDeleteCalendarEvent(eventId);
                        return false;
                    }
                }
            }, true); // Use capture para interceptar antes de outros handlers
        }

        /**
         * Intercepta botões de exclusão existentes no modal e faz eles usarem nossa função
         */
        function interceptExistingDeleteButtons() {
            // Evitar loop infinito - só executar se não estiver já executando
            if (window.interceptingButtons) return;
            window.interceptingButtons = true;
            
            console.log('🔍 Procurando botões de exclusão existentes...');
            
            // Buscar botões de exclusão existentes com seletores mais específicos
            const deleteButtons = document.querySelectorAll(
                'button[onclick*="deleteEvent"], ' +
                'button[onclick*="excluir"], ' +
                'button[onclick*="delete"], ' +
                '.delete-btn, ' +
                '.excluir-btn, ' +
                '.btn-delete, ' +
                '.btn-excluir, ' +
                '[data-action="delete"], ' +
                '[data-action="excluir"], ' +
                '[id*="delete"], ' +
                '[id*="excluir"], ' +
                '[class*="delete"], ' +
                '[class*="excluir"]'
            );
            
            // Também buscar por texto em todos os botões
            const allButtons = document.querySelectorAll('button, input[type="button"], .btn');
            const deleteButtonsByText = Array.from(allButtons).filter(btn => {
                const text = btn.textContent.toLowerCase().trim();
                const title = (btn.title || '').toLowerCase();
                const ariaLabel = (btn.getAttribute('aria-label') || '').toLowerCase();
                
                return text.includes('excluir evento') || 
                       text.includes('delete event') ||
                       text.includes('excluir') || 
                       text.includes('delete') || 
                       text.includes('🗑️') ||
                       title.includes('excluir') ||
                       title.includes('delete') ||
                       ariaLabel.includes('excluir') ||
                       ariaLabel.includes('delete');
            }); // Fechamento do DOMContentLoaded
            
            const allDeleteButtons = [...deleteButtons, ...deleteButtonsByText];
            
            console.log('🔍 Botões de exclusão encontrados:', allDeleteButtons.length);
            
            if (allDeleteButtons.length > 0) {
                console.log('📋 Detalhes dos botões encontrados:');
                allDeleteButtons.forEach((btn, i) => {
                    console.log(`  ${i+1}. Texto: "${btn.textContent.trim()}" | ID: "${btn.id}" | Class: "${btn.className}"`);
                });
            }
            
            allDeleteButtons.forEach((button, index) => {
                if (button.dataset.intercepted) return; // Já interceptado
                
                console.log(`🔧 Interceptando botão ${index + 1}:`, button.textContent);
                
                // Marcar como interceptado
                button.dataset.intercepted = 'true';
                
                // Remover event listeners existentes
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                
                // Adicionar novo event listener
                newButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('🗑️ Botão de exclusão interceptado clicado');
                    
                    // Tentar encontrar o ID do evento no modal
                    let eventId = null;
                    let accountEmail = null;
                    
                    // Buscar ID do evento em vários lugares
                    const modal = newButton.closest('.modal, .popup, .event-modal, .event-details');
                    if (modal) {
                        eventId = modal.getAttribute('data-event-id') ||
                                 modal.getAttribute('data-id') ||
                                 modal.id;
                        
                        accountEmail = modal.getAttribute('data-account') ||
                                     modal.getAttribute('data-email');
                    }
                    
                    // Buscar em elementos próximos
                    if (!eventId) {
                        const eventElement = newButton.closest('[data-event-id], [data-id]');
                        if (eventElement) {
                            eventId = eventElement.getAttribute('data-event-id') ||
                                     eventElement.getAttribute('data-id');
                            
                            accountEmail = eventElement.getAttribute('data-account') ||
                                         eventElement.getAttribute('data-email');
                        }
                    }
                    
                    // Buscar no DOM global
                    if (!eventId) {
                        const eventElements = document.querySelectorAll('[data-event-id], [data-id]');
                        for (const el of eventElements) {
                            if (el.style.display !== 'none' && el.offsetParent !== null) {
                                eventId = el.getAttribute('data-event-id') || el.getAttribute('data-id');
                                accountEmail = el.getAttribute('data-account') || el.getAttribute('data-email');
                                break;
                            }
                        }
                    }
                    
                    console.log('🔍 ID do evento encontrado:', eventId);
                    console.log('📧 Email da conta:', accountEmail);
                    
                    if (eventId) {
                        // Usar nossa função de exclusão
                        deleteCalendarEvent(eventId, accountEmail);
                    } else {
                        console.error('❌ ID do evento não encontrado');
                        showMessage('Não foi possível identificar o evento para exclusão', 'error');
                    }
                });
            }); // Fechamento do DOMContentLoaded
            
            // Reset da flag após processamento
            setTimeout(async () => {
                window.interceptingButtons = false;
            }, 1000);
        }

        /**
         * Adiciona botão de exclusão aos eventos no calendário
         */
        function addDeleteButtonsToEvents() {
            // Buscar todos os eventos no DOM
            const eventElements = document.querySelectorAll('.event-item, .calendar-event, [data-event-id]');
            
            eventElements.forEach(eventElement => {
                // Verificar se já tem botão de exclusão
                if (eventElement.querySelector('.delete-event-btn')) {
                    return;
                }
                
                // Obter ID do evento
                const eventId = eventElement.getAttribute('data-event-id') || 
                               eventElement.getAttribute('data-id') ||
                               eventElement.id;
                
                if (!eventId) return;
                
                // Obter email da conta (se disponível)
                const accountEmail = eventElement.getAttribute('data-account') ||
                                   eventElement.getAttribute('data-email');
                
                // Criar botão de exclusão
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-event-btn';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.title = 'Excluir evento';
                deleteBtn.style.cssText = `
                    background: #dc3545;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    padding: 4px 8px;
                    cursor: pointer;
                    font-size: 12px;
                    margin-left: 8px;
                    transition: all 0.3s ease;
                `;
                
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteCalendarEvent(eventId, accountEmail);
                });
                
                deleteBtn.addEventListener('mouseenter', function() {
                    this.style.background = '#c82333';
                });
                
                deleteBtn.addEventListener('mouseleave', function() {
                    this.style.background = '#dc3545';
                });
                
                // Adicionar botão ao evento
                eventElement.appendChild(deleteBtn);
            }); // Fechamento do DOMContentLoaded
        }

        // Função para mostrar mensagens
        window.showMessage = function showMessage(message, type = 'info') {
            let messagesContainer = document.getElementById('messagesContainer');
            if (!messagesContainer) {
                // Criar container se não existir
                messagesContainer = document.createElement('div');
                messagesContainer.id = 'messagesContainer';
                messagesContainer.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
                document.body.appendChild(messagesContainer);
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.style.cssText = `
                padding: 15px 20px;
                border-radius: 10px;
                margin-bottom: 10px;
                font-size: 14px;
                display: flex;
                align-items: center;
                gap: 10px;
                color: white;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                ${type === 'success' ? 'background: rgba(52, 168, 83, 0.9); border: 1px solid #34a853;' : ''}
                ${type === 'error' ? 'background: rgba(234, 67, 53, 0.9); border: 1px solid #ea4335;' : ''}
                ${type === 'info' ? 'background: rgba(66, 133, 244, 0.9); border: 1px solid #4285f4;' : ''}
            `;
            messageDiv.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                <span>${message}</span>
            `;
            
            messagesContainer.appendChild(messageDiv);
            
            // Remover mensagem após 5 segundos
            setTimeout(async () => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // CORREÇÃO: Definir as funções ANTES dos scripts carregarem
        window.gapiLoaded = function() {
            console.log('🔄 Carregando GAPI...');
            if (typeof gapi !== 'undefined') {
                gapi.load('client', initializeGapiClient);
            } else {
                console.error('❌ GAPI não está disponível');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        window.gisLoaded = function() {
            console.log('🔄 Carregando GIS...');
            try {
                if (typeof google !== 'undefined' && google.accounts) {
                    tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: CLIENT_ID,
                        scope: SCOPES,
                        callback: handleTokenResponse,
                        access_type: 'offline',
                        include_granted_scopes: true,
                        prompt: 'consent'
                    });
                    gisInited = true;
                    maybeEnableButtons();
                    console.log('✅ GIS carregado com sucesso');
                } else {
                    console.error('❌ Google Identity Services não está disponível');
                }
            } catch (error) {
                console.error('❌ Erro ao carregar GIS:', error);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // Garantir que as funções estejam disponíveis globalmente
        if (typeof window.gapiLoaded === 'undefined') {
            window.gapiLoaded = function() {
                console.log('🔄 Carregando GAPI (fallback)...');
                if (typeof gapi !== 'undefined') {
                    gapi.load('client', initializeGapiClient);
                }
            };
        }

        if (typeof window.gisLoaded === 'undefined') {
            window.gisLoaded = function() {
                console.log('🔄 Carregando GIS (fallback)...');
                try {
                    if (typeof google !== 'undefined' && google.accounts) {
                        tokenClient = google.accounts.oauth2.initTokenClient({
                            client_id: CLIENT_ID,
                            scope: SCOPES,
                            callback: handleTokenResponse,
                            access_type: 'offline',
                            include_granted_scopes: true,
                            prompt: 'consent',
                            enable_granular_consent: true,
                            enable_serial_consent: true
                        });
                        gisInited = true;
                        maybeEnableButtons();
                    }
                } catch (error) {
                    console.error('❌ Erro ao carregar GIS (fallback):', error);
                }
            };
        }

        async function initializeGapiClient() {
            try {
                console.log('🔄 Inicializando GAPI client...');
                console.log('📋 Discovery docs:', DISCOVERY_DOC);
                
                await gapi.client.init({
                    discoveryDocs: DISCOVERY_DOC,
                });
                
                console.log('✅ GAPI client inicializado');
                
                // Verificar se as APIs foram carregadas corretamente
                if (gapi.client.calendar) {
                    console.log('✅ Google Calendar API carregada');
                } else {
                    console.warn('⚠️ Google Calendar API não foi carregada');
                }
                
                if (gapi.client.drive) {
                    console.log('✅ Google Drive API carregada');
                } else {
                    console.warn('⚠️ Google Drive API não foi carregada');
                }
                
                gapiInited = true;
                maybeEnableButtons();
                console.log('✅ GAPI inicializado com sucesso!');
                
                // Tentar restaurar sessão
                await tryRestoreSession();
            } catch (error) {
                console.error('❌ Erro ao inicializar GAPI:', error);
                console.error('❌ Detalhes do erro:', error.message);
                showMessage('Erro ao carregar APIs do Google', 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                const authorizeButton = document.getElementById('authorizeButton');
                if (authorizeButton) {
                    authorizeButton.style.display = 'block';
                    console.log('✅ APIs do Google carregadas com sucesso');
                    showMessage('APIs do Google carregadas com sucesso!', 'success');
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // ✅ SISTEMA DE EXTRAÇÃO COM STATUS MELHORADO
        // =================================================================
        function extractPaymentInfo(text, eventTitle = '') {
            if (!text) return [];
            
            // Determinar tipo baseado no título do evento primeiro
            const titleLower = eventTitle.toLowerCase();
            let defaultType = 'pagamento';
            if (titleLower.includes('recebimento')) {
                defaultType = 'recebimento';
            }
            
            // Regex para detectar padrões como "Nome do pagamento - R$ 1.234,56 (STATUS) - detalhes"
            const paymentRegex = /([^-\n\r]+?)\s*-\s*R\$\s*([\d.]+,\d{2})\s*(\([^)]*\))?\s*(?:-\s*([^\n\r]*))?/gi;
            const matches = [];
            let match;
            
            while ((match = paymentRegex.exec(text)) !== null) {
                let paymentName = match[1].trim();
                let itemType = defaultType; // Usar tipo baseado no título do evento
                
                // Remover "PAGAMENTO" ou "RECEBIMENTO" do início se existir e ajustar tipo
                if (paymentName.toLowerCase().startsWith('pagamento ')) {
                    paymentName = paymentName.substring(10).trim(); // Remove "PAGAMENTO "
                    itemType = 'pagamento';
                } else if (paymentName.toLowerCase().startsWith('recebimento ')) {
                    paymentName = paymentName.substring(12).trim(); // Remove "RECEBIMENTO "
                    itemType = 'recebimento';
                }
                
                const valueStr = match[2];
                const statusText = match[3] ? match[3].replace(/[()]/g, '').trim() : '';
                const detailText = match[4] ? match[4].trim() : ''; // ✅ NOVO: Capturar detalhes
                const numericValue = parseFloat(valueStr.replace(/\./g, '').replace(',', '.'));
                
                // Determinar status baseado no texto entre parênteses e tipo
                let status = itemType === 'recebimento' ? 'AGUARDANDO' : 'PENDENTE'; // Status padrão
                
                if (statusText) {
                    const statusLower = statusText.toLowerCase();
                    
                    if (itemType === 'recebimento') {
                        // Status para recebimentos: RC, ADIADO, AGUARDANDO
                        if (statusLower.includes('rc')) {
                            status = 'RC';
                        } else if (statusLower.includes('adiado')) {
                            status = 'ADIADO';
                        } else if (statusLower.includes('aguardando')) {
                            status = 'AGUARDANDO';
                        }
                    } else {
                        // Status para pagamentos: PG, RECALCULADO, PENDENTE
                        if (statusLower.includes('pg')) {
                            status = 'PG';
                        } else if (statusLower.includes('recalculado')) {
                            status = 'RECALCULADO';
                        } else if (statusLower.includes('pendente')) {
                            status = 'PENDENTE';
                        }
                    }
                }
                
                matches.push({
                    name: paymentName,
                    original: `${paymentName} - R$ ${valueStr}${match[3] ? ' ' + match[3] : ''}${detailText ? ' - ' + detailText : ''}`,
                    value: numericValue,
                    formattedValue: `R$ ${valueStr}`,
                    status: status,
                    statusText: statusText,
                    detail: detailText, // ✅ NOVO: Incluir detalhes
                    type: itemType
                });
            }
            
            // Fallback: se não encontrar o padrão com "-", usar o método antigo
            if (matches.length === 0) {
                const moneyRegex = /R\$\s*([\d.]+,\d{2})/gi;
                const moneyMatches = text.match(moneyRegex) || [];
                
                moneyMatches.forEach(match => {
                    const valueStr = match.replace(/R\$\s*/, '');
                    const numericValue = parseFloat(valueStr.replace(/\./g, '').replace(',', '.'));
                    
                    matches.push({
                        name: 'Pagamento',
                        original: match,
                        value: numericValue,
                        formattedValue: match,
                        status: 'PENDENTE',
                        statusText: '',
                        type: 'pagamento'
                    });
                });
            }
            
            return matches;
        }

        function calculateEventTotal(event) {
            const description = event.description || '';
            const summary = event.summary || '';
            const fullText = `${summary} ${description}`;
            
            const payments = extractPaymentInfo(fullText, summary);
            
            // Separar pagamentos e recebimentos
            const paymentItems = payments.filter(p => p.type === 'pagamento');
            const receivingItems = payments.filter(p => p.type === 'recebimento');
            
            // Para pagamentos: contar PG e PENDENTE
            const countablePayments = paymentItems.filter(p => p.status === 'PG' || p.status === 'PENDENTE');
            const paymentTotal = countablePayments.reduce((sum, item) => sum + item.value, 0);
            
            // Para recebimentos: contar RC e AGUARDANDO (equivalentes a PG e PENDENTE)
            const countableReceivings = receivingItems.filter(p => p.status === 'RC' || p.status === 'AGUARDANDO');
            const receivingTotal = countableReceivings.reduce((sum, item) => sum + item.value, 0);
            
            // Total geral (pagamentos + recebimentos contáveis)
            const total = paymentTotal + receivingTotal;
            
            return {
                total: total,
                paymentTotal: paymentTotal,
                receivingTotal: receivingTotal,
                payments: payments,
                paymentItems: paymentItems,
                receivingItems: receivingItems,
                countablePayments: countablePayments,
                countableReceivings: countableReceivings,
                count: payments.length,
                countableCount: countablePayments.length + countableReceivings.length
            };
        }

        function formatCurrency(value) {
            return new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
            }).format(value);
        }

        function calculateDayTotal(date) {
            const eventsForDay = getEventsForDay(date);
            let dayTotal = 0;
            
            eventsForDay.forEach(event => {
                const eventCalc = calculateEventTotal(event);
                dayTotal += eventCalc.total; // Já considera apenas PG e PENDENTE
            });
            
            return dayTotal;
        }

        // ✅ NOVA: Função para calcular totais separados por tipo
        function calculateDayTotals(date) {
            const eventsForDay = getEventsForDay(date);
            let paymentTotal = 0;
            let receivingTotal = 0;
            
            // Verificar se a data é anterior à data atual
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const compareDate = new Date(date);
            compareDate.setHours(0, 0, 0, 0);
            const isPastDate = compareDate < today;
            
            let balanceReceivingTotal = 0;
            let balancePaymentTotal = 0;
            
            eventsForDay.forEach(event => {
                const eventCalc = calculateEventTotal(event);
                paymentTotal += eventCalc.paymentTotal; // PG + PENDENTE
                receivingTotal += eventCalc.receivingTotal; // RC + AGUARDANDO
                
                // Para o saldo, usar lógica diferente baseada na data
                if (isPastDate) {
                    // Data anterior: apenas RC e PG
                    eventCalc.receivingItems.forEach(item => {
                        if (item.status.toLowerCase() === 'rc') {
                            balanceReceivingTotal += item.value;
                        }
                    });
                    eventCalc.paymentItems.forEach(item => {
                        if (item.status.toLowerCase() === 'pg') {
                            balancePaymentTotal += item.value;
                        }
                    });
                } else {
                    // Outras datas: todos os itens independente do status
                    eventCalc.receivingItems.forEach(item => {
                        balanceReceivingTotal += item.value;
                    });
                    eventCalc.paymentItems.forEach(item => {
                        balancePaymentTotal += item.value;
                    });
                }
            });
            
            return {
                paymentTotal: paymentTotal,
                receivingTotal: receivingTotal,
                balance: balanceReceivingTotal - balancePaymentTotal
            };
        }

        // =================================================================
        // ✅ CÁLCULOS MENSAIS COM MONTANTES POR STATUS
        // =================================================================
        function calculateMonthlyTotals() {
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            
            let monthlyTotal = 0;
            let totalEvents = 0;
            let totalItems = 0;
            
            // ✅ NOVO: Contadores e montantes por status - PAGAMENTOS
            let totalPG = 0;
            let totalPendente = 0;
            let totalRecalculado = 0;
            let amountPG = 0;
            let amountPendente = 0;
            let amountRecalculado = 0;
            
            // ✅ NOVO: Contadores e montantes por status - RECEBIMENTOS
            let totalRC = 0;
            let totalAguardando = 0;
            let totalAdiado = 0;
            let amountRC = 0;
            let amountAguardando = 0;
            let amountAdiado = 0;
            
            // ✅ NOVO: Contadores e montantes para itens em atraso
            let totalPendenteAtraso = 0;
            let totalAguardandoAtraso = 0;
            let amountPendenteAtraso = 0;
            let amountAguardandoAtraso = 0;
            
            // Data atual para comparação
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const paymentsList = [];
            const receivingsList = [];
            
            filteredEvents.forEach(event => {
                const eventDate = parseEventDate(event);
                
                if (eventDate.getMonth() === currentMonth && eventDate.getFullYear() === currentYear) {
                    const eventCalc = calculateEventTotal(event);
                    monthlyTotal += eventCalc.total; // Já considera apenas contáveis
                    totalEvents++;
                    totalItems += eventCalc.count;
                    
                    // Processar pagamentos
                    eventCalc.paymentItems.forEach(payment => {
                        const eventDateCopy = new Date(eventDate);
                        eventDateCopy.setHours(0, 0, 0, 0);
                        const isOverdue = eventDateCopy < today;
                        
                        if (payment.status === 'PG') {
                            totalPG++;
                            amountPG += payment.value;
                        } else if (payment.status === 'PENDENTE') {
                            if (isOverdue) {
                                totalPendenteAtraso++;
                                amountPendenteAtraso += payment.value;
                            } else {
                                totalPendente++;
                                amountPendente += payment.value;
                            }
                        } else if (payment.status === 'RECALCULADO') {
                            totalRecalculado++;
                            amountRecalculado += payment.value;
                        }
                        
                        // Adicionar pagamentos à lista
                        paymentsList.push({
                            ...payment,
                            eventTitle: event.summary || 'Sem título',
                            eventDate: eventDate,
                            eventType: getEventType(event),
                            eventId: event.id
                        });
                    });
                    
                    // Processar recebimentos
                    eventCalc.receivingItems.forEach(receiving => {
                        const eventDateCopy = new Date(eventDate);
                        eventDateCopy.setHours(0, 0, 0, 0);
                        const isOverdue = eventDateCopy < today;
                        
                        if (receiving.status === 'RC') {
                            totalRC++;
                            amountRC += receiving.value;
                        } else if (receiving.status === 'AGUARDANDO') {
                            if (isOverdue) {
                                totalAguardandoAtraso++;
                                amountAguardandoAtraso += receiving.value;
                            } else {
                                totalAguardando++;
                                amountAguardando += receiving.value;
                            }
                        } else if (receiving.status === 'ADIADO') {
                            totalAdiado++;
                            amountAdiado += receiving.value;
                        }
                        
                        // Adicionar recebimentos à lista
                        receivingsList.push({
                            ...receiving,
                            eventTitle: event.summary || 'Sem título',
                            eventDate: eventDate,
                            eventType: getEventType(event),
                            eventId: event.id
                        });
                    });
                }
            }); // Fechamento do DOMContentLoaded
            
            // ✅ NOVO: Ordenar por data (mais recente primeiro)
            paymentsList.sort((a, b) => b.eventDate - a.eventDate);
            receivingsList.sort((a, b) => b.eventDate - a.eventDate);
            
            // ✅ NOVO: Calcular movimentação atual (apenas PG + RC até ontem)
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            let currentMovement = 0;
            filteredEvents.forEach(event => {
                const eventDate = parseEventDate(event);
                if (eventDate.getMonth() === currentMonth && eventDate.getFullYear() === currentYear && eventDate <= yesterday) {
                    const eventCalc = calculateEventTotal(event);
                    eventCalc.paymentItems.forEach(payment => {
                        if (payment.status === 'PG') {
                            currentMovement += payment.value;
                        }
                    });
                    eventCalc.receivingItems.forEach(receiving => {
                        if (receiving.status === 'RC') {
                            currentMovement += receiving.value;
                        }
                    });
                }
            });

            return {
                total: monthlyTotal,
                currentMovement: currentMovement, // ✅ NOVO: Movimentação atual
                paymentTotal: amountPG + amountPendente,
                receivingTotal: amountRC + amountAguardando,
                events: totalEvents,
                items: totalItems,
                // Pagamentos
                totalPG: totalPG,
                totalPendente: totalPendente,
                totalRecalculado: totalRecalculado,
                amountPG: amountPG,
                amountPendente: amountPendente,
                amountRecalculado: amountRecalculado,
                paymentsList: paymentsList,
                // Recebimentos
                totalRC: totalRC,
                totalAguardando: totalAguardando,
                totalAdiado: totalAdiado,
                amountRC: amountRC,
                amountAguardando: amountAguardando,
                amountAdiado: amountAdiado,
                receivingsList: receivingsList,
                // ✅ NOVO: Itens em atraso
                totalPendenteAtraso: totalPendenteAtraso,
                totalAguardandoAtraso: totalAguardandoAtraso,
                amountPendenteAtraso: amountPendenteAtraso,
                amountAguardandoAtraso: amountAguardandoAtraso
            };
        }

        function updateMonthlySummary() {
            const monthlyData = calculateMonthlyTotals();
            
            // Calcular dias do mês para médias diárias
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
            
            // ✅ ATUALIZADO: Usar movimentação atual (PG + RC até ontem)
            const monthlyTotalElement = document.getElementById('monthlyTotal');
            if (monthlyTotalElement) {
                monthlyTotalElement.textContent = formatCurrency(monthlyData.currentMovement);
            }
            
            // Atualizar totais por seção
            const paymentTotalElement = document.getElementById('paymentTotal');
            const receivingTotalElement = document.getElementById('receivingTotal');
            
            if (paymentTotalElement) {
                paymentTotalElement.textContent = formatCurrency(monthlyData.paymentTotal);
            }
            
            if (receivingTotalElement) {
                receivingTotalElement.textContent = formatCurrency(monthlyData.receivingTotal);
            }
            
            // Atualizar estatísticas gerais
            const totalEventsElement = document.getElementById('totalEvents');
            const totalItemsElement = document.getElementById('totalItems');
            const avgPaymentElement = document.getElementById('avgPayment');
            
            if (totalEventsElement) {
                totalEventsElement.textContent = monthlyData.events;
            }
            
            if (totalItemsElement) {
                totalItemsElement.textContent = monthlyData.items;
            }
            
            if (avgPaymentElement) {
                const avgValue = monthlyData.total > 0 ? monthlyData.total / daysInMonth : 0;
                avgPaymentElement.textContent = formatCurrency(avgValue);
            }

            // ✅ NOVO: Atualizar Análise de Saldo
            const balanceRCElement = document.getElementById('balanceRC');
            const balancePGElement = document.getElementById('balancePG');
            const balanceRCDailyElement = document.getElementById('balanceRCDaily');
            const balancePGDailyElement = document.getElementById('balancePGDaily');
            const balanceRCPGElement = document.getElementById('balanceRCPG');
            
            const balanceAguardandoElement = document.getElementById('balanceAguardando');
            const balancePendenteElement = document.getElementById('balancePendente');
            const balanceAguardandoDailyElement = document.getElementById('balanceAguardandoDaily');
            const balancePendenteDailyElement = document.getElementById('balancePendenteDaily');
            const balanceAguardandoPendenteElement = document.getElementById('balanceAguardandoPendente');
            
            // ✅ NOVO: Elementos para análise de atraso
            const balanceAguardandoAtrasoElement = document.getElementById('balanceAguardandoAtraso');
            const balancePendenteAtrasoElement = document.getElementById('balancePendenteAtraso');
            const balanceAguardandoAtrasoDailyElement = document.getElementById('balanceAguardandoAtrasoDaily');
            const balancePendenteAtrasoDailyElement = document.getElementById('balancePendenteAtrasoDaily');
            const balanceAtrasoElement = document.getElementById('balanceAtraso');
            
            if (balanceRCElement) balanceRCElement.textContent = formatCurrency(monthlyData.amountRC);
            if (balancePGElement) balancePGElement.textContent = formatCurrency(monthlyData.amountPG);
            if (balanceRCDailyElement) balanceRCDailyElement.textContent = `${formatCurrency(monthlyData.amountRC / daysInMonth)}/dia`;
            if (balancePGDailyElement) balancePGDailyElement.textContent = `${formatCurrency(monthlyData.amountPG / daysInMonth)}/dia`;
            if (balanceRCPGElement) {
                const saldoRCPG = monthlyData.amountRC - monthlyData.amountPG;
                balanceRCPGElement.textContent = formatCurrency(saldoRCPG);
                balanceRCPGElement.className = `balance-final ${saldoRCPG >= 0 ? 'positive' : 'negative'}`;
            }
            
            if (balanceAguardandoElement) balanceAguardandoElement.textContent = formatCurrency(monthlyData.amountAguardando);
            if (balancePendenteElement) balancePendenteElement.textContent = formatCurrency(monthlyData.amountPendente);
            if (balanceAguardandoDailyElement) balanceAguardandoDailyElement.textContent = `${formatCurrency(monthlyData.amountAguardando / daysInMonth)}/dia`;
            if (balancePendenteDailyElement) balancePendenteDailyElement.textContent = `${formatCurrency(monthlyData.amountPendente / daysInMonth)}/dia`;
            if (balanceAguardandoPendenteElement) {
                const saldoAguardandoPendente = monthlyData.amountAguardando - monthlyData.amountPendente;
                balanceAguardandoPendenteElement.textContent = formatCurrency(saldoAguardandoPendente);
                balanceAguardandoPendenteElement.className = `balance-final ${saldoAguardandoPendente >= 0 ? 'positive' : 'negative'}`;
            }
            
            // ✅ NOVO: Atualizar análise de atraso
            if (balanceAguardandoAtrasoElement) balanceAguardandoAtrasoElement.textContent = formatCurrency(monthlyData.amountAguardandoAtraso);
            if (balancePendenteAtrasoElement) balancePendenteAtrasoElement.textContent = formatCurrency(monthlyData.amountPendenteAtraso);
            if (balanceAguardandoAtrasoDailyElement) balanceAguardandoAtrasoDailyElement.textContent = `${formatCurrency(monthlyData.amountAguardandoAtraso / daysInMonth)}/dia`;
            if (balancePendenteAtrasoDailyElement) balancePendenteAtrasoDailyElement.textContent = `${formatCurrency(monthlyData.amountPendenteAtraso / daysInMonth)}/dia`;
            if (balanceAtrasoElement) {
                const saldoAtraso = monthlyData.amountAguardandoAtraso - monthlyData.amountPendenteAtraso;
                balanceAtrasoElement.textContent = formatCurrency(saldoAtraso);
                balanceAtrasoElement.className = `balance-final ${saldoAtraso >= 0 ? 'positive' : 'negative'}`;
            }

            // ✅ ATUALIZADO: Estatísticas de PAGAMENTOS com quantidade e média diária
            const totalPGElement = document.getElementById('totalPG');
            const totalPendenteElement = document.getElementById('totalPendente');
            const totalRecalculadoElement = document.getElementById('totalRecalculado');
            const amountPGElement = document.getElementById('amountPG');
            const amountPendenteElement = document.getElementById('amountPendente');
            const amountRecalculadoElement = document.getElementById('amountRecalculado');
            const avgPGDailyElement = document.getElementById('avgPGDaily');
            const avgPendenteDailyElement = document.getElementById('avgPendenteDaily');
            const avgRecalculadoDailyElement = document.getElementById('avgRecalculadoDaily');
            
            if (totalPGElement) {
                totalPGElement.textContent = `${monthlyData.totalPG} itens`;
            }
            
            if (totalPendenteElement) {
                totalPendenteElement.textContent = `${monthlyData.totalPendente} itens`;
            }
            
            if (totalRecalculadoElement) {
                totalRecalculadoElement.textContent = `${monthlyData.totalRecalculado} itens`;
            }
            
            if (amountPGElement) {
                amountPGElement.textContent = formatCurrency(monthlyData.amountPG);
            }
            
            if (amountPendenteElement) {
                amountPendenteElement.textContent = formatCurrency(monthlyData.amountPendente);
            }
            
            if (amountRecalculadoElement) {
                amountRecalculadoElement.textContent = formatCurrency(monthlyData.amountRecalculado);
            }
            
            if (avgPGDailyElement) {
                avgPGDailyElement.textContent = formatCurrency(monthlyData.amountPG / daysInMonth) + '/dia';
            }
            
            if (avgPendenteDailyElement) {
                avgPendenteDailyElement.textContent = formatCurrency(monthlyData.amountPendente / daysInMonth) + '/dia';
            }
            
            if (avgRecalculadoDailyElement) {
                avgRecalculadoDailyElement.textContent = formatCurrency(monthlyData.amountRecalculado / daysInMonth) + '/dia';
            }
            
            // ✅ ATUALIZADO: Estatísticas de RECEBIMENTOS com quantidade e média diária
            const totalRCElement = document.getElementById('totalRC');
            const totalAguardandoElement = document.getElementById('totalAguardando');
            const totalAdiadoElement = document.getElementById('totalAdiado');
            const amountRCElement = document.getElementById('amountRC');
            const amountAguardandoElement = document.getElementById('amountAguardando');
            const amountAdiadoElement = document.getElementById('amountAdiado');
            const avgRCDailyElement = document.getElementById('avgRCDaily');
            const avgAguardandoDailyElement = document.getElementById('avgAguardandoDaily');
            const avgAdiadoDailyElement = document.getElementById('avgAdiadoDaily');
            
            if (totalRCElement) {
                totalRCElement.textContent = `${monthlyData.totalRC} itens`;
            }
            
            if (totalAguardandoElement) {
                totalAguardandoElement.textContent = `${monthlyData.totalAguardando} itens`;
            }
            
            if (totalAdiadoElement) {
                totalAdiadoElement.textContent = `${monthlyData.totalAdiado} itens`;
            }
            
            if (amountRCElement) {
                amountRCElement.textContent = formatCurrency(monthlyData.amountRC);
            }
            
            if (amountAguardandoElement) {
                amountAguardandoElement.textContent = formatCurrency(monthlyData.amountAguardando);
            }
            
            if (amountAdiadoElement) {
                amountAdiadoElement.textContent = formatCurrency(monthlyData.amountAdiado);
            }
            
            if (avgRCDailyElement) {
                avgRCDailyElement.textContent = formatCurrency(monthlyData.amountRC / daysInMonth) + '/dia';
            }
            
            if (avgAguardandoDailyElement) {
                avgAguardandoDailyElement.textContent = formatCurrency(monthlyData.amountAguardando / daysInMonth) + '/dia';
            }
            
            if (avgAdiadoDailyElement) {
                avgAdiadoDailyElement.textContent = formatCurrency(monthlyData.amountAdiado / daysInMonth) + '/dia';
            }
            
            // ✅ NOVO: Atualizar estatísticas de itens em atraso
            const totalPendenteAtrasoElement = document.getElementById('totalPendenteAtraso');
            const totalAguardandoAtrasoElement = document.getElementById('totalAguardandoAtraso');
            const amountPendenteAtrasoElement = document.getElementById('amountPendenteAtraso');
            const amountAguardandoAtrasoElement = document.getElementById('amountAguardandoAtraso');
            const avgPendenteAtrasoDailyElement = document.getElementById('avgPendenteAtrasoDaily');
            const avgAguardandoAtrasoDailyElement = document.getElementById('avgAguardandoAtrasoDaily');
            
            if (totalPendenteAtrasoElement) {
                totalPendenteAtrasoElement.textContent = `${monthlyData.totalPendenteAtraso} itens`;
            }
            
            if (totalAguardandoAtrasoElement) {
                totalAguardandoAtrasoElement.textContent = `${monthlyData.totalAguardandoAtraso} itens`;
            }
            
            if (amountPendenteAtrasoElement) {
                amountPendenteAtrasoElement.textContent = formatCurrency(monthlyData.amountPendenteAtraso);
            }
            
            if (amountAguardandoAtrasoElement) {
                amountAguardandoAtrasoElement.textContent = formatCurrency(monthlyData.amountAguardandoAtraso);
            }
            
            if (avgPendenteAtrasoDailyElement) {
                avgPendenteAtrasoDailyElement.textContent = formatCurrency(monthlyData.amountPendenteAtraso / daysInMonth) + '/dia';
            }
            
            if (avgAguardandoAtrasoDailyElement) {
                avgAguardandoAtrasoDailyElement.textContent = formatCurrency(monthlyData.amountAguardandoAtraso / daysInMonth) + '/dia';
            }
            
            // Atualizar listas com filtros
            allPaymentsList = monthlyData.paymentsList;
            filteredPaymentsList = [...allPaymentsList];
            updatePaymentsList();
            
            // ✅ NOVO: Atualizar lista de recebimentos
            allReceivingsList = monthlyData.receivingsList;
            filteredReceivingsList = [...allReceivingsList];
            updateReceivingsList();
        }

        // =================================================================
        // ✅ NOVO: SISTEMA DE FILTROS DE PAGAMENTOS E RECEBIMENTOS
        // =================================================================
        function initializePaymentFilters() {
            const nameFilter = document.getElementById('nameFilter');
            const dateFilter = document.getElementById('dateFilter');
            const statusFilter = document.getElementById('statusFilter');
            const clearFiltersBtn = document.getElementById('clearFilters');
            
            if (nameFilter) {
                nameFilter.addEventListener('input', applyFilters);
            }
            
            if (dateFilter) {
                dateFilter.addEventListener('change', applyFilters);
            }
            
            if (statusFilter) {
                statusFilter.addEventListener('change', applyFilters);
            }
            
            if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', clearFilters);
            }
        }

        function initializeReceivingFilters() {
            const nameFilter = document.getElementById('receivingNameFilter');
            const dateFilter = document.getElementById('receivingDateFilter');
            const statusFilter = document.getElementById('receivingStatusFilter');
            const clearFiltersBtn = document.getElementById('clearReceivingFilters');
            
            if (nameFilter) {
                nameFilter.addEventListener('input', applyReceivingFilters);
            }
            
            if (dateFilter) {
                dateFilter.addEventListener('change', applyReceivingFilters);
            }
            
            if (statusFilter) {
                statusFilter.addEventListener('change', applyReceivingFilters);
            }
            
            if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', clearReceivingFilters);
            }
        }

        function initializeEventTypeListeners() {
            const typePagamento = document.getElementById('typePagamento');
            const typeRecebimento = document.getElementById('typeRecebimento');
            
            if (typePagamento) {
                typePagamento.addEventListener('change', updateEventTypeInterface);
            }
            
            if (typeRecebimento) {
                typeRecebimento.addEventListener('change', updateEventTypeInterface);
            }
        }

        function updateEventTypeInterface() {
            const selectedType = document.querySelector('input[name="eventType"]:checked');
            const itemsTitle = document.getElementById('itemsTitle');
            const statusSelect = document.getElementById('itemStatus');
            
            if (!selectedType) return;
            
            // ✅ NOVO: Renderizar campos baseado no tipo de evento
            const eventType = selectedType.value.toLowerCase();
            if (typeof window.renderEventTypeFields === 'function') {
                window.renderEventTypeFields(eventType);
            }
            
            // Atualizar título da seção
            if (itemsTitle) {
                itemsTitle.textContent = selectedType.value === 'PAGAMENTO' ? 'Itens de Pagamento' : 'Itens de Recebimento';
            }
            
            // Atualizar opções de status
            if (statusSelect) {
                statusSelect.innerHTML = '';
                statusSelect.appendChild(new Option('Selecionar...', ''));
                
                if (selectedType.value === 'PAGAMENTO') {
                    statusSelect.appendChild(new Option('PG', 'PG'));
                    statusSelect.appendChild(new Option('PENDENTE', 'PENDENTE'));
                    statusSelect.appendChild(new Option('RECALCULADO', 'RECALCULADO'));
                } else {
                    statusSelect.appendChild(new Option('RC', 'RC'));
                    statusSelect.appendChild(new Option('AGUARDANDO', 'AGUARDANDO'));
                    statusSelect.appendChild(new Option('ADIADO', 'ADIADO'));
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

           function applyFilters() {
            const nameFilter = document.getElementById('nameFilter')?.value.toLowerCase() || '';
            const dateFilter = document.getElementById('dateFilter')?.value || '';
            const statusFilter = document.getElementById('statusFilter')?.value || '';
            
            filteredPaymentsList = allPaymentsList.filter(payment => {
                // Filtro por nome
                const nameMatch = !nameFilter || 
                    payment.name.toLowerCase().includes(nameFilter) ||
                    payment.eventTitle.toLowerCase().includes(nameFilter);
                
                // Filtro por data
                const dateMatch = !dateFilter || 
                    payment.eventDate.toISOString().split('T')[0] === dateFilter;
                
                // Filtro por status
                const statusMatch = !statusFilter || payment.status === statusFilter;
                
                return nameMatch && dateMatch && statusMatch;
            }); // Fechamento do DOMContentLoaded
            
            updatePaymentsList();
        }

        function applyReceivingFilters() {
            const nameFilter = document.getElementById('receivingNameFilter')?.value.toLowerCase() || '';
            const dateFilter = document.getElementById('receivingDateFilter')?.value || '';
            const statusFilter = document.getElementById('receivingStatusFilter')?.value || '';
            
            filteredReceivingsList = allReceivingsList.filter(receiving => {
                // Filtro por nome
                const nameMatch = !nameFilter || 
                    receiving.name.toLowerCase().includes(nameFilter) ||
                    receiving.eventTitle.toLowerCase().includes(nameFilter);
                
                // Filtro por data
                const dateMatch = !dateFilter || 
                    receiving.eventDate.toISOString().split('T')[0] === dateFilter;
                
                // Filtro por status
                const statusMatch = !statusFilter || receiving.status === statusFilter;
                
                return nameMatch && dateMatch && statusMatch;
            }); // Fechamento do DOMContentLoaded
            
            updateReceivingsList();
        }

        function clearFilters() {
            const nameFilter = document.getElementById('nameFilter');
            const dateFilter = document.getElementById('dateFilter');
            const statusFilter = document.getElementById('statusFilter');
            
            if (nameFilter) nameFilter.value = '';
            if (dateFilter) dateFilter.value = '';
            if (statusFilter) statusFilter.value = '';
            
            filteredPaymentsList = [...allPaymentsList];
            updatePaymentsList();
        }

        function clearReceivingFilters() {
            const nameFilter = document.getElementById('receivingNameFilter');
            const dateFilter = document.getElementById('receivingDateFilter');
            const statusFilter = document.getElementById('receivingStatusFilter');
            
            if (nameFilter) nameFilter.value = '';
            if (dateFilter) dateFilter.value = '';
            if (statusFilter) statusFilter.value = '';
            
            filteredReceivingsList = [...allReceivingsList];
            updateReceivingsList();
        }

        function updatePaymentsList() {
            const paymentsListElement = document.getElementById('paymentsList');
            if (!paymentsListElement) return;
            
            if (filteredPaymentsList.length === 0) {
                paymentsListElement.innerHTML = `
                    <div class="no-payments">
                        <i class="fas fa-inbox"></i>
                        <p>Nenhum pagamento encontrado</p>
                        ${allPaymentsList.length > 0 ? '<p style="font-size: 0.9rem;">Tente ajustar os filtros</p>' : ''}
                    </div>
                `;
                return;
            }
            
            paymentsListElement.innerHTML = filteredPaymentsList.map(payment => {
                const itemInfo = extractAndFormatItemName(payment.name);
                return `
                <div class="payment-item" onclick="showPaymentEvent('${payment.eventId}')">
                    <div class="payment-header">
                        <div class="payment-name">${itemInfo.displayName}</div>
                        <div class="payment-value">${payment.formattedValue}</div>
                    </div>
                    <div class="payment-details">
                        <div class="payment-date">
                            <i class="fas fa-calendar"></i>
                            ${payment.eventDate.toLocaleDateString('pt-BR')}
                        </div>
                        <div class="payment-status ${payment.status.toLowerCase()}${(() => {
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const eventDate = new Date(payment.eventDate);
                            eventDate.setHours(0, 0, 0, 0);
                            const isOverdue = eventDate < today && (payment.status === 'PENDENTE' || payment.status === 'AGUARDANDO');
                            return isOverdue ? ' overdue' : '';
                        })()}">
                            <i class="fas fa-tag"></i>
                            ${payment.status}
                        </div>
                        <div style="color: rgba(255, 255, 255, 0.6);">
                            ${payment.eventTitle}
                        </div>
                    </div>
                </div>
            `;
            }).join('');
        }

        function updateReceivingsList() {
            const receivingsListElement = document.getElementById('receivingsList');
            if (!receivingsListElement) return;
            
            if (filteredReceivingsList.length === 0) {
                receivingsListElement.innerHTML = `
                    <div class="no-receivings">
                        <i class="fas fa-inbox"></i>
                        <p>Nenhum recebimento encontrado</p>
                        ${allReceivingsList.length > 0 ? '<p style="font-size: 0.9rem;">Tente ajustar os filtros</p>' : ''}
                    </div>
                `;
                return;
            }
            
            receivingsListElement.innerHTML = filteredReceivingsList.map(receiving => {
                const itemInfo = extractAndFormatItemName(receiving.name);
                return `
                <div class="receiving-item" onclick="showReceivingEvent('${receiving.eventId}')">
                    <div class="payment-header">
                        <div class="payment-name">${itemInfo.displayName}</div>
                        <div class="payment-value">${receiving.formattedValue}</div>
                    </div>
                    <div class="payment-details">
                        <div class="payment-date">
                            <i class="fas fa-calendar"></i>
                            ${receiving.eventDate.toLocaleDateString('pt-BR')}
                        </div>
                        <div class="payment-status ${receiving.status.toLowerCase()}${(() => {
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            const eventDate = new Date(receiving.eventDate);
                            eventDate.setHours(0, 0, 0, 0);
                            const isOverdue = eventDate < today && (receiving.status === 'PENDENTE' || receiving.status === 'AGUARDANDO');
                            return isOverdue ? ' overdue' : '';
                        })()}">
                            <i class="fas fa-tag"></i>
                            ${receiving.status}
                        </div>
                        <div style="color: rgba(255, 255, 255, 0.6);">
                            ${receiving.eventTitle}
                        </div>
                    </div>
                </div>
            `;
            }).join('');
        }

        function showPaymentEvent(eventId) {
            const event = filteredEvents.find(e => e.id === eventId);
            if (event) {
                showEventDetails(event);
            }
        }

        function showReceivingEvent(eventId) {
            const event = filteredEvents.find(e => e.id === eventId);
            if (event) {
                showEventDetails(event);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // LÓGICA DE CORES BASEADA EM STATUS E DATA
        // =================================================================
        function getEventColorClass(event) {
            const eventCalc = calculateEventTotal(event);
            const eventDate = parseEventDate(event);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            eventDate.setHours(0, 0, 0, 0);
            
            const eventType = getEventType(event);
            
            if (eventType === 'recebimento') {
                // ✅ NOVO: Lógica de cores para RECEBIMENTOS
                // Verificar se todos os recebimentos estão com RC ou ADIADO
                const allReceivingsCompleted = eventCalc.receivingItems.length > 0 && 
                    eventCalc.receivingItems.every(r => r.status === 'RC' || r.status === 'ADIADO');
                
                if (allReceivingsCompleted) {
                    return 'receiving-upcoming'; // ✅ AZUL para recebimentos RC/ADIADO
                } else if (eventDate < today) {
                    return 'receiving-overdue'; // Laranja para recebimentos em atraso
                } else {
                    return 'receiving-upcoming'; // Azul claro para recebimentos futuros
                }
            } else {
                // ✅ NOVO: Lógica de cores para PAGAMENTOS
                // Verificar se todos os pagamentos estão com PG ou RECALCULADO
                const allPaymentsCompleted = eventCalc.paymentItems.length > 0 && 
                    eventCalc.paymentItems.every(p => p.status === 'PG' || p.status === 'RECALCULADO');
                
                if (allPaymentsCompleted) {
                    return 'payment-completed'; // ✅ MARROM para pagamentos PG/RECALCULADO
                } else if (eventDate < today) {
                    return 'payment-overdue'; // Vermelho para pagamentos em atraso
                } else {
                    return 'payment-upcoming'; // Laranja para pagamentos futuros
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // CORREÇÃO DE FUSO HORÁRIO - FUNÇÃO PRINCIPAL
        // =================================================================
        function parseEventDate(event) {
            let eventDate;
            
            if (event.start.date) {
                // Evento de dia inteiro - usar apenas a data sem conversão de fuso
                eventDate = new Date(event.start.date + 'T00:00:00');
            } else if (event.start.dateTime) {
                // Evento com horário específico - converter para data local
                eventDate = new Date(event.start.dateTime);
            } else {
                // Fallback
                eventDate = new Date();
            }
            
            return eventDate;
        }

        function getDateString(date) {
            // Retorna string no formato YYYY-MM-DD para comparação
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function getCalendarDateString(date) {
            // Para datas do calendário, usar a data local sem conversão
            return getDateString(date);
        }

        // =================================================================
        // PERSISTÊNCIA DE LOGIN
        // =================================================================
        function saveConnectionState() {
            try {
                const connectionData = {
                    connected: isGoogleConnected,
                    timestamp: Date.now(),
                    clientId: CLIENT_ID
                };
                localStorage.setItem('google_calendar_connection', JSON.stringify(connectionData));
                sessionStorage.setItem('google_calendar_session', 'active');
                console.log('✅ Estado de conexão salvo');
            } catch (error) {
                console.error('❌ Erro ao salvar estado:', error);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function getConnectionState() {
            try {
                const connectionData = localStorage.getItem('google_calendar_connection');
                const sessionData = sessionStorage.getItem('google_calendar_session');
                
                if (!connectionData || !sessionData) return null;
                
                const data = JSON.parse(connectionData);
                
                // Verificar se não passou muito tempo (24 horas)
                const timeElapsed = Date.now() - data.timestamp;
                if (timeElapsed > 24 * 60 * 60 * 1000) {
                    clearConnectionState();
                    return null;
                }
                
                return data;
            } catch (error) {
                console.error('❌ Erro ao recuperar estado:', error);
                return null;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function clearConnectionState() {
            try {
                localStorage.removeItem('google_calendar_connection');
                sessionStorage.removeItem('google_calendar_session');
                console.log('✅ Estado de conexão removido');
            } catch (error) {
                console.error('❌ Erro ao remover estado:', error);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        async function tryRestoreSession() {
            const savedState = getConnectionState();
            if (savedState && savedState.connected && gapiInited && gisInited) {
                try {
                    // Tentar uma nova autenticação silenciosa
                    tokenClient.requestAccessToken({ prompt: '' });
                } catch (error) {
                    console.log('❌ Não foi possível restaurar sessão automaticamente');
                    clearConnectionState();
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // MODAL FUNCTIONS
        // =================================================================
        function closeEventModal() {
            document.getElementById('eventModal').style.display = 'none';
        }

        // =================================================================
        // MESSAGE SYSTEM
        // =================================================================
        function showMessage(message, type = 'info') {
            const container = document.getElementById('messagesContainer');
            if (!container) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const icon = getMessageIcon(type);
            messageDiv.innerHTML = `<i class="fas ${icon}"></i> ${message}`;
            
            // Remove mensagem anterior se existir
            const existingMessage = container.querySelector('.message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            container.appendChild(messageDiv);
            
            // Auto-remove após 5 segundos
            setTimeout(async () => {
                messageDiv.remove();
            }, 5000);
        }

        function getMessageIcon(type) {
            switch (type) {
                case 'success': return 'fa-check-circle';
                case 'error': return 'fa-exclamation-triangle';
                case 'warning': return 'fa-exclamation-circle';
                default: return 'fa-info-circle';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // GOOGLE AUTHENTICATION
        // =================================================================
        function handleAuthClick() {
            if (!gapiInited || !gisInited) {
                showMessage('APIs do Google ainda não foram carregadas. Aguarde...', 'error');
                return;
            }

            try {
                // ✅ CORREÇÃO: Sempre forçar seleção de conta para múltiplas contas
                tokenClient.requestAccessToken({ 
                    prompt: 'select_account', // Força seleção de conta
                    include_granted_scopes: true,
                    enable_granular_consent: true
                });
            } catch (error) {
                console.error('❌ Erro na autenticação:', error);
                showMessage('Erro ao tentar conectar com o Google Calendar', 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        async function handleTokenResponse(resp) {
            console.log('🔄 handleTokenResponse chamado com:', {
                access_token: resp.access_token ? 'presente' : 'ausente',
                token_type: resp.token_type,
                expires_in: resp.expires_in,
                state: resp.state || 'não informado'
            });
            
            // Verificar se este token é diferente do anterior
            const currentAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
            if (currentAccounts.length > 0) {
                const lastToken = currentAccounts[currentAccounts.length - 1].accessToken;
                if (lastToken && resp.access_token === lastToken) {
                    console.error('❌ DETECTADO: Token idêntico ao anterior! Isso indica reutilização indevida.');
                    showMessage('Erro: Sistema detectou reutilização de token. Tente desconectar todas as contas e conectar novamente.', 'error');
                    return;
                }
            }
            
            if (resp.error) {
                console.error('❌ Erro de autenticação:', resp.error);
                showMessage(`Erro de autenticação: ${resp.error}`, 'error');
                return;
            }

            try {
                // Verificar se GAPI está disponível e inicializado
                if (typeof gapi === 'undefined' || !gapi.client) {
                    console.error('❌ GAPI não está disponível ou não foi inicializado');
                    showMessage('Erro: Sistema de autenticação não carregado. Recarregue a página.', 'error');
                    return;
                }

                console.log('🔄 Processando novo token de acesso...');
                
                // IMPORTANTE: Criar um novo token client temporário para esta autenticação
                // Isso evita conflitos com tokens de outras contas
                const tempToken = {
                    access_token: resp.access_token,
                    token_type: resp.token_type || 'Bearer',
                    expires_in: resp.expires_in
                };
                
                // Definir token temporário
                gapi.client.setToken(tempToken);
                
                console.log('✅ Token temporário definido para obter informações do usuário');
                
                // Obter informações do usuário com o token atual
                let userInfo = null;
                
                try {
                    console.log('🔄 Obtendo informações do usuário...');
                    console.log('🔑 Token sendo usado:', resp.access_token.substring(0, 20) + '...');
                    
                    const userInfoResponse = await gapi.client.request({
                        path: 'https://www.googleapis.com/oauth2/v2/userinfo',
                        headers: {
                            'Authorization': `Bearer ${resp.access_token}`
                        }
                    });
                    
                    userInfo = userInfoResponse.result;
                    console.log('✅ Informações do usuário obtidas:');
                    console.log('   - Email:', userInfo.email);
                    console.log('   - Nome:', userInfo.name);
                    console.log('   - ID:', userInfo.id);
                    

                // Verificar estado do sistema antes de processar
                console.log('🔍 Estado atual do sistema:');
                console.log('   - window.connectedAccounts:', window.connectedAccounts);
                console.log('   - localStorage contas:', localStorage.getItem('connectedAccounts'));
                console.log('   - Função getConnectedAccounts disponível:', typeof window.getConnectedAccounts);
                
                if (typeof window.getConnectedAccounts === 'function') {
                    const currentAccounts = window.getConnectedAccounts();
                    console.log('   - Contas retornadas por getConnectedAccounts:', currentAccounts);
                }
                } catch (apiError) {
                    console.error('❌ Erro ao obter informações do usuário:', apiError);
                    showMessage('Erro ao obter informações da conta. Tente novamente.', 'error');
                    return;
                }
                
                // Verificar se o sistema de múltiplas contas está carregado
                if (typeof window.onAuthSuccess !== 'function') {
                    console.error('❌ Sistema de múltiplas contas não carregado');
                    showMessage('Erro: Sistema de contas não carregado. Recarregue a página.', 'error');
                    return;
                }
                
                // Verificar se a conta já existe
                const existingAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                
                console.log('🔍 DEBUG - Verificando contas existentes:');
                console.log('   - Contas existentes:', existingAccounts.map(acc => acc.email));
                console.log('   - Nova conta tentando conectar:', userInfo.email);
                
                const accountExists = existingAccounts.some(acc => acc.email === userInfo.email);
                console.log('   - Conta já existe?', accountExists);
                
                if (accountExists) {
                    console.log('🔄 Conta já existe, atualizando token para:', userInfo.email);
                    // Atualizar token da conta existente
                    const existingAccount = existingAccounts.find(acc => acc.email === userInfo.email);
                    if (existingAccount) {
                        existingAccount.accessToken = resp.access_token;
                        existingAccount.status = 'connected';
                        existingAccount.lastSync = Date.now();
                        
                        // Salvar no localStorage
                        if (typeof saveAccountsToStorage === 'function') {
                            saveAccountsToStorage();
                        }
                        
                        // Atualizar interface
                        if (typeof updateAccountsDisplay === 'function') {
                            updateAccountsDisplay();
                        }
                        
                        // FORÇAR ATUALIZAÇÃO COMPLETA DA INTERFACE
                        console.log('🔄 Forçando atualização da interface para conta reconectada...');
                        
                        // Ativar sistema legado se for a primeira/única conta
                        if (existingAccounts.length === 1) {
                            isGoogleConnected = true;
                            saveConnectionState();
                            
                            // Carregar eventos
                            await loadFilteredEvents();
                            
                            // Forçar atualização da interface
                            setTimeout(async () => {
                                forceInterfaceUpdate();
                            }, 1000);
                        }
                        
                        showMessage(`Conta ${userInfo.email} reconectada com sucesso!`, 'success');
                    }
                } else {
                    console.log('🆕 Nova conta detectada:', userInfo.email);
                    console.log('🔄 Chamando onAuthSuccess para nova conta...');
                    
                    // Verificar se onAuthSuccess existe
                    if (typeof window.onAuthSuccess === 'function') {
                        // Chamar função do gerenciador de múltiplas contas para nova conta
                        window.onAuthSuccess(userInfo, resp.access_token);
                    } else {
                        console.error('❌ Função onAuthSuccess não encontrada');
                        showMessage('Erro: Sistema de múltiplas contas não carregado', 'error');
                        return;
                    }
                }
                
                // Manter compatibilidade com sistema antigo se for a primeira conta
                const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                if (connectedAccounts.length === 1) {
                    isGoogleConnected = true;
                    saveConnectionState();
                    console.log('✅ Primeira conta conectada, ativando sistema legado');
                    
                    // Carregar eventos filtrados
                    await loadFilteredEvents();
                    
                    // FORÇAR ATUALIZAÇÃO DA INTERFACE
                    console.log('🔄 Forçando atualização da interface...');
                    
                    // Mostrar seções que devem aparecer após conexão
                    const calendarSection = document.getElementById('calendarSection');
                    const eventsSection = document.getElementById('monthlySummarySection');
                    const paymentsSection = document.getElementById('paymentsListSection');
                    
                    if (calendarSection) {
                        calendarSection.style.display = 'block';
                        console.log('✅ Seção do calendário mostrada');
                    }
                    
                    if (eventsSection) {
                        eventsSection.style.display = 'block';
                        console.log('✅ Seção de eventos mostrada');
                    }
                    
                    if (paymentsSection) {
                        paymentsSection.style.display = 'block';
                        console.log('✅ Seção de pagamentos mostrada');
                    }
                    
                    // Forçar renderização do calendário
                    if (typeof renderCalendar === 'function') {
                        console.log('🔄 Renderizando calendário...');
                        renderCalendar();
                    }
                    
                    // Forçar atualização de listas
                    if (typeof updateEventsList === 'function') {
                        console.log('🔄 Atualizando lista de eventos...');
                        updateEventsList();
                    }
                    
                    if (typeof updatePaymentsList === 'function') {
                        console.log('🔄 Atualizando lista de pagamentos...');
                        updatePaymentsList();
                    }
                    
                } else if (connectedAccounts.length > 1) {
                    console.log('✅ Múltiplas contas conectadas, recarregando eventos...');
                    // Recarregar eventos para incluir a nova conta
                    await loadFilteredEvents();
                    
                    // Atualizar interface também para múltiplas contas
                    if (typeof renderCalendar === 'function') {
                        renderCalendar();
                    }
                    if (typeof updateEventsList === 'function') {
                        updateEventsList();
                    }
                }
                
            } catch (error) {
                console.error('❌ Erro ao processar token:', error);
                showMessage('Erro ao processar autenticação', 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function handleSignoutClick() {
            try {
                const token = gapi.client.getToken();
                if (token !== null) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                    isGoogleConnected = false;
                    
                    // Limpar estado de conexão
                    clearConnectionState();
                    
                    console.log('✅ Desconectado do Google Calendar');
                    updateConnectionStatus(false);
                    document.getElementById('calendarSection').style.display = 'none';
                    document.getElementById('filterSection').style.display = 'none';
                    document.getElementById('monthlySummarySection').style.display = 'none';
                    document.getElementById('paymentsListSection').style.display = 'none';
                    showMessage('Desconectado do Google Calendar', 'success');
                }
            } catch (error) {
                console.error('❌ Erro ao desconectar:', error);
                showMessage('Erro ao desconectar', 'error');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // CONNECTION STATUS
        // =================================================================
        function updateConnectionStatus(connected) {
            // ✅ NOVO: Para múltiplas contas, não usar mais esta função
            // A interface será controlada pelo gerenciador de múltiplas contas
            const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
            
            if (connectedAccounts.length > 0) {
                // Mostrar seções quando há contas conectadas
                const calendarSection = document.getElementById('calendarSection');
                const filterSection = document.getElementById('filterSection');
                const monthlySummarySection = document.getElementById('monthlySummarySection');
                const listsSection = document.getElementById('listsSection');
                
                if (calendarSection) calendarSection.style.display = 'block';
                if (filterSection) filterSection.style.display = 'block';
                if (monthlySummarySection) monthlySummarySection.style.display = 'block';
                if (listsSection) listsSection.style.display = 'block';
            } else {
                // Esconder seções quando não há contas conectadas
                const calendarSection = document.getElementById('calendarSection');
                const filterSection = document.getElementById('filterSection');
                const monthlySummarySection = document.getElementById('monthlySummarySection');
                const listsSection = document.getElementById('listsSection');
                
                if (calendarSection) calendarSection.style.display = 'none';
                if (filterSection) filterSection.style.display = 'none';
                if (monthlySummarySection) monthlySummarySection.style.display = 'none';
                if (listsSection) listsSection.style.display = 'none';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // EVENT FILTERING
        // =================================================================
        function filterEvents(events) {
            const keywords = ['pagamento', 'pagamentos', 'recebimento', 'recebimentos', 'hvc'];
            
            return events.filter(event => {
                const title = (event.summary || '').toLowerCase();
                
                // Buscar palavras-chave APENAS no título do evento
                return keywords.some(keyword => title.includes(keyword));
            });
        }

        function getEventType(event) {
            const title = (event.summary || '').toLowerCase();
            
            if (title.includes('pagamento')) {
                return 'pagamento';
            } else if (title.includes('recebimento')) {
                return 'recebimento';
            } else if (title.includes('hvc')) {
                return 'hvc';
            }
            return 'default';
        }

        // =================================================================
        // GOOGLE CALENDAR OPERATIONS
        // =================================================================
        async function loadFilteredEvents() {
            try {
                const now = new Date();
                const startOfYear = new Date(now.getFullYear(), 0, 1);
                const endOfYear = new Date(now.getFullYear(), 11, 31);

                // ✅ NOVO: Verificar se há múltiplas contas conectadas
                const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                
                if (connectedAccounts.length > 1) {
                    console.log(`🔄 Carregando eventos de ${connectedAccounts.length} contas conectadas`);
                    
                    // Carregar eventos de todas as contas
                    const allEventsFromAllAccounts = [];
                    let totalEventsCount = 0;
                    
                    for (const account of connectedAccounts) {
                        try {
                            console.log(`📅 Carregando eventos da conta: ${account.email}`);
                            
                            // Definir token da conta atual
                            gapi.client.setToken({ access_token: account.accessToken });
                            
                            const response = await makeAuthenticatedRequest(
                            () => gapi.client.calendar.events.list({
                                calendarId: 'primary',
                                timeMin: startOfYear.toISOString(),
                                timeMax: endOfYear.toISOString(),
                                showDeleted: false,
                                singleEvents: true,
                                maxResults: 250,
                                orderBy: 'startTime'
                            }),
                            account.email
                        );

                            const accountEvents = response.result.items || [];
                            totalEventsCount += accountEvents.length;
                            
                            // Adicionar informação da conta a cada evento
                            accountEvents.forEach(event => {
                                event._accountEmail = account.email;
                                event._accountName = account.name || account.email;
                            });
                            
                            allEventsFromAllAccounts.push(...accountEvents);
                            console.log(`✅ ${accountEvents.length} eventos carregados da conta ${account.email}`);
                            
                        } catch (error) {
                            console.error(`❌ Erro ao carregar eventos da conta ${account.email}:`, error);
                            
                            // Marcar conta com erro
                            if (typeof window.multiAccountManager?.updateAccountStatus === 'function') {
                                window.multiAccountManager.updateAccountStatus(account.email, 'error');
                            }
                        }
                    }
                    
                    // Filtrar todos os eventos
                    filteredEvents = filterEvents(allEventsFromAllAccounts);
                    
                    console.log(`✅ Total de eventos carregados: ${totalEventsCount} de ${connectedAccounts.length} contas`);
                    console.log(`✅ Eventos filtrados: ${filteredEvents.length}`);
                    
                    updateFilterStats(totalEventsCount, filteredEvents.length);
                    updateMonthlySummary();
                    renderCalendar();
                    
                    showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados em ${connectedAccounts.length} contas`, 'success');
                    
                } else if (connectedAccounts.length === 1) {
                    // Uma conta conectada - usar sistema tradicional
                    console.log('📅 Carregando eventos da conta única conectada');
                    
                    const account = connectedAccounts[0];
                    gapi.client.setToken({ access_token: account.accessToken });
                    
                    const response = await makeAuthenticatedRequest(
                            () => gapi.client.calendar.events.list({
                                calendarId: 'primary',
                                timeMin: startOfYear.toISOString(),
                                timeMax: endOfYear.toISOString(),
                                showDeleted: false,
                                singleEvents: true,
                                maxResults: 250,
                                orderBy: 'startTime'
                            }),
                            account.email
                        );

                    const allEvents = response.result.items || [];
                    
                    // Adicionar informação da conta
                    allEvents.forEach(event => {
                        event._accountEmail = account.email;
                        event._accountName = account.name || account.email;
                    });
                    
                    filteredEvents = filterEvents(allEvents);
                    
                    console.log(`✅ Eventos carregados: ${allEvents.length} total, ${filteredEvents.length} filtrados`);
                    
                    updateFilterStats(allEvents.length, filteredEvents.length);
                    updateMonthlySummary();
                    renderCalendar();
                    
                    showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados`, 'success');
                    
                } else {
                    // Nenhuma conta conectada - usar sistema legado se isGoogleConnected for true
                    if (isGoogleConnected && gapi.client.getToken()) {
                        console.log('📅 Usando sistema legado - nenhuma conta no gerenciador');
                        
                        const response = await makeAuthenticatedRequest(
                            () => gapi.client.calendar.events.list({
                                calendarId: 'primary',
                                timeMin: startOfYear.toISOString(),
                                timeMax: endOfYear.toISOString(),
                                showDeleted: false,
                                singleEvents: true,
                                maxResults: 250,
                                orderBy: 'startTime'
                            }),
                            account.email
                        );

                        const allEvents = response.result.items || [];
                        filteredEvents = filterEvents(allEvents);
                        
                        console.log(`✅ Eventos carregados (legado): ${allEvents.length} total, ${filteredEvents.length} filtrados`);
                        
                        updateFilterStats(allEvents.length, filteredEvents.length);
                        updateMonthlySummary();
                        renderCalendar();
                        
                        showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados`, 'success');
                    } else {
                        console.log('⚠️ Nenhuma conta conectada');
                        showMessage('Nenhuma conta conectada ao Google Calendar', 'warning');
                    }
                }
                
            } catch (error) {
                console.error('❌ Erro ao carregar eventos:', error);
                showMessage('Erro ao carregar eventos', 'error');
                
                // Se erro de autenticação, limpar estado
                if (error.status === 401 || error.status === 403) {
                    clearConnectionState();
                    isGoogleConnected = false;
                    updateConnectionStatus(false);
                }
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        function updateFilterStats(total, filtered) {
            const statsElement = document.getElementById('filterStats');
            if (statsElement) {
                statsElement.innerHTML = `
                    Total de eventos: ${total} | 
                    Eventos filtrados: ${filtered} | 
                    Palavras-chave: "PAGAMENTO", "PAGAMENTOS", "HVC"
                `;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // CALENDAR RENDERING
        // =================================================================
        function renderCalendar() {
            // ✅ SINCRONIZAR variáveis globais no início
            currentYear = currentDate.getFullYear();
            currentMonth = currentDate.getMonth();
            
            const calendarGrid = document.getElementById('calendarGrid');
            const calendarTitle = document.getElementById('calendarTitle');
            
            if (!calendarGrid || !calendarTitle) return;
            
            // Update title
            const monthNames = [
                'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
            ];
            calendarTitle.textContent = `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
            
            // Clear grid
            calendarGrid.innerHTML = '';
            
            // Add day headers - COMEÇANDO NA SEGUNDA-FEIRA
            const dayHeaders = ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb', 'Dom'];
            dayHeaders.forEach(day => {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'calendar-day-header';
                headerDiv.textContent = day;
                calendarGrid.appendChild(headerDiv);
            }); // Fechamento do DOMContentLoaded
            
            // Get first day of month and number of days
            const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            const startDate = new Date(firstDay);
            
            // Ajustar para começar na segunda-feira (1 = segunda, 0 = domingo)
            const dayOfWeek = firstDay.getDay();
            const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            startDate.setDate(startDate.getDate() - daysToSubtract);
            
            // Generate calendar days
            const today = new Date();
            const todayString = getCalendarDateString(today);
            
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                
                if (cellDate.getMonth() !== currentDate.getMonth()) {
                    dayDiv.classList.add('other-month');
                }
                
                // CORREÇÃO: Comparação precisa para o dia de hoje usando strings de data
                if (getCalendarDateString(cellDate) === todayString) {
                    dayDiv.classList.add('today');
                }
                
                // ✅ NOVO: Calcular totais separados
                const dayTotals = calculateDayTotals(cellDate);
                
                // Day number com saldo ao lado
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                
                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = cellDate.getDate();
                dayHeader.appendChild(dayNumber);
                
                // Saldo ao lado do número do dia
                if (dayTotals.paymentTotal > 0 || dayTotals.receivingTotal > 0) {
                    const balanceDiv = document.createElement('div');
                    balanceDiv.className = `day-balance-inline ${dayTotals.balance >= 0 ? 'positive' : 'negative'}`;
                    balanceDiv.textContent = formatCurrency(Math.abs(dayTotals.balance));
                    if (dayTotals.balance < 0) {
                        balanceDiv.textContent = '-' + balanceDiv.textContent;
                    }
                    dayHeader.appendChild(balanceDiv);
                }
                
                dayDiv.appendChild(dayHeader);
                
                // Events for this day - AGRUPADOS POR TIPO
                const dayEvents = document.createElement('div');
                dayEvents.className = 'day-events';
                
                const eventsForDay = getEventsForDay(cellDate);
                if (eventsForDay.length > 0) {
                    // Criar eventos agrupados separados por tipo
                    const groupedEvents = createGroupedEvents(eventsForDay, cellDate);
                    
                    groupedEvents.forEach(groupedEvent => {
                        // Adicionar total de pagamentos antes do eventão de pagamentos
                        if (groupedEvent.type === 'pagamento' && dayTotals.paymentTotal > 0) {
                            const paymentTotalDiv = document.createElement('div');
                            paymentTotalDiv.className = `event-total ${groupedEvent.colorClass}`;
                            paymentTotalDiv.textContent = formatCurrency(dayTotals.paymentTotal);
                            dayEvents.appendChild(paymentTotalDiv);
                        }
                        
                        // Eventão
                        const eventDiv = document.createElement('div');
                        eventDiv.className = `event-item ${groupedEvent.colorClass}`;
                        eventDiv.textContent = groupedEvent.title;
                        eventDiv.onclick = () => showGroupedEventDetails(groupedEvent.events, cellDate, groupedEvent.type);
                        dayEvents.appendChild(eventDiv);
                        
                        // Adicionar total de recebimentos imediatamente após o eventão de recebimentos
                        if (groupedEvent.type === 'recebimento' && dayTotals.receivingTotal > 0) {
                            const receivingTotalDiv = document.createElement('div');
                            receivingTotalDiv.className = `event-total ${groupedEvent.colorClass}`;
                            receivingTotalDiv.textContent = formatCurrency(dayTotals.receivingTotal);
                            dayEvents.appendChild(receivingTotalDiv);
                        }
                    });
                }
                
                dayDiv.appendChild(dayEvents);
                
                calendarGrid.appendChild(dayDiv);
            }
            
            // Atualizar resumo mensal após renderizar calendário
            updateMonthlySummary();
        }

        // NOVA: Função para criar eventos agrupados (separados por tipo)
        function createGroupedEvents(events, date) {
            // Separar eventos por tipo
            const paymentEvents = events.filter(event => getEventType(event) === 'pagamento');
            const receivingEvents = events.filter(event => getEventType(event) === 'recebimento');
            const hvcEvents = events.filter(event => getEventType(event) === 'hvc');
            
            const groupedEvents = [];
            
            // Criar eventão de pagamentos
            if (paymentEvents.length > 0) {
                const totalPayments = paymentEvents.length;
                let title = totalPayments === 1 ? 
                    (paymentEvents[0].summary || 'Pagamento') : 
                    `${totalPayments} Pagamentos`;
                
                groupedEvents.push({
                    title: title,
                    colorClass: getDayColorClass(paymentEvents, 'pagamento', date),
                    events: paymentEvents,
                    type: 'pagamento'
                });
            }
            
            // Criar eventão de recebimentos
            if (receivingEvents.length > 0) {
                const totalReceivings = receivingEvents.length;
                let title = totalReceivings === 1 ? 
                    (receivingEvents[0].summary || 'Recebimento') : 
                    `${totalReceivings} Recebimentos`;
                
                groupedEvents.push({
                    title: title,
                    colorClass: getDayColorClass(receivingEvents, 'recebimento', date),
                    events: receivingEvents,
                    type: 'recebimento'
                });
            }
            
            // Adicionar eventos HVC se existirem
            if (hvcEvents.length > 0) {
                hvcEvents.forEach(event => {
                    groupedEvents.push({
                        title: event.summary || 'HVC',
                        colorClass: getEventColorClass(event),
                        events: [event],
                        type: 'hvc'
                    });
                });
            }
            
            return groupedEvents;
        }

        // NOVA: Função para determinar cor do dia baseada em todos os eventos
        function getDayColorClass(events, eventType = 'pagamento', eventDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const compareDate = new Date(eventDate);
            compareDate.setHours(0, 0, 0, 0);
            
            if (eventType === 'pagamento') {
                let allItemsCompleted = true;
                let hasNonCompliantItem = false;
                
                // Analisar todos os itens de pagamento de todos os eventos do dia
                events.forEach(event => {
                    const eventCalc = calculateEventTotal(event);
                    eventCalc.paymentItems.forEach(payment => {
                        const statusLower = payment.status.toLowerCase();
                        
                        // ✅ CORRIGIDO: Verificar se todos são PG OU RECALCULADO
                        if (statusLower !== 'pg' && statusLower !== 'recalculado') {
                            allItemsCompleted = false;
                        }
                        
                        // Verificar se há itens não conformes (não PG e não RECALCULADO)
                        if (statusLower !== 'pg' && statusLower !== 'recalculado') {
                            hasNonCompliantItem = true;
                        }
                    });
                });
                
                // ✅ CORRIGIDO: Todos os itens são PG OU RECALCULADO = MARROM
                if (allItemsCompleted) return 'payment-completed';
                
                // Regra 2: Data atual > data do evento + algum item não conforme = VERMELHO
                if (today > compareDate && hasNonCompliantItem) return 'payment-overdue';
                
                // Regra 3: Demais casos = LARANJA
                return 'payment-upcoming';
                
            } else if (eventType === 'recebimento') {
                let allItemsCompleted = true;
                let hasNonCompliantItem = false;
                
                // Analisar todos os itens de recebimento de todos os eventos do dia
                events.forEach(event => {
                    const eventCalc = calculateEventTotal(event);
                    eventCalc.receivingItems.forEach(receiving => {
                        const statusLower = receiving.status.toLowerCase();
                        
                        // ✅ CORRIGIDO: Verificar se todos são RC OU ADIADO
                        if (statusLower !== 'rc' && statusLower !== 'adiado') {
                            allItemsCompleted = false;
                        }
                        
                        // Verificar se há itens não conformes (não RC e não ADIADO)
                        if (statusLower !== 'rc' && statusLower !== 'adiado') {
                            hasNonCompliantItem = true;
                        }
                    });
                });
                
                // ✅ CORRIGIDO: Todos os itens são RC OU ADIADO = AZUL
                if (allItemsCompleted) return 'receiving-completed';
                
                // Regra 2: Data atual > data do evento + algum item não conforme = ROXO
                if (today > compareDate && hasNonCompliantItem) return 'receiving-overdue';
                
                // Regra 3: Demais casos = VERDE
                return 'receiving-default';
            }
            
            return 'event-default';
        }

        // NOVA: Função para mostrar detalhes do evento agrupado
        async function showGroupedEventDetails(events, date, eventType = 'pagamento') {
            const modal = document.getElementById('eventModal');
            const title = document.getElementById('eventModalTitle');
            const body = document.getElementById('eventModalBody');
            
            if (!modal || !title || !body) return;
            
            const dateStr = date.toLocaleDateString('pt-BR');
            const typeLabel = eventType === 'recebimento' ? 'Recebimentos' : 'Pagamentos';
            title.textContent = `${typeLabel} de ${dateStr} (${events.length} evento${events.length > 1 ? 's' : ''})`;
            
            let detailsHTML = '';
            let totalDay = 0;
            let allItems = [];
            
            // Processar todos os eventos do dia
            events.forEach((event, index) => {
                const eventCalc = calculateEventTotal(event);
                
                // Escolher itens baseado no tipo
                const items = eventType === 'recebimento' ? eventCalc.receivingItems : eventCalc.paymentItems;
                const itemTotal = eventType === 'recebimento' ? eventCalc.receivingTotal : eventCalc.paymentTotal;
                
                totalDay += itemTotal;
                allItems = allItems.concat(items);
                
                detailsHTML += `
                    <div class="grouped-event-section">
                        <h4><i class="fas fa-calendar-alt"></i> ${event.summary || 'Evento sem título'}</h4>
                        <div class="event-total-value">
                            ${formatCurrency(itemTotal)}
                        </div>
                `;
                
                if (items.length > 0) {
                    const itemLabel = eventType === 'recebimento' ? 'Recebimentos' : 'Pagamentos';
                    detailsHTML += `
                        <div class="event-values-list">
                            <div class="items-header">
                                <h5><i class="fas fa-list"></i> ${itemLabel} (${items.length}):</h5>
                            </div>
                            <div id="items-display-${index}" class="items-display">
                    `;
                    items.forEach((item, itemIndex) => {
                        detailsHTML += `
                            <div class="value-item" data-item-index="${itemIndex}">
                                <div>
                                    <strong>${item.name}</strong> - ${item.formattedValue}
                                    ${item.detail ? `<br><small>${item.detail}</small>` : ''}
                                </div>
                                <div class="value-item-status ${item.status.toLowerCase()}">
                                    ${item.status}
                                </div>
                            </div>
                        `;
                    });
                    detailsHTML += `
                            </div>
                            <div id="items-edit-${index}" class="items-edit" style="display: none;">
                                <!-- Formulário de edição será inserido aqui -->
                            </div>
                        </div>
                    `;
                }
                
                detailsHTML += `
                        <div class="event-actions">
                            <button class="btn-secondary" onclick="showEventDetails(${JSON.stringify(event).replace(/"/g, '&quot;')})">
                                <i class="fas fa-eye"></i> Ver Detalhes
                            </button>
                        </div>
                    </div>
                `;
            }); // Fechamento do DOMContentLoaded
            
            // Resumo do dia
            detailsHTML = `
                <div class="day-summary">
                    <h3><i class="fas fa-chart-line"></i> Resumo do Dia</h3>
                    <div class="day-total-value">
                        Total: ${formatCurrency(totalDay)}
                    </div>
                    <div class="day-stats">
                        <span>📅 ${events.length} evento${events.length > 1 ? 's' : ''}</span>
                        <span>💰 ${allItems.length} ${eventType === 'recebimento' ? 'recebimento' : 'pagamento'}${allItems.length > 1 ? 's' : ''}</span>
                    </div>
                </div>
                <hr>
            ` + detailsHTML;
            
            body.innerHTML = detailsHTML;
            modal.style.display = 'block';
        }

        // CORREÇÃO: Função principal para comparar datas dos eventos
        function getEventsForDay(date) {
            const targetDateString = getCalendarDateString(date);
            
            return filteredEvents.filter(event => {
                const eventDate = parseEventDate(event);
                const eventDateString = getCalendarDateString(eventDate);
                
                return eventDateString === targetDateString;
            }); // Fechamento do DOMContentLoaded
        }

        // Função para extrair TIPO, SUBTIPO e CATEGORIA do nome e formatar para exibição
        window.extractAndFormatItemName = function(fullName) {
            try {
                const nameParts = (fullName || '').split(' - ');
                
                if (nameParts.length >= 4) {
                    // Formato completo: TIPO - SUBTIPO - CATEGORIA - NOME
                    const tipo = nameParts[0].trim();
                    const subtipo = nameParts[1].trim();
                    const categoria = nameParts[2].trim();
                    const nome = nameParts.slice(3).join(' - ').trim();
                    
                    return {
                        tipo,
                        subtipo,
                        categoria,
                        nome,
                        displayName: nome,
                        hasTipoSubtipoCategoria: true,
                        formatted: `<div class="item-metadata"><span class="item-tipo">${tipo}</span> - <span class="item-subtipo">${subtipo}</span> - <span class="item-categoria">${categoria}</span></div><div class="item-name-main">${nome}</div>`
                    };
                } else if (nameParts.length === 3) {
                    // Formato: SUBTIPO - CATEGORIA - NOME (sem TIPO)
                    const subtipo = nameParts[0].trim();
                    const categoria = nameParts[1].trim();
                    const nome = nameParts[2].trim();
                    
                    return {
                        tipo: '',
                        subtipo,
                        categoria,
                        nome,
                        displayName: nome,
                        hasTipoSubtipoCategoria: true,
                        formatted: `<div class="item-metadata"><span class="item-tipo">Nenhum</span> - <span class="item-subtipo">${subtipo}</span> - <span class="item-categoria">${categoria}</span></div><div class="item-name-main">${nome}</div>`
                    };
                } else if (nameParts.length === 2) {
                    // Formato: SUBTIPO - NOME (sem TIPO e CATEGORIA)
                    const subtipo = nameParts[0].trim();
                    const nome = nameParts[1].trim();
                    
                    return {
                        tipo: '',
                        subtipo,
                        categoria: '',
                        nome,
                        displayName: nome,
                        hasTipoSubtipoCategoria: true,
                        formatted: `<div class="item-metadata"><span class="item-tipo">Nenhum</span> - <span class="item-subtipo">${subtipo}</span> - <span class="item-categoria">Nenhum</span></div><div class="item-name-main">${nome}</div>`
                    };
                } else {
                    // Formato: NOME (sem TIPO, SUBTIPO e CATEGORIA)
                    return {
                        tipo: '',
                        subtipo: '',
                        categoria: '',
                        nome: fullName.trim(),
                        displayName: fullName.trim(),
                        hasTipoSubtipoCategoria: false,
                        formatted: `<div class="item-name-main">${fullName.trim()}</div>`
                    };
                }
            } catch (error) {
                console.error('Erro ao extrair TIPO/SUBTIPO/CATEGORIA:', error);
                return {
                    tipo: 'Erro',
                    subtipo: 'Erro',
                    categoria: 'Erro',
                    nome: fullName || 'Erro',
                    displayName: fullName || 'Erro',
                    hasTipoSubtipoCategoria: true,
                    formatted: `<div class="item-metadata"><span class="item-tipo error">Erro</span> - <span class="item-subtipo error">Erro</span> - <span class="item-categoria error">Erro</span></div><div class="item-name-main">${fullName || 'Erro'}</div>`
                };
            }
        };

        async function showEventDetails(event) {
            const modal = document.getElementById('eventModal');
            const title = document.getElementById('eventModalTitle');
            const body = document.getElementById('eventModalBody');
            
            if (!modal || !title || !body) return;
            
            title.textContent = event.summary || 'Sem título';
            
            const eventDate = parseEventDate(event);
            const start = eventDate;
            const end = event.end.dateTime ? new Date(event.end.dateTime) : eventDate;
            
            // Calcular valores do evento
            const eventCalc = calculateEventTotal(event);
            
            let detailsHTML = `
                <p><strong><i class="fas fa-calendar"></i> Data:</strong> ${start.toLocaleDateString('pt-BR')}</p>
                <p><strong><i class="fas fa-clock"></i> Horário:</strong> ${event.start.dateTime ? 
                    `${start.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })} - ${end.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}` : 
                    'Dia inteiro'}</p>
                                <div id="descriptionSection">
                                    <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                                    ${event.description ? `
                                        <div id="descriptionDisplay" class="description-display">${event.description}</div>
                                    ` : `
                                        <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                                    `}
                                    <button onclick="startEditingDescription('${event.id}')" class="btn-edit">
                                        <i class="fas fa-edit"></i> ${event.description ? 'Editar Descrição' : 'Adicionar Descrição'}
                                    </button>
                                </div>

                ${event.location ? `<p><strong><i class="fas fa-map-marker-alt"></i> Local:</strong> ${event.location}</p>` : ''}
                <p><strong><i class="fas fa-tag"></i> Tipo:</strong> ${getEventType(event).toUpperCase()}</p>
            `;
            
            // Seção de valores encontrados
            if (eventCalc.count > 0) {
                detailsHTML += `
                    <div class="event-total-section">
                        <div class="event-total-title">
                            <i class="fas fa-calculator"></i> TOTAL CONTABILIZADO (PG + PENDENTE)
                        </div>
                        <div class="event-total-value">
                            ${formatCurrency(eventCalc.total)}
                        </div>
                    </div>
                `;
                
                if (eventCalc.payments.length > 0) {
                    const eventType = getEventType(event);
                    const isReceiving = eventType === 'recebimento';
                    const itemsLabel = isReceiving ? 'Recebimentos' : 'Pagamentos';
                    const editType = isReceiving ? 'recebimento' : 'pagamento';
                    
                    detailsHTML += `
                        <div class="event-values-list">
                            <div class="payments-header">
                                <h4><i class="fas fa-list"></i> ${itemsLabel} Encontrados (${eventCalc.count}):</h4>
                                <button class="btn-edit-payments" onclick="startEditingEventItems('${event.id}', '${editType}')">
                                    <i class="fas fa-edit"></i> EDITAR
                                </button>
                            </div>
                            <div id="payments-display" class="payments-display">
                    `;
                    eventCalc.payments.forEach((payment, index) => {
                        const itemInfo = extractAndFormatItemName(payment.name);
                        detailsHTML += `
                            <div class="value-item" data-item-index="${index}">
                                <div>
                                    <strong>${itemInfo.formatted}</strong>
                                    <div class="item-value-line">${payment.formattedValue}</div>
                                    ${payment.detail ? `<div class="item-detail"><small>${payment.detail}</small></div>` : ''}
                                </div>
                                <div class="value-item-status ${payment.status.toLowerCase()}">
                                    ${payment.status}
                                </div>
                            </div>
                        `;
                    });
                    detailsHTML += `
                            </div>
                            <div id="payments-edit" class="payments-edit" style="display: none;">
                                <!-- Formulário de edição será inserido aqui -->
                            </div>
                        </div>
                    `;
                }
            }
            
            // ✅ NOVO: Seção de anexos PDF
            detailsHTML += `
                <div class="event-attachments-section">
                    <h4><i class="fas fa-paperclip"></i> Anexos PDF</h4>
                    <div id="eventAttachmentsList" class="event-attachments-list">
                        <!-- Lista de anexos será carregada aqui -->
                    </div>
                    <div class="attachment-upload-section">
                        <input type="file" id="eventPdfInput" multiple accept=".pdf" style="display: none;">
                        <button onclick="document.getElementById('eventPdfInput').click()" class="btn-add-pdf">
                            <i class="fas fa-plus"></i> Adicionar PDF
                        </button>
                    </div>
                </div>
            `;
            
            // ✅ NOVO: Adicionar botão de excluir evento
            detailsHTML += `
                <div class="event-actions">
                    <button onclick="deleteEvent('${event.id}', '${event.summary}')" class="btn-delete">
                        <i class="fas fa-trash"></i> Excluir Evento
                    </button>
                </div>
            `;
            
            body.innerHTML = detailsHTML;
            
            // Configurar upload de PDFs para este evento
            setupEventPdfUpload(event);
            
            // Carregar anexos existentes
            loadEventAttachments(event);
            
            modal.style.display = 'block';
        }

        // =================================================================
        // EVENT PDF MANAGEMENT
        // =================================================================
        
        let currentEventForPdf = null;
        
        function setupEventPdfUpload(event) {
            currentEventForPdf = event;
            const pdfInput = document.getElementById('eventPdfInput');
            if (pdfInput) {
                pdfInput.addEventListener('change', handleEventPdfUpload);
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }
        
        async function handleEventPdfUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0 || !currentEventForPdf) return;
            
            // Mostrar indicador de carregamento
            const uploadSection = document.querySelector('.attachment-upload-section');
            const originalHTML = uploadSection.innerHTML;
            uploadSection.innerHTML = '<p style="color: #007bff;"><i class="fas fa-spinner fa-spin"></i> Fazendo upload...</p>';
            
            let successCount = 0;
            let errorCount = 0;
            const errors = [];
            
            for (const file of files) {
                if (file.type !== 'application/pdf') {
                    errors.push(`${file.name}: Apenas arquivos PDF são permitidos`);
                    errorCount++;
                    continue;
                }
                
                if (file.size > 10 * 1024 * 1024) {
                    errors.push(`${file.name}: Arquivo muito grande (máx. 10MB)`);
                    errorCount++;
                    continue;
                }
                
                try {
                    console.log(`📤 Processando: ${file.name}`);
                    await uploadPdfToEvent(file, currentEventForPdf);
                    successCount++;
                    console.log(`✅ Sucesso: ${file.name}`);
                } catch (error) {
                    console.error(`❌ Erro em ${file.name}:`, error);
                    errors.push(`${file.name}: ${error.message}`);
                    errorCount++;
                }
            }
            
            // Restaurar interface
            uploadSection.innerHTML = originalHTML;
            
            // Mostrar resultado
            let message = '';
            if (successCount > 0) {
                message += `✅ ${successCount} arquivo(s) anexado(s) com sucesso!`;
            }
            if (errorCount > 0) {
                if (message) message += '\n\n';
                message += `❌ ${errorCount} erro(s):\n${errors.join('\n')}`;
            }
            
            if (message) {
                alert(message);
            }
            
            // Limpar input
            event.target.value = '';
        }
        
        async function uploadPdfToEvent(file, event) {
            try {
                console.log('📤 Fazendo upload do PDF para o evento:', file.name);
                
                // Verificar autenticação
                if (!gapi.client.getToken()) {
                    throw new Error('Usuário não está autenticado');
                }
                
                // Converter arquivo para base64
                const base64 = await convertFileToBase64(file);
                
                // Upload para Google Drive
                const driveFile = await uploadPdfToDrive({
                    name: file.name,
                    base64: base64
                }, event.summary);
                
                // Atualizar evento com novo anexo
                await addAttachmentToEvent(event.id, driveFile);
                
                // Recarregar anexos
                await loadEventAttachments(event);
                
                alert(`${file.name} anexado com sucesso!`);
                
            } catch (error) {
                console.error('Erro no upload:', error);
                throw error;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }
        
        function convertFileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            }); // Fechamento do DOMContentLoaded
        }
        
        async function uploadPdfToDrive(pdfData, eventTitle) {
            try {
                console.log('📤 Iniciando upload para Google Drive:', pdfData.name);
                
                // Verificar se o usuário está autenticado
                const token = gapi.client.getToken();
                if (!token || !token.access_token) {
                    console.error('❌ Token não encontrado, solicitando nova autenticação...');
                    
                    // Solicitar nova autenticação com escopos corretos
                    await new Promise((resolve, reject) => {
                        tokenClient.callback = async (resp) => {
                            if (resp.error !== undefined) {
                                reject(resp);
                            } else {
                                console.log('✅ Nova autenticação realizada');
                                resolve(resp);
                            }
                        };
                        tokenClient.requestAccessToken({prompt: 'consent'});
                    });
                }
                
                // Verificar novamente após autenticação
                const newToken = gapi.client.getToken();
                if (!newToken || !newToken.access_token) {
                    throw new Error('Falha na autenticação. Tente novamente.');
                }
                
                console.log('🔑 Token válido encontrado, prosseguindo com upload...');
                
                // Converter base64 para blob
                const byteCharacters = atob(pdfData.base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/pdf' });
                
                console.log('📄 Arquivo preparado:', blob.size, 'bytes');
                
                // Metadados do arquivo
                const metadata = {
                    name: `${eventTitle} - ${pdfData.name}`,
                    parents: [] // Salvar na raiz do Drive
                };
                
                // Criar FormData para upload
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', blob);
                
                console.log('📤 Enviando para Google Drive...');
                
                // Fazer upload usando fetch
                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${newToken.access_token}`
                    },
                    body: form
                });
                
                console.log('📡 Resposta do Drive:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Erro detalhado:', errorText);
                    
                    if (response.status === 403) {
                        throw new Error('Permissão negada. Você precisa reautenticar com permissões do Google Drive. Clique em "Sincronizar" novamente.');
                    } else if (response.status === 401) {
                        throw new Error('Token expirado. Faça login novamente.');
                    } else {
                        throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
                    }
                }
                
                const fileData = await response.json();
                console.log('✅ Arquivo enviado com sucesso:', fileData.id);
                
                // Tentar tornar arquivo público (opcional)
                try {
                    console.log('🔓 Tornando arquivo público...');
                    await gapi.client.drive.permissions.create({
                        fileId: fileData.id,
                        resource: {
                            role: 'reader',
                            type: 'anyone'
                        }
                    });
                    console.log('✅ Arquivo tornado público');
                } catch (permError) {
                    console.warn('⚠️ Não foi possível tornar o arquivo público (não é crítico):', permError);
                }
                
                return {
                    fileId: fileData.id,
                    fileUrl: `https://drive.google.com/file/d/${fileData.id}/view`,
                    title: `${eventTitle} - ${pdfData.name}`,
                    mimeType: 'application/pdf'
                };
                
            } catch (error) {
                console.error('❌ Erro completo no upload:', error);
                throw error;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }
        
        async function addAttachmentToEvent(eventId, attachment) {
            try {
                // Buscar evento atual
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                
                // Adicionar novo anexo
                if (!event.attachments) {
                    event.attachments = [];
                }
                event.attachments.push(attachment);
                
                // Atualizar evento
                await gapi.client.calendar.events.update({
                    calendarId: 'primary',
                    eventId: eventId,
                    resource: event,
                    supportsAttachments: true
                });
                
                console.log('✅ Anexo adicionado ao evento');
                
            } catch (error) {
                console.error('Erro ao adicionar anexo ao evento:', error);
                throw error;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }
        
        async function loadEventAttachments(event) {
            const attachmentsList = document.getElementById('eventAttachmentsList');
            if (!attachmentsList) return;
            
            try {
                // ✅ NOVO: Garantir que estamos usando o token correto da conta do evento
                if (event._accountEmail) {
                    const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                    const eventAccount = connectedAccounts.find(acc => acc.email === event._accountEmail);
                    
                    if (eventAccount && eventAccount.accessToken) {
                        console.log(`🔄 Carregando anexos usando token da conta: ${event._accountEmail}`);
                        gapi.client.setToken({ access_token: eventAccount.accessToken });
                    }
                }
                
                // Buscar evento completo com anexos
                const fullEventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: event.id
                });
                
                const fullEvent = fullEventResponse.result;
                
                if (fullEvent.attachments && fullEvent.attachments.length > 0) {
                    const attachmentsHTML = fullEvent.attachments.map(attachment => `
                        <div class="attachment-item">
                            <div class="attachment-info">
                                <i class="fas fa-file-pdf"></i>
                                <span class="attachment-name">${attachment.title || 'Anexo'}</span>
                            </div>
                            <div class="attachment-actions">
                                <button onclick="viewAttachmentWithCorrectToken('${attachment.fileUrl}', '${event._accountEmail || ''}')" class="btn-view-attachment" title="Visualizar">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button onclick="removeAttachmentFromEvent('${event.id}', '${attachment.fileId}', '${event._accountEmail || ''}')" class="btn-remove-attachment" title="Remover">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `).join('');
                    
                    attachmentsList.innerHTML = attachmentsHTML;
                } else {
                    attachmentsList.innerHTML = '<p class="no-attachments">Nenhum anexo encontrado</p>';
                }
                
            } catch (error) {
                console.error('Erro ao carregar anexos:', error);
                attachmentsList.innerHTML = '<p class="no-attachments">Erro ao carregar anexos</p>';
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }
        
        // ✅ CORRIGIDO: Função para visualizar anexo com o token correto
        async function viewAttachmentWithCorrectToken(fileUrl, accountEmail) {
            try {
                console.log('🔄 Tentando visualizar anexo:', fileUrl);
                console.log('📧 Conta do evento:', accountEmail);
                
                // Extrair o file ID da URL do Google Drive
                let fileId = null;
                
                // Diferentes formatos de URL do Google Drive
                const driveUrlPatterns = [
                    /\/file\/d\/([a-zA-Z0-9-_]+)/,  // drive.google.com/file/d/ID
                    /id=([a-zA-Z0-9-_]+)/,         // drive.google.com/open?id=ID
                    /\/d\/([a-zA-Z0-9-_]+)/        // Outros formatos
                ];
                
                for (const pattern of driveUrlPatterns) {
                    const match = fileUrl.match(pattern);
                    if (match) {
                        fileId = match[1];
                        break;
                    }
                }
                
                if (!fileId) {
                    console.log('⚠️ Não foi possível extrair file ID, tentando abrir URL diretamente');
                    window.open(fileUrl, '_blank');
                    return;
                }
                
                console.log('📄 File ID extraído:', fileId);
                
                // Tentar usar o token da conta específica
                if (accountEmail) {
                    const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                    const eventAccount = connectedAccounts.find(acc => acc.email === accountEmail);
                    
                    if (eventAccount && eventAccount.accessToken) {
                        console.log(`🔑 Usando token da conta: ${accountEmail}`);
                        
                        // Definir o token no gapi para esta operação
                        const currentToken = gapi.client.getToken();
                        gapi.client.setToken({ access_token: eventAccount.accessToken });
                        
                        try {
                            // Tentar obter informações do arquivo via API
                            const fileResponse = await gapi.client.request({
                                path: `https://www.googleapis.com/drive/v3/files/${fileId}`,
                                method: 'GET',
                                params: {
                                    fields: 'webViewLink,webContentLink,name'
                                }
                            });
                            
                            console.log('📁 Informações do arquivo:', fileResponse.result);
                            
                            // Usar webViewLink para visualização
                            if (fileResponse.result.webViewLink) {
                                window.open(fileResponse.result.webViewLink, '_blank');
                                return;
                            }
                            
                        } catch (apiError) {
                            console.log('⚠️ Erro na API do Drive, tentando URL direta:', apiError);
                        } finally {
                            // Restaurar token original
                            if (currentToken) {
                                gapi.client.setToken(currentToken);
                            }
                        }
                    }
                }
                
                // Fallback 1: Tentar URL de visualização direta
                const viewUrl = `https://drive.google.com/file/d/${fileId}/view`;
                console.log('🔄 Tentando URL de visualização:', viewUrl);
                window.open(viewUrl, '_blank');
                
            } catch (error) {
                console.error('❌ Erro ao visualizar anexo:', error);
                
                // Fallback final: URL original
                console.log('🔄 Fallback: abrindo URL original');
                window.open(fileUrl, '_blank');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        async function removeAttachmentFromEvent(eventId, fileId, accountEmail) {
            if (!confirm('Tem certeza que deseja remover este anexo?')) return;
            
            try {
                // ✅ NOVO: Garantir que estamos usando o token correto da conta do evento
                if (accountEmail) {
                    const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                    const eventAccount = connectedAccounts.find(acc => acc.email === accountEmail);
                    
                    if (eventAccount && eventAccount.accessToken) {
                        console.log(`🔄 Removendo anexo usando token da conta: ${accountEmail}`);
                        gapi.client.setToken({ access_token: eventAccount.accessToken });
                    }
                }
                
                // Buscar evento atual
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                
                // Remover anexo da lista
                if (event.attachments) {
                    event.attachments = event.attachments.filter(att => att.fileId !== fileId);
                }
                
                // Atualizar evento
                await gapi.client.calendar.events.update({
                    calendarId: 'primary',
                    eventId: eventId,
                    resource: event,
                    supportsAttachments: true
                });
                
                // Recarregar anexos
                await loadEventAttachments(currentEventForPdf);
                
                alert('Anexo removido com sucesso!');
                
            } catch (error) {
                console.error('Erro ao remover anexo:', error);
                alert('Erro ao remover anexo');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // EVENT DELETION
        // =================================================================
        // EVENT DELETION WITH RECURRENCE SUPPORT
        // =================================================================
        async function deleteEvent(eventId, eventTitle) {
            if (!isGoogleConnected) {
                alert('Conecte-se ao Google Calendar primeiro');
                return;
            }
            
            try {
                // Buscar detalhes completos do evento para verificar recorrência
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                const isRecurring = event.recurringEventId || event.recurrence;
                
                if (isRecurring) {
                    // Evento recorrente - mostrar opções
                    const choice = await showRecurrenceDeleteDialog(eventTitle);
                    if (!choice) return; // Usuário cancelou
                    
                    await handleRecurringEventDeletion(event, choice);
                } else {
                    // Evento único - confirmação simples
                    const confirmMessage = `Tem certeza que deseja excluir o evento "${eventTitle}"?\n\nEsta ação não pode ser desfeita.`;
                    if (!confirm(confirmMessage)) {
                        return;
                    }
                    
                    await gapi.client.calendar.events.delete({
                        calendarId: 'primary',
                        eventId: eventId
                    });
                    
                    console.log('✅ Evento excluído:', eventTitle);
                    alert('Evento excluído com sucesso!');
                }
                
                // Fechar modal e recarregar
                const eventModal = document.getElementById('eventModal');
                if (eventModal) {
                    eventModal.style.display = 'none';
                }
                await handleSyncClick();
                
            } catch (error) {
                console.error('❌ Erro ao excluir evento:', error);
                alert('Erro ao excluir evento. Verifique sua conexão e tente novamente.');
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // Função para mostrar dialog de opções de recorrência para exclusão
        function showRecurrenceDeleteDialog(eventTitle) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'recurrence-modal';
                modal.innerHTML = `
                    <div class="recurrence-modal-content">
                        <h3><i class="fas fa-exclamation-triangle"></i> Excluir Evento Recorrente</h3>
                        <p>O evento "<strong>${eventTitle}</strong>" faz parte de uma série recorrente.</p>
                        <p>Como você gostaria de excluir?</p>
                        
                        <div class="recurrence-options">
                            <button class="recurrence-btn" data-choice="this">
                                <i class="fas fa-calendar-day"></i>
                                <div class="recurrence-btn-content">
                                    <span>Apenas este evento</span>
                                    <small>Exclui somente esta ocorrência</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="following">
                                <i class="fas fa-calendar-week"></i>
                                <div class="recurrence-btn-content">
                                    <span>Este e eventos seguintes</span>
                                    <small>Exclui esta ocorrência e todas as futuras</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="all">
                                <i class="fas fa-calendar"></i>
                                <div class="recurrence-btn-content">
                                    <span>Todos os eventos da série</span>
                                    <small>Exclui toda a série recorrente</small>
                                </div>
                            </button>
                        </div>
                        
                        <div class="recurrence-actions">
                            <button class="recurrence-cancel">Cancelar</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Event listeners
                modal.querySelectorAll('.recurrence-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
                
                modal.querySelector('.recurrence-cancel').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
                
                // Fechar ao clicar fora
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                        resolve(null);
                    }
                });
            }); // Fechamento do DOMContentLoaded
            
            // Reset da flag após processamento
            setTimeout(async () => {
                window.interceptingButtons = false;
            }, 1000);
        }

        // Função para mostrar dialog de opções de recorrência para edição
        function showRecurrenceEditDialog(eventTitle) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'recurrence-modal';
                modal.innerHTML = `
                    <div class="recurrence-modal-content">
                        <h3><i class="fas fa-edit"></i> Editar Evento Recorrente</h3>
                        <p>O evento "<strong>${eventTitle}</strong>" faz parte de uma série recorrente.</p>
                        <p>Como você gostaria de editar?</p>
                        
                        <div class="recurrence-options">
                            <button class="recurrence-btn" data-choice="this">
                                <i class="fas fa-calendar-day"></i>
                                <div class="recurrence-btn-content">
                                    <span>Apenas este evento</span>
                                    <small>Edita somente esta ocorrência</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="following">
                                <i class="fas fa-calendar-week"></i>
                                <div class="recurrence-btn-content">
                                    <span>Este e eventos seguintes</span>
                                    <small>Edita esta ocorrência e todas as futuras</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="all">
                                <i class="fas fa-calendar"></i>
                                <div class="recurrence-btn-content">
                                    <span>Todos os eventos da série</span>
                                    <small>Edita toda a série recorrente</small>
                                </div>
                            </button>
                        </div>
                        
                        <div class="recurrence-actions">
                            <button class="recurrence-cancel">Cancelar</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Event listeners
                modal.querySelectorAll('.recurrence-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
                
                modal.querySelector('.recurrence-cancel').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
                
                // Fechar ao clicar fora
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                        resolve(null);
                    }
                });
            }); // Fechamento do DOMContentLoaded
            
            // Reset da flag após processamento
            setTimeout(async () => {
                window.interceptingButtons = false;
            }, 1000);
        }

        // Função para lidar com exclusão de eventos recorrentes
        async function handleRecurringEventDeletion(event, choice) {
            switch (choice) {
                case 'this':
                    // Excluir apenas esta instância
                    if (event.recurringEventId) {
                        // É uma instância de evento recorrente
                        await gapi.client.calendar.events.delete({
                            calendarId: 'primary',
                            eventId: event.id
                        });
                    } else {
                        // É o evento principal - criar exceção
                        // Isso é mais complexo, por simplicidade vamos excluir a instância
                        await gapi.client.calendar.events.delete({
                            calendarId: 'primary',
                            eventId: event.id
                        });
                    }
                    break;
                    
                case 'following':
                    // Excluir este e eventos seguintes
                    if (event.recurringEventId) {
                        // Buscar evento principal e modificar até esta data
                        const masterEvent = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: event.recurringEventId
                        });
                        
                        // Modificar recorrência para terminar antes desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000); // Um dia antes
                        
                        const updatedRecurrence = masterEvent.result.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.recurringEventId,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                    } else {
                        // É o evento principal - modificar recorrência
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000);
                        
                        const updatedRecurrence = event.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                    }
                    break;
                    
                case 'all':
                    // Excluir toda a série
                    const masterEventId = event.recurringEventId || event.id;
                    await gapi.client.calendar.events.delete({
                        calendarId: 'primary',
                        eventId: masterEventId
                    });
                    break;
            }
            
            console.log('✅ Evento(s) excluído(s) com sucesso');
            alert('Evento(s) excluído(s) com sucesso!');
        }

        // Função para lidar com edição de eventos recorrentes
        async function handleRecurringEventEdit(event, choice, newDescription) {
            switch (choice) {
                case 'this':
                    // Editar apenas esta instância
                    if (event.recurringEventId) {
                        // É uma instância de evento recorrente - editar diretamente
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                description: newDescription
                            }
                        });
                    } else {
                        // É o evento principal - criar uma exceção
                        // Para simplificar, vamos editar o evento principal
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                description: newDescription
                            }
                        });
                    }
                    break;
                    
                case 'following':
                    // Editar este e eventos seguintes
                    if (event.recurringEventId) {
                        // Buscar evento principal e modificar a partir desta data
                        const masterEvent = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: event.recurringEventId
                        });
                        
                        // Terminar a série original antes desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000); // Um dia antes
                        
                        const updatedRecurrence = masterEvent.result.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.recurringEventId,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                        
                        // Criar nova série a partir desta data com a nova descrição
                        const newEvent = {
                            ...masterEvent.result,
                            description: newDescription,
                            start: event.start,
                            end: event.end
                        };
                        delete newEvent.id;
                        delete newEvent.etag;
                        delete newEvent.htmlLink;
                        delete newEvent.iCalUID;
                        delete newEvent.created;
                        delete newEvent.updated;
                        
                        await gapi.client.calendar.events.insert({
                            calendarId: 'primary',
                            resource: newEvent
                        });
                    } else {
                        // É o evento principal - modificar a partir desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000);
                        
                        const updatedRecurrence = event.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                        
                        // Criar nova série com a nova descrição
                        const newEvent = {
                            ...event,
                            description: newDescription
                        };
                        delete newEvent.id;
                        delete newEvent.etag;
                        delete newEvent.htmlLink;
                        delete newEvent.iCalUID;
                        delete newEvent.created;
                        delete newEvent.updated;
                        
                        await gapi.client.calendar.events.insert({
                            calendarId: 'primary',
                            resource: newEvent
                        });
                    }
                    break;
                    
                case 'all':
                    // Editar toda a série
                    console.log('🔄 Editando toda a série de eventos recorrentes');
                    console.log('📋 Evento atual:', event);
                    
                    let masterEventId;
                    let masterEvent;
                    
                    if (event.recurringEventId) {
                        // É uma instância - buscar o evento principal
                        masterEventId = event.recurringEventId;
                        console.log('📌 Evento é uma instância, buscando master ID:', masterEventId);
                        
                        try {
                            const masterResponse = await gapi.client.calendar.events.get({
                                calendarId: 'primary',
                                eventId: masterEventId
                            });
                            masterEvent = masterResponse.result;
                            console.log('📋 Evento master encontrado:', masterEvent);
                        } catch (error) {
                            console.error('❌ Erro ao buscar evento master:', error);
                            throw new Error('Não foi possível encontrar o evento principal da série');
                        }
                    } else {
                        // É o evento principal
                        masterEventId = event.id;
                        masterEvent = event;
                        console.log('📌 Evento é o principal, ID:', masterEventId);
                    }
                    
                    console.log('🎯 Atualizando evento master:', masterEventId);
                    console.log('📝 Nova descrição:', newDescription);
                    
                    const updateResult = await gapi.client.calendar.events.patch({
                        calendarId: 'primary',
                        eventId: masterEventId,
                        resource: {
                            description: newDescription
                        }
                    });
                    
                    console.log('✅ Resultado da atualização:', updateResult);
                    
                    // Verificar se a atualização foi bem-sucedida
                    if (updateResult.status === 200) {
                        console.log('✅ Evento master atualizado com sucesso');
                        
                        // Aguardar um pouco para que o Google Calendar processe a mudança
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        console.log('🔄 Verificando se a atualização foi aplicada...');
                        const verificationResponse = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: masterEventId
                        });
                        
                        console.log('📋 Descrição após atualização:', verificationResponse.result.description);
                    } else {
                        throw new Error(`Falha na atualização: status ${updateResult.status}`);
                    }
                    break;
            }
            
            console.log('✅ Evento(s) editado(s) com sucesso');
            return true;
        }

        // =================================================================
        // CALENDAR NAVIGATION
        // =================================================================
        function previousMonth() {
            currentDate.setMonth(currentDate.getMonth() - 1);
            // ✅ SINCRONIZAR variáveis globais
            currentYear = currentDate.getFullYear();
            currentMonth = currentDate.getMonth();
            renderCalendar();
        }

        function nextMonth() {
            currentDate.setMonth(currentDate.getMonth() + 1);
            // ✅ SINCRONIZAR variáveis globais
            currentYear = currentDate.getFullYear();
            currentMonth = currentDate.getMonth();
            renderCalendar();
        }

        function goToToday() {
            currentDate = new Date();
            // ✅ SINCRONIZAR variáveis globais
            currentYear = currentDate.getFullYear();
            currentMonth = currentDate.getMonth();
            renderCalendar();
        }

        async function handleSyncClick() {
            if (!isGoogleConnected) {
                showMessage('Conecte-se ao Google Calendar primeiro', 'error');
                return;
            }

            const syncButton = document.getElementById('syncButton');
            syncButton.innerHTML = '<div class="spinner"></div> Sincronizando...';
            syncButton.disabled = true;

            try {
                await loadFilteredEvents();
                showMessage('Sincronização concluída com sucesso!', 'success');
            } catch (error) {
                console.error('❌ Erro na sincronização:', error);
                showMessage('Erro durante a sincronização', 'error');
            } finally {
                syncButton.innerHTML = '<i class="fas fa-sync-alt"></i> Sincronizar';
                syncButton.disabled = false;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        // =================================================================
        // WINDOW CLICK HANDLER - REMOVIDO PARA EVITAR FECHAR MODAL AO CLICAR FORA
        // =================================================================
        // Modal só fecha quando clicar no X

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }


                    // =================================================================
                    // ✅ NOVO: SISTEMA COMPLETO DE EDIÇÃO DE DESCRIÇÃO
                    // =================================================================
            
                    /**
                     * Inicia o modo de edição da descrição do evento
                     * @param {string} eventId - ID do evento a ser editado
                     */
                    function startEditingDescription(eventId) {
                        console.log('🔄 Iniciando edição da descrição para evento:', eventId);
                        
                        // Verificar se já está editando
                        if (isEditingDescription) {
                            showMessage('Já existe uma edição em andamento. Finalize a edição atual primeiro.', 'warning');
                            return;
                        }
                        
                        // Encontrar o evento
                        const event = filteredEvents.find(e => e.id === eventId);
                        if (!event) {
                            console.error('❌ Evento não encontrado:', eventId);
                            showMessage('Evento não encontrado', 'error');
                            return;
                        }
                        
                        // Configurar estado de edição
                        currentEditingEvent = event;
                        isEditingDescription = true;
                        originalDescription = event.description || '';
                        
                        console.log('✅ Modo de edição ativado para:', event.summary);
                        
                        // Obter elemento da seção de descrição
                        const descriptionSection = document.getElementById('descriptionSection');
                        if (!descriptionSection) {
                            console.error('❌ Elemento descriptionSection não encontrado');
                            showMessage('Erro interno: elemento não encontrado', 'error');
                            return;
                        }
                        
                        // Gerar HTML do modo de edição
                        descriptionSection.innerHTML = `
                            <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                            <div class="edit-description-section">
                                <textarea 
                                    id="editDescriptionTextarea" 
                                    class="edit-description-textarea" 
                                    placeholder="Digite a descrição do evento...&#10;&#10;Dica: Você pode usar quebras de linha e formatação de texto."
                                >${originalDescription}</textarea>
                                
                                <div class="edit-hint">
                                    <i class="fas fa-info-circle"></i> 
                                    Pressione Ctrl+Enter para salvar rapidamente
                                </div>
                                
                                <div class="edit-buttons">
                                    <button onclick="saveEventDescription()" class="btn-edit btn-save" id="saveDescriptionBtn">
                                        <i class="fas fa-save"></i> Salvar
                                    </button>
                                    <button onclick="cancelEditingDescription()" class="btn-edit btn-cancel" id="cancelDescriptionBtn">
                                        <i class="fas fa-times"></i> Cancelar
                                    </button>
                                </div>
                                
                                <div id="editLoadingIndicator" class="edit-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <span>Salvando alterações no Google Calendar...</span>
                                </div>
                            </div>
                        `;
                        
                        // Focar no textarea e posicionar cursor no final
                        setTimeout(async () => {
                            const textarea = document.getElementById('editDescriptionTextarea');
                            if (textarea) {
                                textarea.focus();
                                // Posicionar cursor no final do texto
                                const textLength = textarea.value.length;
                                textarea.setSelectionRange(textLength, textLength);
                                
                                console.log('✅ Textarea focado e cursor posicionado');
                            }
                        }, 100);
                    }
            
                    /**
                     * Cancela a edição da descrição e restaura o estado original
                     */
                    function cancelEditingDescription() {
                        console.log('🔄 Cancelando edição da descrição');
                        
                        if (!currentEditingEvent) {
                            console.warn('⚠️ Nenhum evento sendo editado');
                            return;
                        }
                        
                        // Resetar estado
                        const event = currentEditingEvent;
                        isEditingDescription = false;
                        currentEditingEvent = null;
                        originalDescription = '';
                        
                        // Restaurar visualização original
                        const descriptionSection = document.getElementById('descriptionSection');
                        if (!descriptionSection) {
                            console.error('❌ Elemento descriptionSection não encontrado');
                            return;
                        }
                        
                        descriptionSection.innerHTML = `
                            <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                            ${event.description ? `
                                <div id="descriptionDisplay" class="description-display">${event.description}</div>
                            ` : `
                                <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                            `}
                            <button onclick="startEditingDescription('${event.id}')" class="btn-edit">
                                <i class="fas fa-edit"></i> ${event.description ? 'Editar Descrição' : 'Adicionar Descrição'}
                            </button>
                        `;
                        
                        console.log('✅ Edição cancelada e interface restaurada');
                    }
            
                    /**
                     * Salva a descrição editada no Google Calendar
                     */
                    async function saveEventDescription() {
                        console.log('🔄 Iniciando salvamento da descrição');
                        
                        // Validações iniciais
                        if (!currentEditingEvent || !isEditingDescription) {
                            console.error('❌ Estado de edição inválido');
                            showMessage('Erro interno: estado de edição inválido', 'error');
                            return;
                        }
                        
                        // Obter elementos
                        const textarea = document.getElementById('editDescriptionTextarea');
                        const loadingIndicator = document.getElementById('editLoadingIndicator');
                        const saveBtn = document.getElementById('saveDescriptionBtn');
                        const cancelBtn = document.getElementById('cancelDescriptionBtn');
                        
                        if (!textarea) {
                            console.error('❌ Textarea não encontrado');
                            showMessage('Erro interno: campo de texto não encontrado', 'error');
                            return;
                        }
                        
                        // Obter nova descrição
                        const newDescription = textarea.value.trim();
                        const eventId = currentEditingEvent.id;
                        
                        console.log('📝 Nova descrição:', newDescription.substring(0, 100) + (newDescription.length > 100 ? '...' : ''));
                        
                        // Verificar se houve mudança
                        if (newDescription === originalDescription) {
                            console.log('ℹ️ Descrição não foi alterada');
                            showMessage('Nenhuma alteração foi feita', 'warning');
                            cancelEditingDescription();
                            return;
                        }
                        
                        // Mostrar loading e desabilitar botões
                        if (loadingIndicator) loadingIndicator.style.display = 'flex';
                        if (saveBtn) saveBtn.disabled = true;
                        if (cancelBtn) cancelBtn.disabled = true;
                        
                        try {
                            console.log('🔄 Verificando se o evento é recorrente...');
                            
                            // Buscar detalhes completos do evento para verificar recorrência
                            const eventResponse = await gapi.client.calendar.events.get({
                                calendarId: 'primary',
                                eventId: eventId
                            });
                            
                            const event = eventResponse.result;
                            const isRecurring = event.recurringEventId || event.recurrence;
                            
                            if (isRecurring) {
                                // Evento recorrente - mostrar opções
                                console.log('🔄 Evento recorrente detectado, mostrando opções...');
                                
                                // Esconder loading temporariamente
                                if (loadingIndicator) loadingIndicator.style.display = 'none';
                                if (saveBtn) saveBtn.disabled = false;
                                if (cancelBtn) cancelBtn.disabled = false;
                                
                                const choice = await showRecurrenceEditDialog(event.summary || 'Evento');
                                if (!choice) {
                                    console.log('ℹ️ Usuário cancelou a edição');
                                    return; // Usuário cancelou
                                }
                                
                                // Mostrar loading novamente
                                if (loadingIndicator) loadingIndicator.style.display = 'flex';
                                if (saveBtn) saveBtn.disabled = true;
                                if (cancelBtn) cancelBtn.disabled = true;
                                
                                console.log('🔄 Aplicando edição com escolha:', choice);
                                await handleRecurringEventEdit(event, choice, newDescription);
                                
                                // Forçar sincronização para garantir que as mudanças sejam refletidas
                                console.log('🔄 Forçando sincronização após edição de evento recorrente...');
                                await loadFilteredEvents();
                                console.log('✅ Sincronização concluída');
                                
                            } else {
                                // Evento único - edição simples
                                console.log('🔄 Evento único, editando diretamente...');
                                
                                const response = await gapi.client.calendar.events.patch({
                                    calendarId: 'primary',
                                    eventId: eventId,
                                    resource: {
                                        description: newDescription
                                    }
                                });
                                
                                console.log('📡 Resposta da API:', response.status);
                                
                                if (response.status !== 200) {
                                    throw new Error(`Resposta inesperada da API: ${response.status}`);
                                }
                            }
                            
                            console.log('✅ Descrição salva com sucesso no Google Calendar');
                            
                            // Atualizar evento local
                            currentEditingEvent.description = newDescription;
                            
                            // Atualizar na lista de eventos filtrados
                            const eventIndex = filteredEvents.findIndex(e => e.id === eventId);
                            if (eventIndex !== -1) {
                                filteredEvents[eventIndex].description = newDescription;
                                console.log('✅ Evento atualizado na lista local');
                            }
                            
                            // Resetar estado de edição
                            const eventForDisplay = currentEditingEvent;
                            isEditingDescription = false;
                            currentEditingEvent = null;
                            originalDescription = '';
                            
                            // Restaurar visualização com nova descrição
                            const descriptionSection = document.getElementById('descriptionSection');
                            if (descriptionSection) {
                                descriptionSection.innerHTML = `
                                    <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                                    ${newDescription ? `
                                        <div id="descriptionDisplay" class="description-display">${newDescription}</div>
                                    ` : `
                                        <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                                    `}
                                    <button onclick="startEditingDescription('${eventForDisplay.id}')" class="btn-edit">
                                        <i class="fas fa-edit"></i> ${newDescription ? 'Editar Descrição' : 'Adicionar Descrição'}
                                    </button>
                                `;
                            }
                            
                            // Atualizar resumo mensal (caso a descrição tenha valores)
                            console.log('🔄 Atualizando resumo mensal...');
                            updateMonthlySummary();
                            
                            // Renderizar calendário novamente
                            console.log('🔄 Renderizando calendário...');
                            renderCalendar();
                            
                            showMessage('Descrição atualizada com sucesso!', 'success');
                            
                        } catch (error) {
                            console.error('❌ Erro ao salvar descrição:', error);
                            
                            let errorMessage = 'Erro ao salvar descrição. ';
                            
                            if (error.status === 401) {
                                errorMessage += 'Sessão expirada. Reconecte-se ao Google Calendar.';
                            } else if (error.status === 403) {
                                errorMessage += 'Sem permissão para editar este evento.';
                            } else if (error.status === 404) {
                                errorMessage += 'Evento não encontrado no Google Calendar.';
                            } else {
                                errorMessage += 'Tente novamente em alguns instantes.';
                            }
                            
                            showMessage(errorMessage, 'error');
                            
                            // Reabilitar botões em caso de erro
                            if (saveBtn) saveBtn.disabled = false;
                            if (cancelBtn) cancelBtn.disabled = false;
                            
                        } finally {
                            // Esconder loading
                            if (loadingIndicator) {
                                loadingIndicator.style.display = 'none';
                            }
                            
                            console.log('🔄 Processo de salvamento finalizado');
                        }
                    }
            
                    /**
                     * Manipulador de eventos de teclado para atalhos
                     */
                    function handleEditingKeyboard(event) {
                        if (!isEditingDescription) return;
                        
                        // Ctrl+Enter para salvar
                        if (event.ctrlKey && event.key === 'Enter') {
                            event.preventDefault();
                            console.log('⌨️ Atalho Ctrl+Enter detectado');
                            saveEventDescription();
                            return;
                        }
                        
                        // Escape para cancelar
                        if (event.key === 'Escape') {
                            event.preventDefault();
                            console.log('⌨️ Atalho Escape detectado');
                            cancelEditingDescription();
                            return;
                        }
                    }
            
                    // Adicionar listener para atalhos de teclado
                    document.addEventListener('keydown', handleEditingKeyboard);

        // =================================================================
        // FUNÇÕES DE RECORRÊNCIA PERSONALIZADA
        // =================================================================
        
        /**
         * Manipula a mudança no dropdown de recorrência
         */
        function handleRecurrenceChange() {
            const select = document.getElementById('eventRecurrence');
            if (select.value === 'CUSTOM') {
                showCustomRecurrenceModal();
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Mostra o modal de recorrência personalizada
         */
        function showCustomRecurrenceModal() {
            const modal = document.getElementById('customRecurrenceModal');
            if (modal) {
                modal.style.display = 'flex';
                
                // Configurar data padrão baseada na data do evento
                const eventDate = document.getElementById('eventDate').value;
                if (eventDate) {
                    const date = new Date(eventDate);
                    const dayOfWeek = date.getDay();
                    
                    // Selecionar o dia da semana correspondente
                    document.querySelectorAll('.weekday-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    const weekdayBtn = document.querySelector(`[data-day="${dayOfWeek}"]`);
                    if (weekdayBtn) {
                        weekdayBtn.classList.add('selected');
                    }
                    
                    // Configurar data de término padrão (3 meses depois)
                    const endDate = new Date(date);
                    endDate.setMonth(endDate.getMonth() + 3);
                    document.getElementById('endDateValue').value = endDate.toISOString().split('T')[0];
                }
                
                // Configurar event listeners
                setupCustomRecurrenceListeners();
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }

        /**
         * Configura os event listeners do modal de recorrência
         */
        function setupCustomRecurrenceListeners() {
            // Listener para mudança de unidade de tempo
            const unitSelect = document.getElementById('recurrenceUnit');
            unitSelect.addEventListener('change', function() {
                const weekdaysGroup = document.getElementById('weekdaysGroup');
                if (this.value === 'week') {
                    weekdaysGroup.style.display = 'block';
                } else {
                    weekdaysGroup.style.display = 'none';
                }
            }); // Fechamento do DOMContentLoaded

            // Listeners para botões de dias da semana
            document.querySelectorAll('.weekday-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('selected');
                });
            }); // Fechamento do DOMContentLoaded

            // Listeners para opções de término
            document.querySelectorAll('input[name="endType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    const endDateInput = document.getElementById('endDateValue');
                    const endCountInput = document.getElementById('endCountValue');
                    
                    endDateInput.disabled = this.value !== 'date';
                    endCountInput.disabled = this.value !== 'count';
                });
            }); // Fechamento do DOMContentLoaded

            // Fechar modal ao clicar fora
            const modal = document.getElementById('customRecurrenceModal');
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeCustomRecurrenceModal();
                }
            }); // Fechamento do DOMContentLoaded
        }

        /**
         * Fecha o modal de recorrência personalizada
         */
        function closeCustomRecurrenceModal() {
            const modal = document.getElementById('customRecurrenceModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Resetar dropdown para "Não se repete"
            const select = document.getElementById('eventRecurrence');
            select.value = 'NONE';
        }

        /**
         * Confirma a recorrência personalizada e gera RRULE
         */
        function confirmCustomRecurrence() {
            const interval = parseInt(document.getElementById('recurrenceInterval').value) || 1;
            const unit = document.getElementById('recurrenceUnit').value;
            const endType = document.querySelector('input[name="endType"]:checked').value;
            
            let rrule = '';
            let description = '';
            
            // Gerar RRULE baseado na unidade
            switch (unit) {
                case 'day':
                    rrule = `FREQ=DAILY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Todos os dias' : `A cada ${interval} dias`;
                    break;
                    
                case 'week':
                    const selectedDays = [];
                    document.querySelectorAll('.weekday-btn.selected').forEach(btn => {
                        const day = parseInt(btn.dataset.day);
                        const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
                        selectedDays.push(rruleDays[day]);
                    });
                    
                    if (selectedDays.length > 0) {
                        rrule = `FREQ=WEEKLY;INTERVAL=${interval};BYDAY=${selectedDays.join(',')}`;
                        if (interval === 1) {
                            description = selectedDays.length === 7 ? 'Todos os dias' : 
                                         selectedDays.length === 5 && !selectedDays.includes('SU') && !selectedDays.includes('SA') ? 'Dias úteis' :
                                         `Semanal: ${selectedDays.join(', ')}`;
                        } else {
                            description = `A cada ${interval} semanas: ${selectedDays.join(', ')}`;
                        }
                    } else {
                        alert('Selecione pelo menos um dia da semana');
                        return;
                    }
                    break;
                    
                case 'month':
                    rrule = `FREQ=MONTHLY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Mensalmente' : `A cada ${interval} meses`;
                    break;
                    
                case 'year':
                    rrule = `FREQ=YEARLY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Anualmente' : `A cada ${interval} anos`;
                    break;
            }
            
            // Adicionar término se especificado
            if (endType === 'date') {
                const endDate = document.getElementById('endDateValue').value;
                if (endDate) {
                    const formattedDate = endDate.replace(/-/g, '');
                    rrule += `;UNTIL=${formattedDate}T235959Z`;
                    description += ` até ${new Date(endDate).toLocaleDateString('pt-BR')}`;
                }
            } else if (endType === 'count') {
                const count = parseInt(document.getElementById('endCountValue').value) || 10;
                rrule += `;COUNT=${count}`;
                description += ` por ${count} ocorrências`;
            }
            
            // Salvar RRULE personalizada
            window.customRRule = rrule;
            window.customRecurrenceDescription = description;
            
            // Atualizar dropdown com descrição personalizada
            const select = document.getElementById('eventRecurrence');
            
            // Remover opção personalizada anterior se existir
            const existingCustom = select.querySelector('option[value="CUSTOM_GENERATED"]');
            if (existingCustom) {
                existingCustom.remove();
            }
            
            // Adicionar nova opção personalizada
            const customOption = document.createElement('option');
            customOption.value = 'CUSTOM_GENERATED';
            customOption.textContent = description;
            customOption.selected = true;
            
            // Inserir antes da opção "Personalizar..."
            const personalizeOption = select.querySelector('option[value="CUSTOM"]');
            select.insertBefore(customOption, personalizeOption);
            
            // Fechar modal
            closeCustomRecurrenceModal();
            
            console.log('✅ Recorrência personalizada configurada:', { rrule, description });
        }

        /**
         * Gera RRULE baseado na seleção do dropdown
         */
        function generateRRule(recurrenceType, eventDate) {
            const date = new Date(eventDate);
            const dayOfWeek = date.getDay();
            const dayOfMonth = date.getDate();
            const month = date.getMonth() + 1;
            
            // Mapear dias da semana para RRULE
            const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
            const currentDay = rruleDays[dayOfWeek];
            
            switch (recurrenceType) {
                case 'NONE':
                    return null;
                    
                case 'DAILY':
                    return 'FREQ=DAILY';
                    
                case 'WEEKLY':
                    return `FREQ=WEEKLY;BYDAY=${currentDay}`;
                    
                case 'MONTHLY':
                    // Calcular qual semana do mês (primeira, segunda, terceira, etc.)
                    const weekOfMonth = Math.ceil(dayOfMonth / 7);
                    return `FREQ=MONTHLY;BYDAY=${weekOfMonth}${currentDay}`;
                    
                case 'YEARLY':
                    return `FREQ=YEARLY;BYMONTH=${month};BYMONTHDAY=${dayOfMonth}`;
                    
                case 'WEEKDAYS':
                    return 'FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR';
                    
                case 'CUSTOM_GENERATED':
                    return window.customRRule || null;
                    
                default:
                    return null;
            }
        }

        /**
         * Função pública para exclusão de eventos (wrapper que evita override)
         */
        async function deleteCalendarEvent(eventId, accountEmail = null) {
            console.log(`🗑️ deleteCalendarEvent chamada com ID: ${eventId}`);
            return await realDeleteCalendarEvent(eventId, accountEmail);
        }


        
        // =================================================================
        // INICIALIZAÇÃO
        // =================================================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Sistema de Fluxo de Caixa HVC inicializado');
            
            // Inicializar estado de conexão
            updateConnectionStatus(false);
            
            // Renderizar calendário inicial (vazio)
            renderCalendar();
            
            // ✅ NOVO: Inicializar filtros de pagamentos e recebimentos
            initializePaymentFilters();
            initializeReceivingFilters();
            
            // ✅ NOVO: Inicializar event listeners para tipo de evento
            initializeEventTypeListeners();
        }); // Fechamento do DOMContentLoaded

        // =================================================================
        // ✅ FUNCIONALIDADES DE EDIÇÃO DE ITENS - ESCOPO GLOBAL
        // =================================================================
        
        // Variáveis globais para edição
        let currentEditingEventData = null;
        let currentEditingItemsData = [];

        // Função para iniciar edição de itens
        window.startEditingEventItems = async function(eventId, eventType) {
            try {
                console.log('🔧 Iniciando edição de itens...');
                console.log('🆔 Event ID:', eventId);
                console.log('🏷️ Event Type:', eventType);
                
                // Verificar se o Google API está carregado
                if (typeof gapi === 'undefined' || !gapi.client) {
                    throw new Error('Google API não está carregado. Aguarde o carregamento da página.');
                }
                
                // Verificar se há token de acesso
                const token = gapi.client.getToken();
                if (!token) {
                    throw new Error('Você precisa estar conectado ao Google Calendar para editar eventos.');
                }
                
                console.log('📤 Buscando evento...');
                const response = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                console.log('✅ Evento encontrado:', response.result);
                currentEditingEventData = response.result;
                
                // Extrair linhas da descrição do evento
                const eventDescription = currentEditingEventData.description || '';
                console.log('📄 Descrição do evento:', eventDescription);
                const descriptionLines = eventDescription.split('\n').filter(line => line.trim());
                console.log('📋 Linhas da descrição:', descriptionLines);
                
                // Calcular itens do evento
                const eventCalc = calculateEventTotal(currentEditingEventData);
                const items = eventType === 'recebimento' ? eventCalc.receivingItems : eventCalc.paymentItems;
                
                console.log('📋 Itens encontrados:', items);
                currentEditingItemsData = items;
                
                // Criar interface de edição
                const editDiv = document.getElementById('payments-edit');
                if (!editDiv) {
                    console.error('❌ Div payments-edit não encontrada');
                    return;
                }
                
                let editHTML = '<div class="edit-items-form">';
                
                items.forEach((item, index) => {
                    const statusOptions = eventType === 'recebimento' 
                        ? ['RC', 'ADIADO', 'AGUARDANDO']
                        : ['PG', 'RECALCULADO', 'PENDENTE'];
                    
                    // DEBUG: Verificar o nome original do item
                    console.log(`🔍 Item ${index} - Nome original:`, item.name);
                    console.log(`🔍 Item ${index} - Original completo:`, item.original);
                    
                    // Buscar a linha correspondente na descrição
                    let fullItemLine = '';
                    for (const line of descriptionLines) {
                        // Verificar se a linha contém o nome do item e o valor
                        if (line.includes(item.name) && line.includes(item.formattedValue)) {
                            fullItemLine = line;
                            break;
                        }
                    }
                    
                    console.log(`🔍 Item ${index} - Linha completa da descrição:`, fullItemLine);
                    
                    // Extrair tipo, subtipo e categoria da linha completa (formato: TIPO - SUBTIPO - CATEGORIA - NOME - VALOR - STATUS)
                    // Primeiro, remover a parte do valor e status
                    const beforeValue = fullItemLine.split(' - R$')[0];
                    console.log(`🔍 Item ${index} - Antes do valor:`, beforeValue);
                    
                    const nameParts = beforeValue.split(' - ');
                    console.log(`🔍 Item ${index} - Partes do nome:`, nameParts);
                    let tipo = '', subtipo = '', categoria = '', nome = item.name || '';
                    
                    if (nameParts.length >= 4) {
                        tipo = nameParts[0];
                        subtipo = nameParts[1];
                        categoria = nameParts[2];
                        nome = nameParts.slice(3).join(' - ');
                    } else if (nameParts.length === 3) {
                        subtipo = nameParts[0];
                        categoria = nameParts[1];
                        nome = nameParts[2];
                    } else if (nameParts.length === 2) {
                        subtipo = nameParts[0];
                        nome = nameParts[1];
                    }
                    
                    console.log(`✅ Item ${index} - Extraído: TIPO="${tipo}", SUBTIPO="${subtipo}", CATEGORIA="${categoria}", NOME="${nome}"`);
                    
                    editHTML += `
                        <div class="edit-item-row">
                            ${eventType === 'pagamento' ? `
                            <div class="edit-item-field">
                                <label>TIPO:</label>
                                <select class="edit-item-tipo" data-item-index="${index}" onchange="updateEditTipoForPayment(${index})">
                                    <option value="">Nenhum</option>
                                    <option value="INTERNO" ${tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                                    <option value="EXTERNO" ${tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                                </select>
                            </div>
                            <div class="edit-item-field">
                                <label>SUBTIPO:</label>
                                <div class="field-with-manage">
                                    <select class="edit-item-subtipo" data-item-index="${index}" onchange="updateCategoriaSelectInEdit(${index}, this.value)">
                                        <option value="">Nenhum</option>
                                    </select>
                                    <button type="button" class="btn-manage-list" onclick="openManageListModal(\'subtipos\')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="edit-item-field">
                                <label>CATEGORIA:</label>
                                <div class="field-with-manage">
                                    <select class="edit-item-categoria" data-item-index="${index}">
                                        <option value="">Selecione uma obra...</option>
                                    </select>
                                    <button type="button" class="btn-manage-list btn-manage-categorias" data-item-index="${index}" onclick="openManageListModal(\'categorias\')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            ` : eventType === 'recebimento' ? `
                            <div class="edit-item-field">
                                <label>TIPO:</label>
                                <select class="edit-item-tipo" data-item-index="${index}" onchange="updateEditTipoForReceiving(${index})">
                                    <option value="">Nenhum</option>
                                    <option value="OBRAS" ${tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                                    <option value="OUTROS" ${tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                                </select>
                            </div>
                            <div class="edit-item-field">
                                <label>SUBTIPO:</label>
                                <div class="field-with-manage">
                                    <select class="edit-item-subtipo" data-item-index="${index}" onchange="updateEditCategoriaForReceivingByIndex(${index})">
                                        <option value="">Nenhum</option>
                                    </select>
                                    <button type="button" class="btn-manage-list btn-manage-subtipo-rec" data-item-index="${index}" id="btn-manage-subtipo-rec-${index}">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="edit-item-field">
                                <label>CATEGORIA:</label>
                                <div class="field-with-manage">
                                    <select class="edit-item-categoria" data-item-index="${index}">
                                        <option value="">Nenhum</option>
                                    </select>
                                    <button type="button" class="btn-manage-list btn-manage-categoria-rec" data-item-index="${index}" id="btn-manage-categoria-rec-${index}">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>


                            ` : ''}
                            <div class="edit-item-field">
                                <label>NOME:</label>
                                <input type="text" class="edit-item-name" value="${nome}" />
                            </div>
                            <div class="edit-item-field">
                                <label>VALOR:</label>
                                <input type="number" class="edit-item-value" value="${item.value || 0}" step="0.01" />
                            </div>
                            <div class="edit-item-field">
                                <label>STATUS:</label>
                                <select class="edit-item-status">
                                    ${statusOptions.map(status => 
                                        `<option value="${status}" ${item.status === status ? 'selected' : ''}>${status}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <div class="edit-item-field">
                                <label>DETALHE:</label>
                                <input type="text" class="edit-item-detail" value="${item.detail || ''}" />
                            </div>
                        </div>
                    `;
                });
                
                editHTML += `
                    <div class="edit-items-actions">
                        <button class="btn-save-items" onclick="saveEventItemsChanges('${eventId}', '${eventType}')">
                            <i class="fas fa-save"></i> SALVAR ALTERAÇÕES
                        </button>
                        <button class="btn-cancel-edit" onclick="cancelEditingEventItems()">
                            <i class="fas fa-times"></i> CANCELAR
                        </button>
                    </div>
                </div>`;
                
                editDiv.innerHTML = editHTML;
                editDiv.style.display = 'block';
                
                // Popular selects de TIPO, SUBTIPO e CATEGORIA
                items.forEach((item, index) => {
                    // Extrair tipo, subtipo e categoria do nome do item
                    const nameParts = (item.name || '').split(' - ');
                    let tipo = '', subtipo = '', categoria = '', nome = item.name || '';
                    
                    if (nameParts.length >= 4) {
                        tipo = nameParts[0];
                        subtipo = nameParts[1];
                        categoria = nameParts[2];
                        nome = nameParts.slice(3).join(' - ');
                    } else if (nameParts.length === 3) {
                        subtipo = nameParts[0];
                        categoria = nameParts[1];
                        nome = nameParts[2];
                    } else if (nameParts.length === 2) {
                        subtipo = nameParts[0];
                        nome = nameParts[1];
                    }
                    
                    setTimeout(async () => {
                        if (eventType === 'pagamento') {
                            // PAGAMENTO: Popular TIPO, SUBTIPO e CATEGORIA
                            const tipoSelect = document.querySelector(`.edit-item-tipo[data-item-index="${index}"]`);
                            if (tipoSelect && tipo) {
                                tipoSelect.value = tipo;
                                // Chamar função para popular SUBTIPO baseado no TIPO
                                await updateEditTipoForPayment(index);
                                
                                // Aguardar um pouco e selecionar SUBTIPO
                                setTimeout(async () => {
                                    const subtipoSelect = document.querySelector(`.edit-item-subtipo[data-item-index="${index}"]`);
                                    if (subtipoSelect && subtipo) {
                                        subtipoSelect.value = subtipo;
                                        
                                        // Adicionar evento de mudança
                                        subtipoSelect.addEventListener('change', function() {
                                            updateCategoriaSelectInEdit(index, this.value);
                                        });
                                        
                                        // Popular CATEGORIA baseado no SUBTIPO
                                        await updateCategoriaSelectInEdit(index, subtipo);
                                        
                                        // Aguardar um pouco e selecionar CATEGORIA
                                        setTimeout(() => {
                                            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${index}"]`);
                                            if (categoriaSelect && categoria) {
                                                categoriaSelect.value = categoria;
                                            }
                                        }, 200);
                                    }
                                }, 300);
                            }
                        } else if (eventType === 'recebimento') {
                            // RECEBIMENTO: Popular TIPO, SUBTIPO e CATEGORIA
                            const tipoSelect = document.querySelector(`.edit-item-tipo[data-item-index="${index}"]`);
                            if (tipoSelect && tipo) {
                                tipoSelect.value = tipo;
                                // Chamar função para popular SUBTIPO baseado no TIPO
                                await updateEditTipoForReceiving(index);
                                
                                // Aguardar um pouco e selecionar SUBTIPO
                                setTimeout(async () => {
                                    const subtipoSelect = document.querySelector(`.edit-item-subtipo[data-item-index="${index}"]`);
                                    if (subtipoSelect && subtipo) {
                                        subtipoSelect.value = subtipo;
                                        // Popular CATEGORIA baseado no SUBTIPO
                                        await updateEditCategoriaForReceivingByIndex(index);
                                        
                                        // Aguardar um pouco e selecionar CATEGORIA
                                        setTimeout(() => {
                                            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${index}"]`);
                                            if (categoriaSelect && categoria) {
                                                categoriaSelect.value = categoria;
                                            }
                                        }, 200);
                                    }
                                }, 300);
                            }
                        }
                    }, 100 * (index + 1)); // Escalonar para evitar conflitos
                });
                
                console.log('✅ Interface de edição criada');
                
            } catch (error) {
                console.error('❌ Erro ao iniciar edição:', error);
                alert('Erro ao carregar dados para edição: ' + error.message);
            }
        };



        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA baseado no tipo de evento
        window.renderEventTypeFields = function(eventType) {
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoContainer = document.getElementById('itemSubtipo')?.closest('.form-group');
            const categoriaContainer = document.getElementById('itemCategoria')?.closest('.form-group');
            
            if (!tipoSelect || !subtipoContainer || !categoriaContainer) {
                console.warn('Campos não encontrados para renderizar');
                return;
            }
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: TIPO = INTERNO/EXTERNO
                tipoSelect.innerHTML = `
                    <option value="">Nenhum</option>
                    <option value="INTERNO">INTERNO</option>
                    <option value="EXTERNO">EXTERNO</option>
                `;
                
                // Adicionar evento onchange para atualizar SUBTIPO baseado no TIPO
                tipoSelect.onchange = updateSubtipoForPayment;
                
                subtipoContainer.innerHTML = `
                    <label>Subtipo</label>
                    <div class="select-with-manage">
                        <select id="itemSubtipo" onchange="updateCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="manage-list-btn" onclick="openManageSubtiposPayment()" title="Gerenciar lista">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaContainer.innerHTML = `
                    <label>Categoria</label>
                    <div class="select-with-manage">
                        <select id="itemCategoria">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="manage-list-btn" id="manageCategoriaBtn" onclick="openManageCategoriasPayment()" title="Gerenciar lista">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular SUBTIPO para pagamento baseado no TIPO
                updateSubtipoForPayment();
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: TIPO = OBRAS/OUTROS
                tipoSelect.innerHTML = `
                    <option value="">Nenhum</option>
                    <option value="OBRAS">OBRAS</option>
                    <option value="OUTROS">OUTROS</option>
                `;
                
                // Adicionar evento onchange para atualizar SUBTIPO
                tipoSelect.onchange = updateSubtipoForReceiving;
                
                // Adicionar evento onchange para atualizar SUBTIPO
                tipoSelect.onchange = updateSubtipoForReceiving;
                
                subtipoContainer.innerHTML = `
                    <label>Subtipo</label>
                    <div class="select-with-manage">
                        <select id="itemSubtipo" onchange="updateCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="manage-list-btn" id="btn-manage-subtipo-rec" onclick="openManageSubtiposRecModal()" title="Gerenciar lista">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaContainer.innerHTML = `
                    <label>Categoria</label>
                    <div class="select-with-manage">
                        <select id="itemCategoria">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="manage-list-btn" id="manageCategoriaBtn" onclick="openManageCategoriasRecModal()" title="Gerenciar lista">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
            }
        };
        
        // Função para atualizar SUBTIPO para PAGAMENTO baseado no TIPO
        window.updateSubtipoForPayment = async function() {
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            // Limpar SUBTIPO
            subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
            
            // Determinar qual tabela usar baseado no TIPO
            let tableKey = null;
            
            if (tipo === 'INTERNO') {
                tableKey = 'pagamento_interno_subtipos';
            } else if (tipo === 'EXTERNO') {
                // Adicionar OBRA primeiro
                subtipoSelect.innerHTML += '<option value="OBRA">OBRA</option>';
                tableKey = 'pagamento_externo_subtipos';
            }
            
            // Adicionar subtipos personalizados se houver tabela definida
            if (tableKey) {
                const customSubtipos = await loadListFromSupabase(tableKey);
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            }
            
            // Limpar CATEGORIA quando SUBTIPO muda
            const categoriaSelect = document.getElementById('itemCategoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        // Função para atualizar CATEGORIA baseado no SUBTIPO (PAGAMENTO)
        window.updateCategoriaBasedOnSubtipo = async function() {
            const subtipoSelect = document.getElementById('itemSubtipo');
            const categoriaSelect = document.getElementById('itemCategoria');
            
            if (!subtipoSelect || !categoriaSelect) return;
            
            const subtipo = subtipoSelect.value;
            
            // Limpar CATEGORIA
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            
            // Se SUBTIPO = OBRA, carregar obras do Supabase
            if (subtipo === 'OBRA') {
                categoriaSelect.innerHTML = '<option value="">Carregando obras...</option>';
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            categoriaSelect.innerHTML += `<option value="${obraName}">${obraName}</option>`;
                        });
                    } else {
                        categoriaSelect.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    }
                } catch (error) {
                    console.error('Erro ao carregar obras:', error);
                    categoriaSelect.innerHTML = '<option value="">Erro ao carregar obras</option>';
                }
            } else if (subtipo) {
                // Senão, carregar categorias personalizadas baseado no TIPO
                const tipoSelect = document.getElementById('itemTipo');
                const tipo = tipoSelect ? tipoSelect.value : null;
                
                let tableKey = null;
                if (tipo === 'INTERNO') {
                    tableKey = 'pagamento_interno_categorias';
                } else if (tipo === 'EXTERNO') {
                    tableKey = 'pagamento_externo_categorias';
                }
                
                if (tableKey) {
                    const customCategorias = await loadListFromSupabase(tableKey);
                    customCategorias.forEach(cat => {
                        categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                    });
                }
            }

        };
        
        // Funções wrapper para abrir modais de gerenciamento de PAGAMENTO

// Abre modal de gerenciamento de SUBTIPOS de PAGAMENTO
window.openManageSubtiposPayment = function() {
    const tipoSelect = document.getElementById('itemTipo');
    const tipo = tipoSelect ? tipoSelect.value : null;
    
    let tableKey = null;
    let title = 'Gerenciar Subtipos';
    
    if (tipo === 'INTERNO') {
        tableKey = 'pagamento_interno_subtipos';
        title = 'Gerenciar Subtipos de Pagamento Interno';
    } else if (tipo === 'EXTERNO') {
        tableKey = 'pagamento_externo_subtipos';
        title = 'Gerenciar Subtipos de Pagamento Externo';
    } else {
        alert('Selecione um TIPO (INTERNO ou EXTERNO) primeiro!');
        return;
    }
    
    openManageListModal(tableKey, title, function() {
        updateSubtipoForPayment();
    });
};

// Abre modal de gerenciamento de CATEGORIAS de PAGAMENTO
window.openManageCategoriasPayment = function() {
    const tipoSelect = document.getElementById('itemTipo');
    const tipo = tipoSelect ? tipoSelect.value : null;
    
    let tableKey = null;
    let title = 'Gerenciar Categorias';
    
    if (tipo === 'INTERNO') {
        tableKey = 'pagamento_interno_categorias';
        title = 'Gerenciar Categorias de Pagamento Interno';
    } else if (tipo === 'EXTERNO') {
        tableKey = 'pagamento_externo_categorias';
        title = 'Gerenciar Categorias de Pagamento Externo';
    } else {
        alert('Selecione um TIPO (INTERNO ou EXTERNO) primeiro!');
        return;
    }
    
    openManageListModal(tableKey, title, function() {
        updateCategoriaBasedOnSubtipo();
    });
};



        
        // Função para popular SUBTIPO no modal de edição (PAGAMENTO)
        window.populateEditSubtipo = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            const currentValue = subtipoSelect.value;
            
            // Limpar SUBTIPO
            subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
            
            // Se TIPO = EXTERNO, adicionar OBRA
            if (tipo === 'EXTERNO') {
                subtipoSelect.innerHTML += '<option value="OBRA">OBRA</option>';
            }
            
            // Adicionar subtipos personalizados
            const customSubtipos = await loadListFromSupabase('hvc_subtipos_pagamento');
            customSubtipos.forEach(st => {
                subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
            });
            
            // Restaurar valor anterior se ainda existir
            if (currentValue) {
                subtipoSelect.value = currentValue;
            }
        };
        
        // Função para atualizar CATEGORIA baseado no SUBTIPO no modal de edição (PAGAMENTO)
        window.updateEditCategoriaBasedOnSubtipo = async function() {
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            
            if (!subtipoSelect || !categoriaSelect) return;
            
            const subtipo = subtipoSelect.value;
            const currentValue = categoriaSelect.value;
            
            // Limpar CATEGORIA
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            
            // Se SUBTIPO = OBRA, carregar obras do Supabase
            if (subtipo === 'OBRA') {
                categoriaSelect.innerHTML = '<option value="">Carregando obras...</option>';
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            categoriaSelect.innerHTML += `<option value="${obraName}">${obraName}</option>`;
                        });
                    } else {
                        categoriaSelect.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    }
                    
                    // Restaurar valor anterior se ainda existir
                    if (currentValue) {
                        categoriaSelect.value = currentValue;
                    }
                } catch (error) {
                    console.error('Erro ao carregar obras:', error);
                    categoriaSelect.innerHTML = '<option value="">Erro ao carregar obras</option>';
                }
            } else {
                // Senão, carregar categorias personalizadas
                const customCategorias = await loadListFromSupabase('hvc_categorias_pagamento');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
                
                // Restaurar valor anterior se ainda existir
                if (currentValue) {
                    categoriaSelect.value = currentValue;
                }
            }
        };

        // Funções auxiliares para edição de RECEBIMENTO
        window.updateEditTipoForReceiving = async function(index) {
            const tipoSelect = document.querySelector(`.edit-item-tipo[data-item-index="${index}"]`);
            const subtipoSelect = document.querySelector(`.edit-item-subtipo[data-item-index="${index}"]`);
            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${index}"]`);
            const btnManageSubtipo = document.getElementById(`btn-manage-subtipo-rec-${index}`);
            const btnManageCategoria = document.getElementById(`btn-manage-categoria-rec-${index}`);
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            
            // Limpar selects
            subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            
                if (tipo === 'OBRAS') {
                // Carregar obras do Supabase
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    obras.forEach(obra => {
                        const option = document.createElement('option');
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        option.value = obraName;
                        option.textContent = obraName;
                        subtipoSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Erro ao carregar obras:', error);
                }
                
                // Desabilitar botões de gerenciamento
                if (btnManageSubtipo) {
                    btnManageSubtipo.disabled = true;
                    btnManageSubtipo.style.opacity = '0.5';
                    btnManageSubtipo.style.cursor = 'not-allowed';
                    btnManageSubtipo.style.pointerEvents = 'none';
                }
                if (btnManageCategoria) {
                    btnManageCategoria.disabled = true;
                    btnManageCategoria.style.opacity = '0.5';
                    btnManageCategoria.style.cursor = 'not-allowed';
                    btnManageCategoria.style.pointerEvents = 'none';
                }
                
            } else if (tipo === 'OUTROS') {
                // Carregar subtipos personalizados usando a função correta
                try {
                    const subtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                    
                    subtipos.forEach(subtipo => {
                        const option = document.createElement('option');
                        option.value = subtipo;
                        option.textContent = subtipo;
                        subtipoSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Erro ao carregar subtipos:', error);
                }
                
                // Habilitar botões de gerenciamento
                if (btnManageSubtipo) {
                    btnManageSubtipo.disabled = false;
                    btnManageSubtipo.style.opacity = '1';
                    btnManageSubtipo.style.cursor = 'pointer';
                    btnManageSubtipo.style.pointerEvents = 'auto';
                    btnManageSubtipo.onclick = function() {
                        openManageListModal(
                            'recebimento_outros_subtipos',
                            'Gerenciar Subtipos de Recebimento (Outros)',
                            () => updateEditTipoForReceiving(index)
                        );
                    };
                }
                if (btnManageCategoria) {
                    btnManageCategoria.disabled = false;
                    btnManageCategoria.style.opacity = '1';
                    btnManageCategoria.style.cursor = 'pointer';
                    btnManageCategoria.style.pointerEvents = 'auto';
                    btnManageCategoria.onclick = function() {
                        openManageListModal(
                            'recebimento_outros_categorias',
                            'Gerenciar Categorias de Recebimento (Outros)',
                            () => updateEditCategoriaForReceivingByIndex(index)
                        );
                    };
                }
            }
        };
        
        window.updateEditCategoriaForReceivingByIndex = async function(index) {
            const tipoSelect = document.querySelector(`.edit-item-tipo[data-item-index="${index}"]`);
            const subtipoSelect = document.querySelector(`.edit-item-subtipo[data-item-index="${index}"]`);
            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${index}"]`);
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            // Limpar select de categoria
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            
            if (tipo === 'OBRAS' && subtipo) {
                // Carregar medições da obra
                try {
                    // Primeiro, buscar o ID da obra pelo numero_obra
                    const { data: obras, error: obraError } = await supabase
                        .from('obras_hvc')
                        .select('id')
                        .eq('numero_obra', subtipo)
                        .limit(1);
                    
                    if (obraError) throw obraError;
                    
                    if (!obras || obras.length === 0) {
                        console.warn('Obra não encontrada:', subtipo);
                        return;
                    }
                    
                    const obraId = obras[0].id;
                    
                    // Agora buscar medições usando o obra_id
                    const { data: medicoes, error } = await supabase
                        .from('medicoes_hvc')
                        .select('*')
                        .eq('obra_id', obraId)
                        .order('numero_medicao', { ascending: true });
                    
                    if (error) throw error;
                    
                    medicoes.forEach(medicao => {
                        const option = document.createElement('option');
                        const medicaoNum = medicao.numero_medicao || medicao.numero || medicao.id;
                        option.value = medicaoNum;
                        option.textContent = `Medição ${medicaoNum}`;
                        categoriaSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Erro ao carregar medições:', error);
                }
                
            } else if (tipo === 'OUTROS') {
                // Carregar categorias personalizadas
                try {
                    const { data: categorias, error } = await supabase
                        .from('recebimento_outros_categorias')
                        .select('*')
                        .order('created_at', { ascending: false});
                    
                    if (error) throw error;
                    
                    categorias.forEach(categoria => {
                        const option = document.createElement('option');
                        option.value = categoria.nome;
                        option.textContent = categoria.nome;
                        categoriaSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Erro ao carregar categorias:', error);
                }
            }
        };




        
        // Função para atualizar SUBTIPO quando TIPO muda (RECEBIMENTO)
        window.updateSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            const btnManageSubtipo = document.getElementById('btn-manage-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                // Carregar obras do Supabase
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManageSubtipo) {
                    btnManageSubtipo.disabled = true;
                    btnManageSubtipo.style.opacity = '0.5';
                    btnManageSubtipo.style.pointerEvents = 'none';
                    btnManageSubtipo.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            const obraId = obra.id;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obraId}">${obraName}</option>`;
                        });
                        
                        // Adicionar evento onchange para atualizar CATEGORIA
                        subtipoSelect.onchange = updateCategoriaForReceiving;
                    } else {
                        subtipoSelect.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    }
                } catch (error) {
                    console.error('Erro ao carregar obras:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar obras</option>';
                }
            } else if (tipo === 'OUTROS') {
                // Usar lista personalizada
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManageSubtipo) {
                    btnManageSubtipo.disabled = false;
                    btnManageSubtipo.style.opacity = '1';
                    btnManageSubtipo.style.pointerEvents = 'auto';
                    btnManageSubtipo.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManageSubtipo) {
                    btnManageSubtipo.disabled = true;
                    btnManageSubtipo.style.opacity = '0.5';
                    btnManageSubtipo.style.pointerEvents = 'none';
                    btnManageSubtipo.style.cursor = 'not-allowed';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('itemCategoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        // Função para atualizar CATEGORIA quando SUBTIPO muda (RECEBIMENTO)
        window.updateCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            const categoriaSelect = document.getElementById('itemCategoria');
            const btnManageCategoria = document.getElementById('manageCategoriaBtn');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                // Carregar medições da obra selecionada
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManageCategoria) {
                        btnManageCategoria.disabled = true;
                        btnManageCategoria.style.opacity = '0.5';
                        btnManageCategoria.style.pointerEvents = 'none';
                        btnManageCategoria.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        } else {
                            categoriaSelect.innerHTML = '<option value="">Nenhuma medição cadastrada</option>';
                        }
                    } catch (error) {
                        console.error('Erro ao carregar medições:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar medições</option>';
                    }
                } else {
                    categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                }
            } else if (tipo === 'OUTROS') {
                // Usar lista personalizada
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManageCategoria) {
                    btnManageCategoria.disabled = false;
                    btnManageCategoria.style.opacity = '1';
                    btnManageCategoria.style.pointerEvents = 'auto';
                    btnManageCategoria.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManageCategoria) {
                    btnManageCategoria.disabled = true;
                    btnManageCategoria.style.opacity = '0.5';
                    btnManageCategoria.style.pointerEvents = 'none';
                    btnManageCategoria.style.cursor = 'not-allowed';
                }
            }
        };
        
        // Funções para abrir modais de gerenciamento (RECEBIMENTO)
        window.openManageSubtiposRecModal = function() {
            const btn = document.getElementById('btn-manage-subtipo-rec');
            if (btn && btn.disabled) {
                console.log('⚠️ Botão de gerenciar subtipos está desabilitado');
                return; // Não abre modal se botão está desabilitado
            }
            openManageListModal('recebimento_outros_subtipos', 'Gerenciar Subtipos de Recebimento', function() {
                updateSubtipoForReceiving();
            });
        };
        
        window.openManageCategoriasRecModal = function() {
            const btn = document.getElementById('manageCategoriaBtn');
            if (btn && btn.disabled) {
                console.log('⚠️ Botão de gerenciar categorias está desabilitado');
                return; // Não abre modal se botão está desabilitado
            }
            openManageListModal('recebimento_outros_categorias', 'Gerenciar Categorias de Recebimento', function() {
                updateCategoriaForReceiving();
            });
        };


        // Função para atualizar SUBTIPO e CATEGORIA quando TIPO muda (PAGAMENTO - na edição)
        window.updateEditTipoForPayment = async function(index) {
            const tipoSelect = document.querySelector(`.edit-item-tipo[data-item-index="${index}"]`);
            const subtipoSelect = document.querySelector(`.edit-item-subtipo[data-item-index="${index}"]`);
            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${index}"]`);
            const btnManageCategoria = document.querySelector(`.btn-manage-categorias[data-item-index="${index}"]`);
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            
            // Salvar valores atuais
            const currentSubtipo = subtipoSelect.value;
            const currentCategoria = categoriaSelect.value;
            
            // Limpar selects
            subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            
            // Se TIPO = EXTERNO, adicionar OBRA
            if (tipo === 'EXTERNO') {
                subtipoSelect.innerHTML += '<option value="OBRA">OBRA</option>';
            }
            
            // Adicionar subtipos personalizados
            try {
                const customSubtipos = await loadListFromSupabase('hvc_subtipos_pagamento');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
                
                // Restaurar valor de subtipo se ainda existir
                if (currentSubtipo) {
                    subtipoSelect.value = currentSubtipo;
                }
            } catch (error) {
                console.error('Erro ao carregar subtipos:', error);
            }
            
            // Atualizar categoria baseado no subtipo atual
            if (currentSubtipo) {
                await updateCategoriaSelectInEdit(index, currentSubtipo);
                // Tentar restaurar o valor de categoria
                if (currentCategoria) {
                    categoriaSelect.value = currentCategoria;
                }
            }
        };

        // Função para atualizar select de categoria na edição
        window.updateCategoriaSelectInEdit = async function(itemIndex, subtipo) {
            const categoriaSelect = document.querySelector(`.edit-item-categoria[data-item-index="${itemIndex}"]`);
            const btnManage = document.querySelector(`.btn-manage-categorias[data-item-index="${itemIndex}"]`);
            
            if (!categoriaSelect) return;
            
            // Salvar valor atual
            const currentValue = categoriaSelect.value;
            
            if (subtipo === 'OBRA') {
                // Carregar obras do Supabase
                categoriaSelect.innerHTML = '<option value="">Carregando obras...</option>';
                btnManage.disabled = true;
                btnManage.style.opacity = '0.5';
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    categoriaSelect.innerHTML = '<option value="">Selecione uma obra...</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            categoriaSelect.innerHTML += `<option value="${obraName}">${obraName}</option>`;
                        });
                    } else {
                        categoriaSelect.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    }
                    
                    // Restaurar valor se existir
                    if (currentValue) {
                        categoriaSelect.value = currentValue;
                    }
                    
                } catch (error) {
                    console.error('Erro ao carregar obras:', error);
                    categoriaSelect.innerHTML = '<option value="">Erro ao carregar obras</option>';
                }
            } else {
                // Usar lista personalizada
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                btnManage.disabled = false;
                btnManage.style.opacity = '1';
                
                const customCategorias = await loadListFromSupabase('hvc_categorias_pagamento');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
                
                // Restaurar valor se existir
                if (currentValue) {
                    categoriaSelect.value = currentValue;
                }
            }
        };

        // Função para cancelar edição
        window.cancelEditingEventItems = function() {
            const editDiv = document.getElementById('payments-edit');
            if (editDiv) {
                editDiv.style.display = 'none';
                editDiv.innerHTML = '';
            }
            currentEditingEventData = null;
            currentEditingItemsData = [];
        };

        // Função para salvar alterações
        window.saveEventItemsChanges = async function(eventId, eventType) {
            try {
                console.log('💾 Iniciando salvamento das alterações...');
                
                if (!currentEditingEventData) {
                    throw new Error('Evento não encontrado para edição');
                }
                
                // Mostrar indicador de carregamento
                const saveBtn = document.querySelector('.btn-save-items');
                if (saveBtn) {
                    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> SALVANDO...';
                    saveBtn.disabled = true;
                }
                
                // Coletar dados editados
                const editDiv = document.getElementById('payments-edit');
                const editRows = editDiv.querySelectorAll('.edit-item-row');
                const updatedItems = [];
                
                editRows.forEach((row, itemIndex) => {
                    // Coletar todos os campos
                    const tipoInput = row.querySelector('.edit-item-tipo');
                    const subtipoInput = row.querySelector('.edit-item-subtipo');
                    const categoriaInput = row.querySelector('.edit-item-categoria');
                    
                    const tipo = tipoInput ? tipoInput.value.trim() : '';
                    const subtipo = subtipoInput ? subtipoInput.value.trim() : '';
                    const categoria = categoriaInput ? categoriaInput.value.trim() : '';
                    const nome = row.querySelector('.edit-item-name').value.trim();
                    const valueInput = row.querySelector('.edit-item-value').value;
                    const value = parseFloat(valueInput) || 0;
                    const status = row.querySelector('.edit-item-status').value;
                    const detail = row.querySelector('.edit-item-detail').value.trim();
                    
                    // Montar o nome completo com tipo, subtipo e categoria
                    // Lógica: Se pelo menos um campo (tipo, subtipo ou categoria) estiver preenchido,
                    // incluir todos os três (usando "Nenhum" para os vazios)
                    const nameParts = [];
                    const hasTipoSubtipoCategoria = tipo || subtipo || categoria;
                    
                    if (hasTipoSubtipoCategoria) {
                        nameParts.push(tipo || 'Nenhum');
                        nameParts.push(subtipo || 'Nenhum');
                        nameParts.push(categoria || 'Nenhum');
                    }
                    
                    nameParts.push(nome);
                    const fullName = nameParts.join(' - ');
                    
                    updatedItems.push({
                        name: fullName,
                        value: value,
                        status: status,
                        detail: detail,
                        formattedValue: formatCurrency(value),
                        originalIndex: itemIndex
                    });
                });
                
                console.log('✅ Dados coletados:', updatedItems);
                
                // Reconstruir descrição do evento
                const newDescription = rebuildEventDescription(currentEditingEventData.description, updatedItems, eventType);
                
                console.log('📝 Nova descrição:', newDescription);
                
                // Verificar se há contas múltiplas e usar o token correto
                let accountEmail = currentEditingEventData._accountEmail;
                if (accountEmail && window.connectedAccounts) {
                    const account = window.connectedAccounts.find(acc => acc.email === accountEmail);
                    if (account && account.accessToken) {
                        console.log('🔑 Usando token da conta:', accountEmail);
                        gapi.client.setToken({ access_token: account.accessToken });
                    }
                }
                
                // Atualizar evento no Google Calendar
                console.log('📤 Atualizando evento no Google Calendar...');
                const updateResponse = await gapi.client.calendar.events.patch({
                    calendarId: 'primary',
                    eventId: eventId,
                    resource: {
                        description: newDescription
                    }
                });
                
                console.log('✅ Evento atualizado:', updateResponse);
                
                // Mostrar mensagem de sucesso
                alert('Alterações salvas com sucesso!');
                
                // Recarregar eventos
                if (typeof loadFilteredEvents === 'function') {
                    await loadFilteredEvents();
                } else if (typeof loadEvents === 'function') {
                    await loadEvents();
                }
                
                // Fechar modal
                const modal = document.getElementById('eventModal');
                if (modal) {
                    modal.style.display = 'none';
                }
                
                console.log('✅ Processo de salvamento concluído!');
                
            } catch (error) {
                console.error('❌ Erro ao salvar alterações:', error);
                alert('Erro ao salvar alterações: ' + error.message);
                
                // Restaurar botão
                const saveBtn = document.querySelector('.btn-save-items');
                if (saveBtn) {
                    saveBtn.innerHTML = '<i class="fas fa-save"></i> SALVAR ALTERAÇÕES';
                    saveBtn.disabled = false;
                }
            }
        };

        // Função para reconstruir a descrição do evento - USANDO LÓGICA EXISTENTE
        window.rebuildEventDescription = function(originalDescription, updatedItems, eventType) {
            console.log('🔧 Reconstruindo descrição usando lógica existente...');
            console.log('📝 Descrição original:', originalDescription);
            console.log('📋 Itens atualizados:', updatedItems);
            
            // Usar a mesma lógica da função generateEventDescription existente
            const newDescription = updatedItems.map(item => {
                const parts = [];
                
                // Formato: [tipo] - [subtipo] - [categoria] - [nome] - [valor] ([status]) - [detalhe]
                // Como não temos tipo/subtipo/categoria nos itens editados, usar apenas nome
                parts.push(item.name);
                
                // Formatar valor com status (usando formatCurrency existente)
                let valorFormatado = formatCurrency(item.value);
                if (item.status) {
                    valorFormatado += ` (${item.status})`;
                }
                parts.push(valorFormatado);
                
                // Adicionar detalhe se existir
                if (item.detail && item.detail.trim() !== '') {
                    parts.push(item.detail.trim());
                }
                
                const itemString = parts.join(' - ');
                console.log(`  ✅ Item construído: "${itemString}"`);
                return itemString;
            }).join('\n');
            
            console.log('📝 Nova descrição completa:', newDescription);
            return newDescription;
        };

        // Verificar se as funções foram declaradas corretamente
        console.log('✅ Função startEditingEventItems declarada:', typeof window.startEditingEventItems);
        console.log('✅ Função saveEventItemsChanges declarada:', typeof window.saveEventItemsChanges);
        console.log('✅ Função rebuildEventDescription declarada:', typeof window.rebuildEventDescription);

        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA na edição do modal
        window.renderEditFieldsBasedOnEventType = function(eventType, itemData) {
            const tipoInput = document.querySelector('#editItemForm input[placeholder*="Tipo"]')?.closest('.form-group');
            const subtipoInput = document.querySelector('#editItemForm input[placeholder*="Subtipo"]')?.closest('.form-group');
            const categoriaInput = document.querySelector('#editItemForm input[placeholder*="Categoria"]')?.closest('.form-group');
            
            if (!tipoInput || !subtipoInput || !categoriaInput) return;
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: mesma lógica atual
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control">
                        <option value="">Nenhum</option>
                        <option value="INTERNO" ${itemData.tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                        <option value="EXTERNO" ${itemData.tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" onclick="openManageListModal(\'subtipos\'); setTimeout(() => populateEditSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria" onclick="openManageListModal(\'categorias\'); setTimeout(() => updateEditCategoriaBasedOnSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    populateEditSubtipo();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaBasedOnSubtipo();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: nova lógica
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control" onchange="updateEditSubtipoForReceiving()">
                        <option value="">Nenhum</option>
                        <option value="OBRAS" ${itemData.tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                        <option value="OUTROS" ${itemData.tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-subtipo-rec" onclick="openManageSubtiposRecModal(); setTimeout(() => updateEditSubtipoForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria-rec" onclick="openManageCategoriasRecModal(); setTimeout(() => updateEditCategoriaForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    updateEditSubtipoForReceiving();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaForReceiving();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
            }
        };
        
        // Funções auxiliares para edição (RECEBIMENTO)
        window.updateEditSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const btnManage = document.getElementById('btn-manage-edit-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obra.id}">${obraName}</option>`;
                        });
                    }
                } catch (error) {
                    console.error('Erro:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                }
            } else if (tipo === 'OUTROS') {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('edit-categoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        window.updateEditCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            const btnManage = document.getElementById('btn-manage-edit-categoria-rec');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManage) {
                        btnManage.disabled = true;
                        btnManage.style.opacity = '0.5';
                        btnManage.style.pointerEvents = 'none';
                        btnManage.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        }
                    } catch (error) {
                        console.error('Erro:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    }
                }
            } else if (tipo === 'OUTROS') {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
            }
        };


        // ===================================================================
        // INTEGRAÇÃO COM SISTEMA DE MEDIÇÕES
        // ===================================================================
        
        // Variável global para armazenar obra selecionada
        window.obraIdSelecionadaFluxoCaixa = null;
        
        // Função para verificar se deve mostrar botão Nova Medição
        function checkAndShowNovaMedicaoButton(listType) {
            const novaMedicaoSection = document.getElementById('novaMedicaoSection');
            
            if (!novaMedicaoSection) return;
            
            // Verificar condições:
            // 1. Tipo de evento = RECEBIMENTO
            // 2. TIPO = OBRAS
            // 3. SUBTIPO = uma obra selecionada
            // 4. listType = 'recebimento_outros_categorias' (gerenciando categorias de recebimento)
            
            const eventTypeRadio = document.querySelector('input[name="eventType"]:checked');
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            const isRecebimento = eventTypeRadio && eventTypeRadio.value === 'RECEBIMENTO';
            const isTipoObras = tipoSelect && tipoSelect.value === 'OBRAS';
            const obraSelecionada = subtipoSelect && subtipoSelect.value !== '';
            const isCategoriasRec = listType === 'recebimento_outros_categorias';
            
            // Mostrar botão apenas se todas as condições forem atendidas
            if (isRecebimento && isTipoObras && obraSelecionada && isCategoriasRec) {
                novaMedicaoSection.style.display = 'block';
                
                // Armazenar obra_id para uso posterior
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                window.obraIdSelecionadaFluxoCaixa = selectedOption.getAttribute('data-obra-id');
                
                console.log('✅ Botão Nova Medição habilitado para obra:', window.obraIdSelecionadaFluxoCaixa);
            } else {
                novaMedicaoSection.style.display = 'none';
                window.obraIdSelecionadaFluxoCaixa = null;
            }
        }
        
        
        // ===================================================================
        
        // Variáveis globais para medições
        window.obraSelecionadaMedicaoInline = null;
        window.obraIdMedicaoInline = null;
        
        // Função para abrir modal de Nova Medição do fluxo de caixa
        async function abrirNovaMedicaoDoFluxoCaixa() {
            console.log('🚀 Abrindo modal de Nova Medição inline...');
            
            // Fechar modal de gerenciar listas
            closeManageListModal();
            
            // Abrir modal inline
            await abrirModalMedicaoInline();
        }
        
        // Abrir modal de medição inline
        async function abrirModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (!modal) return;
            
            // Limpar formulário
            document.getElementById('data-medicao-inline').value = new Date().toISOString().split('T')[0];
            
            const dataFutura = new Date();
            dataFutura.setDate(dataFutura.getDate() + 30);
            document.getElementById('data-recebimento-inline').value = dataFutura.toISOString().split('T')[0];
            
            document.getElementById('valor-medicao-inline').value = '';
            document.getElementById('status-medicao-inline').value = 'pendente';
            document.getElementById('observacoes-medicao-inline').value = '';
            
            // Resetar obra selecionada
            window.obraSelecionadaMedicaoInline = null;
            window.obraIdMedicaoInline = window.obraIdSelecionadaFluxoCaixa;
            
            // Se já tem obra selecionada do fluxo de caixa, pré-selecionar
            if (window.obraIdSelecionadaFluxoCaixa) {
                await preSelecionarObraNoModal(window.obraIdSelecionadaFluxoCaixa);
            } else {
                const container = document.getElementById('obra-selecionada-container-inline');
                if (container) {
                    container.innerHTML = `
                        <button type="button" class="btn-secondary" onclick="abrirModalObrasInline()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-building"></i>
                            Selecionar Obra
                        </button>
                    `;
                }
            }
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Pré-selecionar obra no modal
        async function preSelecionarObraNoModal(obraId) {
            try {
                const { data: obra, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .eq('id', obraId)
                    .single();
                
                if (error) throw error;
                
                if (obra) {
                    window.obraSelecionadaMedicaoInline = obra;
                    window.obraIdMedicaoInline = obra.id;
                    
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    const container = document.getElementById('obra-selecionada-container-inline');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #4CAF50;">${obraName}</strong>
                                </div>
                                <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                                    Trocar
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Erro ao pré-selecionar obra:', error);
            }
        }
        
        // Fechar modal de medição
        function fecharModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Abrir modal de obras
        async function abrirModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (!modal) return;
            
            // Carregar obras
            await carregarObrasParaModal();
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Fechar modal de obras
        function fecharModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Carregar obras para o modal
        async function carregarObrasParaModal() {
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('obras-list-inline');
                if (!container) return;
                
                if (obras && obras.length > 0) {
                    container.innerHTML = obras.map(obra => {
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        return `
                            <div class="obras-list-item" onclick="selecionarObraInline(${obra.id}, '${obraName}')" style="padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                                <strong style="color: #fff;">${obraName}</strong>
                            </div>
                        `;
                    }).join('');
                } else {
                    container.innerHTML = '<p style="text-align: center; color: #b0c4de;">Nenhuma obra cadastrada</p>';
                }
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
            }
        }
        
        // Selecionar obra
        function selecionarObraInline(obraId, obraName) {
            window.obraIdMedicaoInline = obraId;
            
            const container = document.getElementById('obra-selecionada-container-inline');
            if (container) {
                container.innerHTML = `
                    <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #4CAF50;">${obraName}</strong>
                        </div>
                        <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                            Trocar
                        </button>
                    </div>
                `;
            }
            
            // Fechar modal de obras
            fecharModalObrasInline();
        }
        
        // Salvar medição
        async function salvarMedicaoInline(event) {
            event.preventDefault();
            
            const dataMedicao = document.getElementById('data-medicao-inline').value;
            const dataRecebimento = document.getElementById('data-recebimento-inline').value;
            const valor = parseFloat(document.getElementById('valor-medicao-inline').value);
            const status = document.getElementById('status-medicao-inline').value;
            const observacoes = document.getElementById('observacoes-medicao-inline').value;
            const obraId = window.obraIdMedicaoInline;
            
            if (!obraId) {
                alert('Por favor, selecione uma obra');
                return;
            }
            
            try {
                // Gerar número da medição
                const { data: ultimaMedicao } = await supabase
                    .from('medicoes_hvc')
                    .select('numero')
                    .order('numero', { ascending: false })
                    .limit(1)
                    .single();
                
                const proximoNumero = ultimaMedicao ? parseInt(ultimaMedicao.numero.replace('MED-', '')) + 1 : 1;
                const numeroMedicao = `MED-${String(proximoNumero).padStart(3, '0')}`;
                
                // Salvar no Supabase
                const { data, error } = await supabase
                    .from('medicoes_hvc')
                    .insert([{
                        numero: numeroMedicao,
                        obra_id: obraId,
                        data_medicao: dataMedicao,
                        data_recebimento: dataRecebimento,
                        valor: valor,
                        status: status,
                        observacoes: observacoes
                    }])
                    .select();
                
                if (error) throw error;
                
                alert('Medição criada com sucesso!');
                fecharModalMedicaoInline();
                
                // Atualizar lista de categorias
                if (typeof updateCategoriaForReceiving === 'function') {
                    await updateCategoriaForReceiving();
                }
                
            } catch (error) {
                console.error('Erro ao salvar medição:', error);
                alert('Erro ao salvar medição: ' + error.message);
            }
        }
        
    </script>
</head>

<body>
    <div id="main-content-fluxo-caixa-hvc">
        <!-- Messages Container -->
        <div id="messagesContainer"></div>

        <!-- Header -->
        <div class="hvc-container">
            <h1 class="hvc-title">
                <i class="fas fa-chart-line"></i>
                Fluxo de Caixa HVC - Agenda e Pagamentos
            </h1>
        </div>

        <!-- ✅ NOVO: Seção de Gerenciamento de Contas Google -->
        <div class="accounts-section">
            <h2><i class="fab fa-google"></i> Contas Google Calendar</h2>
            
            <div id="accountsList" class="accounts-list">
                <!-- A lista de contas será renderizada aqui -->
            </div>

            <div class="add-account-section">
                <button id="addAccountButton" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Adicionar Nova Conta
                </button>
                 <button id="syncAllButton" class="btn btn-secondary" disabled>
                    <i class="fas fa-sync-alt"></i> Sincronizar Todas as Contas
                </button>
                <!-- ✅ NOVO: Botão para criar eventos -->
                <button id="createEventButton" onclick="toggleEventCreator()" class="btn btn-success" style="display: none;">
                    <i class="fas fa-plus-circle"></i> Criar Evento
                </button>
            </div>
        </div>

        <!-- ✅ NOVO: Seção de Criação de Eventos -->
        <div id="eventCreatorSection" class="event-creator-section" style="display: none;">
            <h3><i class="fas fa-plus-circle"></i> Criar Evento</h3>
            
            <!-- ✅ NOVO: Seleção Obrigatória de Tipo -->
            <div class="event-type-selector">
                <h4><i class="fas fa-tags"></i> Tipo de Evento *</h4>
                <div class="type-options">
                    <label class="type-option">
                        <input type="radio" name="eventType" value="PAGAMENTO" id="typePagamento" required>
                        <span class="type-label pagamento-type">
                            <i class="fas fa-credit-card"></i>
                            PAGAMENTO
                        </span>
                    </label>
                    <label class="type-option">
                        <input type="radio" name="eventType" value="RECEBIMENTO" id="typeRecebimento" required>
                        <span class="type-label recebimento-type">
                            <i class="fas fa-hand-holding-usd"></i>
                            RECEBIMENTO
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- Lista de Itens -->
            <div class="payment-items-container">
                <h4><i class="fas fa-list"></i> <span id="itemsTitle">Itens</span></h4>
                
                <!-- Formulário para Adicionar Item -->
                <div class="add-item-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tipo</label>
                            <select id="itemTipo">
                                <option value="">Nenhum</option>
                                <option value="INTERNO">INTERNO</option>
                                <option value="EXTERNO">EXTERNO</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Subtipo</label>
                            <div class="select-with-manage">
                                <select id="itemSubtipo">
                                    <option value="">Nenhum</option>
                                    <option value="OBRA">OBRA</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageSubtiposPayment()" title="Gerenciar lista">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Categoria</label>
                            <div class="select-with-manage">
                                <select id="itemCategoria">
                                    <option value="">Nenhum</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageCategoriasPayment()" title="Gerenciar lista" id="manageCategoriaBtn">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Nome do Item *</label>
                            <input type="text" id="itemNome" placeholder="Nome do item (obrigatório)" required>
                        </div>
                        <div class="form-group">
                            <label>Valor *</label>
                            <input type="text" id="itemValor" placeholder="R$ 0,00" required>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="itemStatus">
                                <option value="">Selecione o tipo primeiro...</option>
                                <!-- Opções serão atualizadas dinamicamente -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group full-width">
                            <label>Detalhe</label>
                            <input type="text" id="itemDetalhe" placeholder="Detalhes adicionais...">
                        </div>
                    </div>
                    
                    <button type="button" id="addItemBtn" class="add-item-btn">
                        <i class="fas fa-plus"></i> Adicionar Item
                    </button>
                </div>
                
                <!-- Lista de Itens Adicionados -->
                <div id="itemsList" class="items-list">
                    <!-- Itens serão listados aqui -->
                </div>
            </div>
            
            <!-- Formulário para Criar Evento -->
            <div class="create-event-form" style="display: none;" id="createEventForm">
                <h4><i class="fas fa-calendar-plus"></i> Criar Evento no Google Calendar</h4>
                
                <!-- ✅ NOVO: Seletor de conta para criar evento -->
                <div class="form-group">
                    <label>Conta Google *</label>
                    <select id="eventAccount" required>
                        <option value="">Selecione uma conta...</option>
                        <!-- As opções serão preenchidas dinamicamente -->
                    </select>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Data *</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label>Horário</label>
                        <input type="time" id="eventTime" value="09:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Recorrência *</label>
                    <select id="eventRecurrence" required>
                        <option value="NONE">Não se repete</option>
                        <option value="DAILY">Todos os dias</option>
                        <option value="WEEKLY">Semanal: cada quinta-feira</option>
                        <option value="MONTHLY">Mensal no(a) terceiro(a) quinta-feira</option>
                        <option value="YEARLY">Anual em setembro 18</option>
                        <option value="WEEKDAYS">Todos os dias da semana (segunda a sexta-feira)</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="refreshAccountsBtn" class="btn btn-secondary" style="margin-right: auto;">
                        <i class="fas fa-refresh"></i> Atualizar Contas
                    </button>
                    <button type="button" id="createEventBtn" class="create-event-btn">
                        <i class="fas fa-calendar-check"></i> Criar Evento
                    </button>
                    <button type="button" id="cancelEventBtn" class="cancel-event-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>

        <!-- Filter Information -->
        <div id="filterSection" class="filter-section" style="display: none;">
            <div class="filter-info">
                <i class="fas fa-filter"></i>
                <span>Filtro Ativo: Eventos com palavras-chave relacionadas a pagamentos</span>
            </div>
            <div class="filter-stats" id="filterStats">
                <!-- Stats will be populated here -->
            </div>
        </div>

        <!-- ✅ NOVO: Seção de Criação de Eventos -->
        <div id="eventCreatorSection" class="event-creator-section" style="display: none;">
            <h3><i class="fas fa-plus-circle"></i> Criar Evento</h3>
            
            <!-- ✅ NOVO: Seleção Obrigatória de Tipo -->
            <div class="event-type-selector">
                <h4><i class="fas fa-tags"></i> Tipo de Evento *</h4>
                <div class="type-options">
                    <label class="type-option">
                        <input type="radio" name="eventType" value="PAGAMENTO" id="typePagamento" required>
                        <span class="type-label pagamento-type">
                            <i class="fas fa-credit-card"></i>
                            PAGAMENTO
                        </span>
                    </label>
                    <label class="type-option">
                        <input type="radio" name="eventType" value="RECEBIMENTO" id="typeRecebimento" required>
                        <span class="type-label recebimento-type">
                            <i class="fas fa-hand-holding-usd"></i>
                            RECEBIMENTO
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- Lista de Itens -->
            <div class="payment-items-container">
                <h4><i class="fas fa-list"></i> <span id="itemsTitle">Itens</span></h4>
                
                <!-- Formulário para Adicionar Item -->
                <div class="add-item-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tipo</label>
                            <select id="itemTipo">
                                <option value="">Nenhum</option>
                                <option value="INTERNO">INTERNO</option>
                                <option value="EXTERNO">EXTERNO</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Subtipo</label>
                            <div class="select-with-manage">
                                <select id="itemSubtipo">
                                    <option value="">Nenhum</option>
                                    <option value="OBRA">OBRA</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageSubtiposPayment()" title="Gerenciar lista">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Categoria</label>
                            <div class="select-with-manage">
                                <select id="itemCategoria">
                                    <option value="">Nenhum</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageCategoriasPayment()" title="Gerenciar lista" id="manageCategoriaBtn">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Nome do Item *</label>
                            <input type="text" id="itemNome" placeholder="Nome do item (obrigatório)" required>
                        </div>
                        <div class="form-group">
                            <label>Valor *</label>
                            <input type="text" id="itemValor" placeholder="R$ 0,00" required>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="itemStatus">
                                <option value="">Selecione o tipo primeiro...</option>
                                <!-- Opções serão atualizadas dinamicamente -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group full-width">
                            <label>Detalhe</label>
                            <input type="text" id="itemDetalhe" placeholder="Detalhes adicionais...">
                        </div>
                    </div>
                    
                    <button type="button" id="addItemBtn" class="add-item-btn">
                        <i class="fas fa-plus"></i> Adicionar Item
                    </button>
                </div>
                
                <!-- Lista de Itens Adicionados -->
                <div id="itemsList" class="items-list">
                    <!-- Itens serão listados aqui -->
                </div>
            </div>
            
            <!-- Formulário para Criar Evento -->
            <div class="create-event-form" style="display: none;" id="createEventForm">
                <h4><i class="fas fa-calendar-plus"></i> Criar Evento no Google Calendar</h4>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Data *</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label>Horário</label>
                        <input type="time" id="eventTime" value="09:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Recorrência *</label>
                    <select id="eventRecurrence" required onchange="handleRecurrenceChange()">
                        <option value="NONE">Não se repete</option>
                        <option value="DAILY">Todos os dias</option>
                        <option value="WEEKLY">Semanal: cada quinta-feira</option>
                        <option value="MONTHLY">Mensal no(a) terceiro(a) quinta-feira</option>
                        <option value="YEARLY">Anual em setembro 18</option>
                        <option value="WEEKDAYS">Todos os dias da semana (segunda a sexta-feira)</option>
                        <option value="CUSTOM">Personalizar...</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="refreshAccountsBtn" class="btn btn-secondary" style="margin-right: auto;">
                        <i class="fas fa-refresh"></i> Atualizar Contas
                    </button>
                    <button type="button" id="createEventBtn" class="create-event-btn">
                        <i class="fas fa-calendar-check"></i> Criar Evento
                    </button>
                    <button type="button" id="cancelEventBtn" class="cancel-event-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>

        <!-- Calendar View -->
        <div id="calendarSection" class="calendar-section" style="display: none;">
            <div class="calendar-header">
                <div class="calendar-nav">
                    <button onclick="previousMonth()">
                        <i class="fas fa-chevron-left"></i> Anterior
                    </button>
                    <button onclick="goToToday()">
                        <i class="fas fa-calendar-day"></i> Hoje
                    </button>
                    <button onclick="nextMonth()">
                        Próximo <i class="fas fa-chevron-right"></i>
                    </button>
                    
                    <!-- ✅ NOVO: Campo de Saldo da Conta Corrente -->
                    <div class="account-balance-input">
                        <label for="accountBalance">Saldo Conta:</label>
                        <input type="text" id="accountBalance" placeholder="R$ 0,00" 
                               onchange="updateAccountBalance()" onkeyup="formatCurrencyInput(this)">
                    </div>
                </div>
                <h3 id="calendarTitle" class="calendar-title">Carregando...</h3>
            </div>
            
            <div id="calendarGrid" class="calendar-grid">
                <!-- Calendar will be rendered here -->
            </div>
        </div>

        <!-- ✅ NOVO: Resumos Mensais - Pagamentos e Recebimentos -->
        <div id="monthlySummarySection" class="monthly-summary-container" style="display: none;">
            <!-- Resumo Geral -->
            <div class="monthly-summary-general">
                <h3><i class="fas fa-chart-pie"></i> Resumo Geral do Mês</h3>
            </div>

            <!-- ✅ NOVO: Análise de Saldo -->
            <div class="balance-analysis">
                <h3><i class="fas fa-balance-scale"></i> Análise de Saldo</h3>
                <div class="balance-stats">
                    <div class="balance-item positive">
                        <div class="balance-header">
                            <i class="fas fa-arrow-up"></i>
                            <span>Recebido vs Pago</span>
                        </div>
                        <div class="balance-values">
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">RC:</span>
                                    <span id="balanceRC" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balanceRCDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">PG:</span>
                                    <span id="balancePG" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balancePGDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-result">
                                <span class="balance-label">Saldo:</span>
                                <span id="balanceRCPG" class="balance-final">R$ 0,00</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="balance-item pending">
                        <div class="balance-header">
                            <i class="fas fa-clock"></i>
                            <span>Aguardando vs Pendente</span>
                        </div>
                        <div class="balance-values">
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">AGUARDANDO:</span>
                                    <span id="balanceAguardando" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balanceAguardandoDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">PENDENTE:</span>
                                    <span id="balancePendente" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balancePendenteDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-result">
                                <span class="balance-label">Saldo:</span>
                                <span id="balanceAguardandoPendente" class="balance-final">R$ 0,00</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="balance-item overdue">
                        <div class="balance-header">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span>Em Atraso</span>
                        </div>
                        <div class="balance-values">
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">REC. ATRASO:</span>
                                    <span id="balanceAguardandoAtraso" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balanceAguardandoAtrasoDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-value">
                                <div class="balance-value-row">
                                    <span class="balance-label">PAG. ATRASO:</span>
                                    <span id="balancePendenteAtraso" class="balance-amount">R$ 0,00</span>
                                </div>
                                <div id="balancePendenteAtrasoDaily" class="balance-daily">R$ 0,00/dia</div>
                            </div>
                            <div class="balance-result">
                                <span class="balance-label">Saldo:</span>
                                <span id="balanceAtraso" class="balance-final">R$ 0,00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Resumos Lado a Lado -->
            <div class="summaries-row">
                <!-- Resumo de Pagamentos -->
                <div class="monthly-summary payments-summary">
                    <h4><i class="fas fa-credit-card"></i> Pagamentos</h4>
                    <div id="paymentTotal" class="section-total">R$ 0,00</div>
                    
                    <div class="status-stats">
                        <div class="status-stat-item pg">
                            <div class="status-stat-header">
                                <div id="totalPG" class="status-stat-count">0 itens</div>
                                <div id="amountPG" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgPGDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">PG</div>
                        </div>
                        <div class="status-stat-item pendente">
                            <div class="status-stat-header">
                                <div id="totalPendente" class="status-stat-count">0 itens</div>
                                <div id="amountPendente" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgPendenteDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Pendente</div>
                        </div>
                        <div class="status-stat-item recalculado">
                            <div class="status-stat-header">
                                <div id="totalRecalculado" class="status-stat-count">0 itens</div>
                                <div id="amountRecalculado" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgRecalculadoDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Recalculado</div>
                        </div>
                        <div class="status-stat-item pendente-atraso">
                            <div class="status-stat-header">
                                <div id="totalPendenteAtraso" class="status-stat-count">0 itens</div>
                                <div id="amountPendenteAtraso" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgPendenteAtrasoDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Em Atraso</div>
                        </div>
                    </div>
                </div>

                <!-- Resumo de Recebimentos -->
                <div class="monthly-summary receivings-summary">
                    <h4><i class="fas fa-hand-holding-usd"></i> Recebimentos</h4>
                    <div id="receivingTotal" class="section-total">R$ 0,00</div>
                    
                    <div class="status-stats">
                        <div class="status-stat-item rc">
                            <div class="status-stat-header">
                                <div id="totalRC" class="status-stat-count">0 itens</div>
                                <div id="amountRC" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgRCDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">RC</div>
                        </div>
                        <div class="status-stat-item aguardando">
                            <div class="status-stat-header">
                                <div id="totalAguardando" class="status-stat-count">0 itens</div>
                                <div id="amountAguardando" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgAguardandoDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Aguardando</div>
                        </div>
                        <div class="status-stat-item adiado">
                            <div class="status-stat-header">
                                <div id="totalAdiado" class="status-stat-count">0 itens</div>
                                <div id="amountAdiado" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgAdiadoDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Adiado</div>
                        </div>
                        <div class="status-stat-item aguardando-atraso">
                            <div class="status-stat-header">
                                <div id="totalAguardandoAtraso" class="status-stat-count">0 itens</div>
                                <div id="amountAguardandoAtraso" class="status-stat-amount">R$ 0,00</div>
                            </div>
                            <div id="avgAguardandoAtrasoDaily" class="status-stat-daily">R$ 0,00/dia</div>
                            <div class="status-stat-label">Em Atraso</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ✅ NOVO: Criador de Eventos de Pagamento -->
        <div id="eventCreatorSection" class="event-creator-section" style="display: none;">
            <h3><i class="fas fa-plus-circle"></i> Criar Evento</h3>
            
            <!-- ✅ NOVO: Seleção Obrigatória de Tipo -->
            <div class="event-type-selector">
                <h4><i class="fas fa-tags"></i> Tipo de Evento *</h4>
                <div class="type-options">
                    <label class="type-option">
                        <input type="radio" name="eventType" value="PAGAMENTO" id="typePagamento" required>
                        <span class="type-label pagamento-type">
                            <i class="fas fa-credit-card"></i>
                            PAGAMENTO
                        </span>
                    </label>
                    <label class="type-option">
                        <input type="radio" name="eventType" value="RECEBIMENTO" id="typeRecebimento" required>
                        <span class="type-label recebimento-type">
                            <i class="fas fa-hand-holding-usd"></i>
                            RECEBIMENTO
                        </span>
                    </label>
                </div>
            </div>
            
            <!-- Lista de Itens -->
            <div class="payment-items-container">
                <h4><i class="fas fa-list"></i> <span id="itemsTitle">Itens</span></h4>
                
                <!-- Formulário para Adicionar Item -->
                <div class="add-item-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tipo</label>
                            <select id="itemTipo">
                                <option value="">Nenhum</option>
                                <option value="INTERNO">INTERNO</option>
                                <option value="EXTERNO">EXTERNO</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Subtipo</label>
                            <div class="select-with-manage">
                                <select id="itemSubtipo">
                                    <option value="">Nenhum</option>
                                    <option value="OBRA">OBRA</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageSubtiposPayment()" title="Gerenciar lista">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Categoria</label>
                            <div class="select-with-manage">
                                <select id="itemCategoria">
                                    <option value="">Nenhum</option>
                                </select>
                                <button type="button" class="manage-list-btn" onclick="openManageCategoriasPayment()" title="Gerenciar lista" id="manageCategoriaBtn">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Nome do Item *</label>
                            <input type="text" id="itemNome" placeholder="Nome do item (obrigatório)" required>
                        </div>
                        <div class="form-group">
                            <label>Valor *</label>
                            <input type="text" id="itemValor" placeholder="R$ 0,00" required>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="itemStatus">
                                <option value="">Selecione o tipo primeiro...</option>
                                <!-- Opções serão atualizadas dinamicamente -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group full-width">
                            <label>Detalhe</label>
                            <input type="text" id="itemDetalhe" placeholder="Detalhes adicionais...">
                        </div>
                    </div>
                    
                    <button type="button" id="addItemBtn" class="add-item-btn">
                        <i class="fas fa-plus"></i> Adicionar Item
                    </button>
                </div>
                
                <!-- Lista de Itens Adicionados -->
                <div id="itemsList" class="items-list">
                    <!-- Itens serão listados aqui -->
                </div>
            </div>
            
            <!-- Formulário para Criar Evento -->
            <div class="create-event-form" style="display: none;" id="createEventForm">
                <h4><i class="fas fa-calendar-plus"></i> Criar Evento no Google Calendar</h4>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Data *</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label>Horário</label>
                        <input type="time" id="eventTime" value="09:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Recorrência *</label>
                    <select id="eventRecurrence" required onchange="handleRecurrenceChange()">
                        <option value="NONE">Não se repete</option>
                        <option value="DAILY">Todos os dias</option>
                        <option value="WEEKLY">Semanal: cada quinta-feira</option>
                        <option value="MONTHLY">Mensal no(a) terceiro(a) quinta-feira</option>
                        <option value="YEARLY">Anual em setembro 18</option>
                        <option value="WEEKDAYS">Todos os dias da semana (segunda a sexta-feira)</option>
                        <option value="CUSTOM">Personalizar...</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="refreshAccountsBtn" class="btn btn-secondary" style="margin-right: auto;">
                        <i class="fas fa-refresh"></i> Atualizar Contas
                    </button>
                    <button type="button" id="createEventBtn" class="create-event-btn">
                        <i class="fas fa-calendar-check"></i> Criar Evento
                    </button>
                    <button type="button" id="cancelEventBtn" class="cancel-event-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>

        <!-- ✅ NOVO: Listas de Pagamentos e Recebimentos -->
        <div id="listsSection" class="lists-container" style="display: none;">
            <div class="lists-row">
                <!-- Lista de Pagamentos -->
                <div id="paymentsListSection" class="payments-list-section">
                    <h3><i class="fas fa-credit-card"></i> Lista de Pagamentos do Mês</h3>
                    
                    <!-- Filtros de Pagamentos -->
                    <div class="payments-filters">
                        <div class="filter-group">
                            <label class="filter-label">Nome do Pagamento</label>
                            <input type="text" id="nameFilter" class="filter-input" placeholder="Buscar por nome...">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Data</label>
                            <input type="date" id="dateFilter" class="filter-input">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Status</label>
                            <select id="statusFilter" class="filter-select">
                                <option value="">Todos os status</option>
                                <option value="PG">PG</option>
                                <option value="PENDENTE">Pendente</option>
                                <option value="RECALCULADO">Recalculado</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <button id="clearFilters" class="clear-filters-btn">
                                <i class="fas fa-times"></i> Limpar Filtros
                            </button>
                        </div>
                    </div>
                    
                    <div id="paymentsList" class="payments-list">
                        <!-- Pagamentos serão listados aqui -->
                    </div>
                </div>

                <!-- Lista de Recebimentos -->
                <div id="receivingsListSection" class="receivings-list-section">
                    <h3><i class="fas fa-hand-holding-usd"></i> Lista de Recebimentos do Mês</h3>
                    
                    <!-- Filtros de Recebimentos -->
                    <div class="receivings-filters">
                        <div class="filter-group">
                            <label class="filter-label">Nome do Recebimento</label>
                            <input type="text" id="receivingNameFilter" class="filter-input" placeholder="Buscar por nome...">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Data</label>
                            <input type="date" id="receivingDateFilter" class="filter-input">
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Status</label>
                            <select id="receivingStatusFilter" class="filter-select">
                                <option value="">Todos os status</option>
                                <option value="RC">RC</option>
                                <option value="AGUARDANDO">Aguardando</option>
                                <option value="ADIADO">Adiado</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <button id="clearReceivingFilters" class="clear-filters-btn">
                                <i class="fas fa-times"></i> Limpar Filtros
                            </button>
                        </div>
                    </div>
                    
                    <div id="receivingsList" class="receivings-list">
                        <!-- Recebimentos serão listados aqui -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Details Modal -->
    <div id="eventModal" class="event-modal">
        <div class="event-modal-content">
            <div class="modal-header">
                <h2 id="eventModalTitle">Detalhes do Evento</h2>
                <span class="close" onclick="closeEventModal()">&times;</span>
            </div>
            <div class="modal-body" id="eventModalBody">
                <!-- Event details will be populated here -->
            </div>
        </div>
    </div>

    <!-- Custom Recurrence Modal -->
    <div id="customRecurrenceModal" class="custom-recurrence-modal">
        <div class="custom-recurrence-modal-content">
            <h3>Recorrência personalizada</h3>
            
            <div class="recurrence-form-group">
                <div class="recurrence-form-row">
                    <span>Repetir a cada:</span>
                    <input type="number" id="recurrenceInterval" class="recurrence-input" value="1" min="1" max="999">
                    <select id="recurrenceUnit" class="recurrence-select">
                        <option value="day">dia</option>
                        <option value="week" selected>semana</option>
                        <option value="month">mês</option>
                        <option value="year">ano</option>
                    </select>
                </div>
            </div>

            <div class="recurrence-form-group" id="weekdaysGroup" style="display: block;">
                <label>Repetir:</label>
                <div class="weekdays-selector">
                    <button type="button" class="weekday-btn" data-day="0">D</button>
                    <button type="button" class="weekday-btn" data-day="1">S</button>
                    <button type="button" class="weekday-btn" data-day="2">T</button>
                    <button type="button" class="weekday-btn" data-day="3">Q</button>
                    <button type="button" class="weekday-btn" data-day="4" id="defaultWeekday">Q</button>
                    <button type="button" class="weekday-btn" data-day="5">S</button>
                    <button type="button" class="weekday-btn" data-day="6">S</button>
                </div>
            </div>

            <div class="recurrence-form-group">
                <label>Termina em</label>
                <div class="end-options">
                    <div class="end-option">
                        <input type="radio" id="endNever" name="endType" value="never" checked>
                        <label for="endNever">Nunca</label>
                    </div>
                    <div class="end-option">
                        <input type="radio" id="endDate" name="endType" value="date">
                        <label for="endDate">
                            Em
                            <input type="date" id="endDateValue" class="end-date-input" disabled>
                        </label>
                    </div>
                    <div class="end-option">
                        <input type="radio" id="endCount" name="endType" value="count">
                        <label for="endCount">
                            Após
                            <input type="number" id="endCountValue" class="end-count-input" value="10" min="1" max="999" disabled>
                            ocorrências
                        </label>
                    </div>
                </div>
            </div>

            <div class="custom-recurrence-actions">
                <button type="button" class="custom-recurrence-btn custom-recurrence-cancel" onclick="closeCustomRecurrenceModal()">
                    Cancelar
                </button>
                <button type="button" class="custom-recurrence-btn custom-recurrence-confirm" onclick="confirmCustomRecurrence()">
                    Concluir
                </button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script type="module" src="supabase.js"></script>
    <script type="module" src="dashboard-hvc.js"></script>
    <script src="multi_account_manager.js"></script>
    <script type="module">
        import { injectSidebar } from './sidebar.js';
        injectSidebar("main-content-fluxo-caixa-hvc");

        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA na edição do modal
        window.renderEditFieldsBasedOnEventType = function(eventType, itemData) {
            const tipoInput = document.querySelector('#editItemForm input[placeholder*="Tipo"]')?.closest('.form-group');
            const subtipoInput = document.querySelector('#editItemForm input[placeholder*="Subtipo"]')?.closest('.form-group');
            const categoriaInput = document.querySelector('#editItemForm input[placeholder*="Categoria"]')?.closest('.form-group');
            
            if (!tipoInput || !subtipoInput || !categoriaInput) return;
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: mesma lógica atual
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control">
                        <option value="">Nenhum</option>
                        <option value="INTERNO" ${itemData.tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                        <option value="EXTERNO" ${itemData.tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" onclick="openManageListModal(\'subtipos\'); setTimeout(() => populateEditSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria" onclick="openManageListModal(\'categorias\'); setTimeout(() => updateEditCategoriaBasedOnSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    populateEditSubtipo();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaBasedOnSubtipo();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: nova lógica
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control" onchange="updateEditSubtipoForReceiving()">
                        <option value="">Nenhum</option>
                        <option value="OBRAS" ${itemData.tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                        <option value="OUTROS" ${itemData.tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-subtipo-rec" onclick="openManageSubtiposRecModal(); setTimeout(() => updateEditSubtipoForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria-rec" onclick="openManageCategoriasRecModal(); setTimeout(() => updateEditCategoriaForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    updateEditSubtipoForReceiving();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaForReceiving();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
            }
        };
        
        // Funções auxiliares para edição (RECEBIMENTO)
        window.updateEditSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const btnManage = document.getElementById('btn-manage-edit-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obra.id}">${obraName}</option>`;
                        });
                    }
                } catch (error) {
                    console.error('Erro:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                }
            } else if (tipo === 'OUTROS') {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('edit-categoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        window.updateEditCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            const btnManage = document.getElementById('btn-manage-edit-categoria-rec');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManage) {
                        btnManage.disabled = true;
                        btnManage.style.opacity = '0.5';
                        btnManage.style.pointerEvents = 'none';
                        btnManage.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        }
                    } catch (error) {
                        console.error('Erro:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    }
                }
            } else if (tipo === 'OUTROS') {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
            }
        };


        // ===================================================================
        // INTEGRAÇÃO COM SISTEMA DE MEDIÇÕES
        // ===================================================================
        
        // Variável global para armazenar obra selecionada
        window.obraIdSelecionadaFluxoCaixa = null;
        
        // Função para verificar se deve mostrar botão Nova Medição
        function checkAndShowNovaMedicaoButton(listType) {
            const novaMedicaoSection = document.getElementById('novaMedicaoSection');
            
            if (!novaMedicaoSection) return;
            
            // Verificar condições:
            // 1. Tipo de evento = RECEBIMENTO
            // 2. TIPO = OBRAS
            // 3. SUBTIPO = uma obra selecionada
            // 4. listType = 'recebimento_outros_categorias' (gerenciando categorias de recebimento)
            
            const eventTypeRadio = document.querySelector('input[name="eventType"]:checked');
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            const isRecebimento = eventTypeRadio && eventTypeRadio.value === 'RECEBIMENTO';
            const isTipoObras = tipoSelect && tipoSelect.value === 'OBRAS';
            const obraSelecionada = subtipoSelect && subtipoSelect.value !== '';
            const isCategoriasRec = listType === 'recebimento_outros_categorias';
            
            // Mostrar botão apenas se todas as condições forem atendidas
            if (isRecebimento && isTipoObras && obraSelecionada && isCategoriasRec) {
                novaMedicaoSection.style.display = 'block';
                
                // Armazenar obra_id para uso posterior
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                window.obraIdSelecionadaFluxoCaixa = selectedOption.getAttribute('data-obra-id');
                
                console.log('✅ Botão Nova Medição habilitado para obra:', window.obraIdSelecionadaFluxoCaixa);
            } else {
                novaMedicaoSection.style.display = 'none';
                window.obraIdSelecionadaFluxoCaixa = null;
            }
        }
        
        
        // ===================================================================
        
        // Variáveis globais para medições
        window.obraSelecionadaMedicaoInline = null;
        window.obraIdMedicaoInline = null;
        
        // Função para abrir modal de Nova Medição do fluxo de caixa
        async function abrirNovaMedicaoDoFluxoCaixa() {
            console.log('🚀 Abrindo modal de Nova Medição inline...');
            
            // Fechar modal de gerenciar listas
            closeManageListModal();
            
            // Abrir modal inline
            await abrirModalMedicaoInline();
        }
        
        // Abrir modal de medição inline
        async function abrirModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (!modal) return;
            
            // Limpar formulário
            document.getElementById('data-medicao-inline').value = new Date().toISOString().split('T')[0];
            
            const dataFutura = new Date();
            dataFutura.setDate(dataFutura.getDate() + 30);
            document.getElementById('data-recebimento-inline').value = dataFutura.toISOString().split('T')[0];
            
            document.getElementById('valor-medicao-inline').value = '';
            document.getElementById('status-medicao-inline').value = 'pendente';
            document.getElementById('observacoes-medicao-inline').value = '';
            
            // Resetar obra selecionada
            window.obraSelecionadaMedicaoInline = null;
            window.obraIdMedicaoInline = window.obraIdSelecionadaFluxoCaixa;
            
            // Se já tem obra selecionada do fluxo de caixa, pré-selecionar
            if (window.obraIdSelecionadaFluxoCaixa) {
                await preSelecionarObraNoModal(window.obraIdSelecionadaFluxoCaixa);
            } else {
                const container = document.getElementById('obra-selecionada-container-inline');
                if (container) {
                    container.innerHTML = `
                        <button type="button" class="btn-secondary" onclick="abrirModalObrasInline()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-building"></i>
                            Selecionar Obra
                        </button>
                    `;
                }
            }
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Pré-selecionar obra no modal
        async function preSelecionarObraNoModal(obraId) {
            try {
                const { data: obra, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .eq('id', obraId)
                    .single();
                
                if (error) throw error;
                
                if (obra) {
                    window.obraSelecionadaMedicaoInline = obra;
                    window.obraIdMedicaoInline = obra.id;
                    
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    const container = document.getElementById('obra-selecionada-container-inline');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #4CAF50;">${obraName}</strong>
                                </div>
                                <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                                    Trocar
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Erro ao pré-selecionar obra:', error);
            }
        }
        
        // Fechar modal de medição
        function fecharModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Abrir modal de obras
        async function abrirModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (!modal) return;
            
            // Carregar obras
            await carregarObrasParaModal();
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Fechar modal de obras
        function fecharModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Carregar obras para o modal
        async function carregarObrasParaModal() {
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('obras-list-inline');
                if (!container) return;
                
                if (obras && obras.length > 0) {
                    container.innerHTML = obras.map(obra => {
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        return `
                            <div class="obras-list-item" onclick="selecionarObraInline(${obra.id}, '${obraName}')" style="padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                                <strong style="color: #fff;">${obraName}</strong>
                            </div>
                        `;
                    }).join('');
                } else {
                    container.innerHTML = '<p style="text-align: center; color: #b0c4de;">Nenhuma obra cadastrada</p>';
                }
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
            }
        }
        
        // Selecionar obra
        function selecionarObraInline(obraId, obraName) {
            window.obraIdMedicaoInline = obraId;
            
            const container = document.getElementById('obra-selecionada-container-inline');
            if (container) {
                container.innerHTML = `
                    <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #4CAF50;">${obraName}</strong>
                        </div>
                        <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                            Trocar
                        </button>
                    </div>
                `;
            }
            
            // Fechar modal de obras
            fecharModalObrasInline();
        }
        
        // Salvar medição
        async function salvarMedicaoInline(event) {
            event.preventDefault();
            
            const dataMedicao = document.getElementById('data-medicao-inline').value;
            const dataRecebimento = document.getElementById('data-recebimento-inline').value;
            const valor = parseFloat(document.getElementById('valor-medicao-inline').value);
            const status = document.getElementById('status-medicao-inline').value;
            const observacoes = document.getElementById('observacoes-medicao-inline').value;
            const obraId = window.obraIdMedicaoInline;
            
            if (!obraId) {
                alert('Por favor, selecione uma obra');
                return;
            }
            
            try {
                // Gerar número da medição
                const { data: ultimaMedicao } = await supabase
                    .from('medicoes_hvc')
                    .select('numero')
                    .order('numero', { ascending: false })
                    .limit(1)
                    .single();
                
                const proximoNumero = ultimaMedicao ? parseInt(ultimaMedicao.numero.replace('MED-', '')) + 1 : 1;
                const numeroMedicao = `MED-${String(proximoNumero).padStart(3, '0')}`;
                
                // Salvar no Supabase
                const { data, error } = await supabase
                    .from('medicoes_hvc')
                    .insert([{
                        numero: numeroMedicao,
                        obra_id: obraId,
                        data_medicao: dataMedicao,
                        data_recebimento: dataRecebimento,
                        valor: valor,
                        status: status,
                        observacoes: observacoes
                    }])
                    .select();
                
                if (error) throw error;
                
                alert('Medição criada com sucesso!');
                fecharModalMedicaoInline();
                
                // Atualizar lista de categorias
                if (typeof updateCategoriaForReceiving === 'function') {
                    await updateCategoriaForReceiving();
                }
                
            } catch (error) {
                console.error('Erro ao salvar medição:', error);
                alert('Erro ao salvar medição: ' + error.message);
            }
        }
        
    </script>
    
    <!-- ✅ NOVO: Event Listeners para criação de eventos -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Event listeners para criação de eventos
            const addItemBtn = document.getElementById('addItemBtn');
            const createEventBtn = document.getElementById('createEventBtn');
            const cancelEventBtn = document.getElementById('cancelEventBtn');
            const refreshAccountsBtn = document.getElementById('refreshAccountsBtn');
            
            if (addItemBtn && typeof addPaymentItem === 'function') {
                addItemBtn.addEventListener('click', addPaymentItem);
            } else if (addItemBtn) {
                console.warn('⚠️ addPaymentItem function not found');
            }
            
            if (createEventBtn && typeof createPaymentEvent === 'function') {
                createEventBtn.addEventListener('click', createPaymentEvent);
            } else if (createEventBtn) {
                console.warn('⚠️ createPaymentEvent function not found');
            }
            
            if (cancelEventBtn) {
                cancelEventBtn.addEventListener('click', function() {
                    clearEventForm();
                    toggleEventCreator();
                });
            }
            
            if (refreshAccountsBtn) {
                refreshAccountsBtn.addEventListener('click', function() {
                    console.log('🔄 Atualizando lista de contas...');
                    populateAccountSelector();
                });
            }
            
            // ✅ NOVO: Formatação automática do campo valor
            const itemValorInput = document.getElementById('itemValor');
            if (itemValorInput) {
                itemValorInput.addEventListener('input', function(e) {
                    let value = e.target.value.replace(/\D/g, ''); // Remove tudo que não é dígito
                    
                    if (value === '') {
                        e.target.value = '';
                        return;
                    }
                    
                    // Converte para número e formata
                    const numValue = parseInt(value) / 100;
                    e.target.value = formatCurrency(numValue);
                });
                
                // Limpar formatação ao focar para edição
                itemValorInput.addEventListener('focus', function(e) {
                    const value = e.target.value.replace(/[^\d,]/g, '').replace(',', '.');
                    if (value && !isNaN(parseFloat(value))) {
                        e.target.value = parseFloat(value).toFixed(2).replace('.', ',');
                    }
                });
                
                // Reformatar ao sair do campo
                itemValorInput.addEventListener('blur', function(e) {
                    const value = e.target.value.replace(',', '.');
                    if (value && !isNaN(parseFloat(value))) {
                        e.target.value = formatCurrency(parseFloat(value));
                    }
                });
            }
            
            // Permitir Enter para adicionar item
            const itemForm = document.querySelector('.add-item-form');
            if (itemForm) {
                itemForm.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addPaymentItem();
                    }
                });
            }
            
            // ✅ NOVO: Configurar override do sistema de exclusão imediatamente
            overrideDeleteSystem();
            
            // ✅ NOVO: Interceptar botão de exclusão existente no modal
            setTimeout(async () => {
                interceptExistingDeleteButtons();
            }, 2000);
            
            // ✅ NOVO: Adicionar botões de exclusão aos eventos existentes
            setTimeout(async () => {
                if (typeof addDeleteButtonsToEvents === 'function') {
                    addDeleteButtonsToEvents();
                }
            }, 3000);
            
            // ✅ NOVO: Observer para adicionar botões quando novos eventos aparecem
            let observerTimeout = null;
            const observer = new MutationObserver(function(mutations) {
                // Debounce para evitar execuções excessivas
                if (observerTimeout) clearTimeout(observerTimeout);
                
                observerTimeout = setTimeout(async () => {
                    let hasNewNodes = false;
                    mutations.forEach(function(mutation) {
                        if (mutation.addedNodes.length > 0) {
                            hasNewNodes = true;
                        }
                    });
                    
                    if (hasNewNodes) {
                        console.log('🔄 Novos elementos detectados, interceptando botões...');
                        
                        // Interceptar novos botões de exclusão
                        interceptExistingDeleteButtons();
                        
                        // Adicionar nossos botões
                        if (typeof addDeleteButtonsToEvents === 'function') {
                            addDeleteButtonsToEvents();
                        }
                    }
                }, 2000); // Aguardar 2 segundos antes de executar
            }); // Fechamento do DOMContentLoaded
            
            // Observar mudanças no calendário e na lista de eventos
            const observeTargets = [
                '.calendar-section',
                '.events-container', 
                '#calendar',
                '.calendar-grid',
                '.event-list',
                '.payments-list'
            ];
            
            observeTargets.forEach(selector => {
                const target = document.querySelector(selector);
                if (target) {
                    observer.observe(target, {
                        childList: true,
                        subtree: true
                    });
                }
            });
        }); // ✅ CORREÇÃO: Fechamento do DOMContentLoaded que estava faltando

        // =================================================================
        // ✅ FUNCIONALIDADES DE EDIÇÃO DE ITENS REMOVIDAS (DUPLICAÇÃO)
        // As funções de edição estão implementadas anteriormente no código
        // =================================================================

        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA na edição do modal
        window.renderEditFieldsBasedOnEventType = function(eventType, itemData) {
            const tipoInput = document.querySelector('#editItemForm input[placeholder*="Tipo"]')?.closest('.form-group');
            const subtipoInput = document.querySelector('#editItemForm input[placeholder*="Subtipo"]')?.closest('.form-group');
            const categoriaInput = document.querySelector('#editItemForm input[placeholder*="Categoria"]')?.closest('.form-group');
            
            if (!tipoInput || !subtipoInput || !categoriaInput) return;
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: mesma lógica atual
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control">
                        <option value="">Nenhum</option>
                        <option value="INTERNO" ${itemData.tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                        <option value="EXTERNO" ${itemData.tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" onclick="openManageListModal(\'subtipos\'); setTimeout(() => populateEditSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria" onclick="openManageListModal(\'categorias\'); setTimeout(() => updateEditCategoriaBasedOnSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    populateEditSubtipo();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaBasedOnSubtipo();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: nova lógica
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control" onchange="updateEditSubtipoForReceiving()">
                        <option value="">Nenhum</option>
                        <option value="OBRAS" ${itemData.tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                        <option value="OUTROS" ${itemData.tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-subtipo-rec" onclick="openManageSubtiposRecModal(); setTimeout(() => updateEditSubtipoForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria-rec" onclick="openManageCategoriasRecModal(); setTimeout(() => updateEditCategoriaForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    updateEditSubtipoForReceiving();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaForReceiving();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
            }
        };
        
        // Funções auxiliares para edição (RECEBIMENTO)
        window.updateEditSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const btnManage = document.getElementById('btn-manage-edit-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obra.id}">${obraName}</option>`;
                        });
                    }
                } catch (error) {
                    console.error('Erro:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                }
            } else if (tipo === 'OUTROS') {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('edit-categoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        window.updateEditCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            const btnManage = document.getElementById('btn-manage-edit-categoria-rec');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManage) {
                        btnManage.disabled = true;
                        btnManage.style.opacity = '0.5';
                        btnManage.style.pointerEvents = 'none';
                        btnManage.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        }
                    } catch (error) {
                        console.error('Erro:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    }
                }
            } else if (tipo === 'OUTROS') {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
            }
        };


        // ===================================================================
        // INTEGRAÇÃO COM SISTEMA DE MEDIÇÕES
        // ===================================================================
        
        // Variável global para armazenar obra selecionada
        window.obraIdSelecionadaFluxoCaixa = null;
        
        // Função para verificar se deve mostrar botão Nova Medição
        function checkAndShowNovaMedicaoButton(listType) {
            const novaMedicaoSection = document.getElementById('novaMedicaoSection');
            
            if (!novaMedicaoSection) return;
            
            // Verificar condições:
            // 1. Tipo de evento = RECEBIMENTO
            // 2. TIPO = OBRAS
            // 3. SUBTIPO = uma obra selecionada
            // 4. listType = 'recebimento_outros_categorias' (gerenciando categorias de recebimento)
            
            const eventTypeRadio = document.querySelector('input[name="eventType"]:checked');
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            const isRecebimento = eventTypeRadio && eventTypeRadio.value === 'RECEBIMENTO';
            const isTipoObras = tipoSelect && tipoSelect.value === 'OBRAS';
            const obraSelecionada = subtipoSelect && subtipoSelect.value !== '';
            const isCategoriasRec = listType === 'recebimento_outros_categorias';
            
            // Mostrar botão apenas se todas as condições forem atendidas
            if (isRecebimento && isTipoObras && obraSelecionada && isCategoriasRec) {
                novaMedicaoSection.style.display = 'block';
                
                // Armazenar obra_id para uso posterior
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                window.obraIdSelecionadaFluxoCaixa = selectedOption.getAttribute('data-obra-id');
                
                console.log('✅ Botão Nova Medição habilitado para obra:', window.obraIdSelecionadaFluxoCaixa);
            } else {
                novaMedicaoSection.style.display = 'none';
                window.obraIdSelecionadaFluxoCaixa = null;
            }
        }
        
        
        // ===================================================================
        
        // Variáveis globais para medições
        window.obraSelecionadaMedicaoInline = null;
        window.obraIdMedicaoInline = null;
        
        // Função para abrir modal de Nova Medição do fluxo de caixa
        async function abrirNovaMedicaoDoFluxoCaixa() {
            console.log('🚀 Abrindo modal de Nova Medição inline...');
            
            // Fechar modal de gerenciar listas
            closeManageListModal();
            
            // Abrir modal inline
            await abrirModalMedicaoInline();
        }
        
        // Abrir modal de medição inline
        async function abrirModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (!modal) return;
            
            // Limpar formulário
            document.getElementById('data-medicao-inline').value = new Date().toISOString().split('T')[0];
            
            const dataFutura = new Date();
            dataFutura.setDate(dataFutura.getDate() + 30);
            document.getElementById('data-recebimento-inline').value = dataFutura.toISOString().split('T')[0];
            
            document.getElementById('valor-medicao-inline').value = '';
            document.getElementById('status-medicao-inline').value = 'pendente';
            document.getElementById('observacoes-medicao-inline').value = '';
            
            // Resetar obra selecionada
            window.obraSelecionadaMedicaoInline = null;
            window.obraIdMedicaoInline = window.obraIdSelecionadaFluxoCaixa;
            
            // Se já tem obra selecionada do fluxo de caixa, pré-selecionar
            if (window.obraIdSelecionadaFluxoCaixa) {
                await preSelecionarObraNoModal(window.obraIdSelecionadaFluxoCaixa);
            } else {
                const container = document.getElementById('obra-selecionada-container-inline');
                if (container) {
                    container.innerHTML = `
                        <button type="button" class="btn-secondary" onclick="abrirModalObrasInline()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-building"></i>
                            Selecionar Obra
                        </button>
                    `;
                }
            }
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Pré-selecionar obra no modal
        async function preSelecionarObraNoModal(obraId) {
            try {
                const { data: obra, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .eq('id', obraId)
                    .single();
                
                if (error) throw error;
                
                if (obra) {
                    window.obraSelecionadaMedicaoInline = obra;
                    window.obraIdMedicaoInline = obra.id;
                    
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    const container = document.getElementById('obra-selecionada-container-inline');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #4CAF50;">${obraName}</strong>
                                </div>
                                <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                                    Trocar
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Erro ao pré-selecionar obra:', error);
            }
        }
        
        // Fechar modal de medição
        function fecharModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Abrir modal de obras
        async function abrirModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (!modal) return;
            
            // Carregar obras
            await carregarObrasParaModal();
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Fechar modal de obras
        function fecharModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Carregar obras para o modal
        async function carregarObrasParaModal() {
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('obras-list-inline');
                if (!container) return;
                
                if (obras && obras.length > 0) {
                    container.innerHTML = obras.map(obra => {
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        return `
                            <div class="obras-list-item" onclick="selecionarObraInline(${obra.id}, '${obraName}')" style="padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                                <strong style="color: #fff;">${obraName}</strong>
                            </div>
                        `;
                    }).join('');
                } else {
                    container.innerHTML = '<p style="text-align: center; color: #b0c4de;">Nenhuma obra cadastrada</p>';
                }
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
            }
        }
        
        // Selecionar obra
        function selecionarObraInline(obraId, obraName) {
            window.obraIdMedicaoInline = obraId;
            
            const container = document.getElementById('obra-selecionada-container-inline');
            if (container) {
                container.innerHTML = `
                    <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #4CAF50;">${obraName}</strong>
                        </div>
                        <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                            Trocar
                        </button>
                    </div>
                `;
            }
            
            // Fechar modal de obras
            fecharModalObrasInline();
        }
        
        // Salvar medição
        async function salvarMedicaoInline(event) {
            event.preventDefault();
            
            const dataMedicao = document.getElementById('data-medicao-inline').value;
            const dataRecebimento = document.getElementById('data-recebimento-inline').value;
            const valor = parseFloat(document.getElementById('valor-medicao-inline').value);
            const status = document.getElementById('status-medicao-inline').value;
            const observacoes = document.getElementById('observacoes-medicao-inline').value;
            const obraId = window.obraIdMedicaoInline;
            
            if (!obraId) {
                alert('Por favor, selecione uma obra');
                return;
            }
            
            try {
                // Gerar número da medição
                const { data: ultimaMedicao } = await supabase
                    .from('medicoes_hvc')
                    .select('numero')
                    .order('numero', { ascending: false })
                    .limit(1)
                    .single();
                
                const proximoNumero = ultimaMedicao ? parseInt(ultimaMedicao.numero.replace('MED-', '')) + 1 : 1;
                const numeroMedicao = `MED-${String(proximoNumero).padStart(3, '0')}`;
                
                // Salvar no Supabase
                const { data, error } = await supabase
                    .from('medicoes_hvc')
                    .insert([{
                        numero: numeroMedicao,
                        obra_id: obraId,
                        data_medicao: dataMedicao,
                        data_recebimento: dataRecebimento,
                        valor: valor,
                        status: status,
                        observacoes: observacoes
                    }])
                    .select();
                
                if (error) throw error;
                
                alert('Medição criada com sucesso!');
                fecharModalMedicaoInline();
                
                // Atualizar lista de categorias
                if (typeof updateCategoriaForReceiving === 'function') {
                    await updateCategoriaForReceiving();
                }
                
            } catch (error) {
                console.error('Erro ao salvar medição:', error);
                alert('Erro ao salvar medição: ' + error.message);
            }
        }
        
    </script>
    
    <style>
        /* ✅ NOVO: Estilos para edição de itens no modal individual */
        .payments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .btn-edit-payments {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-edit-payments:hover {
            background: linear-gradient(135deg, #f57c00, #e65100);
            transform: translateY(-1px);
        }
        
        .edit-items-form {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 25px;
            margin-top: 20px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .edit-item-row {
            display: grid;
            grid-template-columns: 2fr 1.2fr 1fr 2fr;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }
        
        .edit-item-row:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        .edit-item-field {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .edit-item-field label {
            color: #ffffff;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        
        .edit-item-field input,
        .edit-item-field select {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            color: #ffffff;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }
        
        .edit-item-field select {
            background: linear-gradient(135deg, #2196F3, #1976D2) !important;
            color: #ffffff !important;
            border: 2px solid #1565C0 !important;
            font-weight: 600;
            cursor: pointer;
        }
        
        .edit-item-field select option {
            background: #1976D2 !important;
            color: #ffffff !important;
            padding: 12px;
            font-weight: 500;
        }
        
        .edit-item-field input:focus,
        .edit-item-field select:focus {
            outline: none;
            border-color: #4CAF50 !important;
            background: rgba(255, 255, 255, 0.25) !important;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
            transform: translateY(-1px);
        }
        
        .edit-item-field select:focus {
            background: linear-gradient(135deg, #1976D2, #1565C0) !important;
        }
        
        .edit-item-field input:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.2);
        }
        
        .edit-items-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn-save-items {
            background: linear-gradient(135deg, #4CAF50, #388E3C);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-save-items:hover {
            background: linear-gradient(135deg, #388E3C, #2E7D32);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .btn-cancel-edit {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-cancel-edit:hover {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
        }
        
        @media (max-width: 768px) {
            .event-modal-content {
                width: 98%;
                margin: 2% auto;
                padding: 20px;
                min-width: 350px;
                max-height: 95vh;
            }
            
            .edit-item-row {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }
            
            .payments-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }
            
            .edit-items-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn-save-items,
            .btn-cancel-edit {
                width: 100%;
                justify-content: center;
                padding: 12px 20px;
                font-size: 14px;
            }
        }
    
        
        </style>
    
    <script>
        // ✅ NOVO: Funções para Saldo da Conta Corrente
        let accountBalance = 0;

        function formatCurrencyInput(input) {
            // ✅ CORRIGIDO: Permitir valores negativos
            const isNegative = input.value.includes('-');
            let value = input.value.replace(/[^\d]/g, ''); // Remove tudo exceto dígitos
            
            if (value) {
                value = (parseInt(value) / 100).toFixed(2);
                value = value.replace('.', ',');
                value = value.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                
                // ✅ NOVO: Adicionar sinal negativo se necessário
                const prefix = isNegative ? '-R$ ' : 'R$ ';
                input.value = prefix + value;
            }
        }

        function updateAccountBalance() {
            const input = document.getElementById('accountBalance');
            
            // ✅ CORRIGIDO: Processar valores negativos corretamente
            const isNegative = input.value.includes('-');
            const value = input.value.replace(/[^\d,]/g, '').replace(',', '.');
            let parsedValue = parseFloat(value) || 0;
            
            // ✅ NOVO: Aplicar sinal negativo se necessário
            if (isNegative) {
                parsedValue = -Math.abs(parsedValue);
            }
            
            accountBalance = parsedValue;
            
            // Atualizar saldos acumulados no calendário
            updateDailyBalances();
        }

        function updateDailyBalances() {
            const calendarGrid = document.getElementById('calendarGrid');
            if (!calendarGrid) return;

            const days = calendarGrid.querySelectorAll('.calendar-day');
            let runningBalance = accountBalance;

            days.forEach((dayElement, index) => {
                const dayNumber = parseInt(dayElement.querySelector('.day-number')?.textContent);
                if (!dayNumber) return;

                // Calcular saldo do dia
                const dayBalance = calculateDayBalance(dayNumber);
                
                // Para o dia 1, usar saldo da conta + saldo do dia
                // Para outros dias, usar saldo acumulado anterior + saldo do dia
                if (dayNumber === 1) {
                    runningBalance = accountBalance + dayBalance;
                } else {
                    runningBalance += dayBalance;
                }

                // Adicionar ou atualizar elemento de saldo acumulado
                let balanceElement = dayElement.querySelector('.day-accumulated-balance');
                if (!balanceElement) {
                    balanceElement = document.createElement('div');
                    balanceElement.className = 'day-accumulated-balance';
                    dayElement.appendChild(balanceElement);
                }

                balanceElement.textContent = formatCurrency(runningBalance);
                
                // Cor baseada no saldo (verde se positivo, vermelho se negativo)
                balanceElement.style.color = runningBalance >= 0 ? '#4caf50' : '#f44336';
            });
        }

        function calculateDayBalance(dayNumber) {
            // Buscar eventos do dia e calcular saldo
            const dayDate = new Date(currentYear, currentMonth, dayNumber);
            const events = getEventsForDay(dayDate);
            let dayBalance = 0;

            events.forEach(event => {
                const eventCalc = calculateEventTotal(event);
                const eventType = getEventType(event);

                if (eventType === 'recebimento') {
                    // Somar apenas recebimentos RC
                    eventCalc.receivingItems.forEach(item => {
                        if (item.status === 'RC') {
                            dayBalance += item.value;
                        }
                    });
                } else {
                    // Subtrair apenas pagamentos PG
                    eventCalc.paymentItems.forEach(item => {
                        if (item.status === 'PG') {
                            dayBalance -= item.value;
                        }
                    });
                }
            });

            return dayBalance;
        }

        // ✅ REMOVIDO: Função duplicada que causava conflito

        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA na edição do modal
        window.renderEditFieldsBasedOnEventType = function(eventType, itemData) {
            const tipoInput = document.querySelector('#editItemForm input[placeholder*="Tipo"]')?.closest('.form-group');
            const subtipoInput = document.querySelector('#editItemForm input[placeholder*="Subtipo"]')?.closest('.form-group');
            const categoriaInput = document.querySelector('#editItemForm input[placeholder*="Categoria"]')?.closest('.form-group');
            
            if (!tipoInput || !subtipoInput || !categoriaInput) return;
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: mesma lógica atual
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control">
                        <option value="">Nenhum</option>
                        <option value="INTERNO" ${itemData.tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                        <option value="EXTERNO" ${itemData.tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" onclick="openManageListModal(\'subtipos\'); setTimeout(() => populateEditSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria" onclick="openManageListModal(\'categorias\'); setTimeout(() => updateEditCategoriaBasedOnSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    populateEditSubtipo();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaBasedOnSubtipo();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: nova lógica
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control" onchange="updateEditSubtipoForReceiving()">
                        <option value="">Nenhum</option>
                        <option value="OBRAS" ${itemData.tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                        <option value="OUTROS" ${itemData.tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-subtipo-rec" onclick="openManageSubtiposRecModal(); setTimeout(() => updateEditSubtipoForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria-rec" onclick="openManageCategoriasRecModal(); setTimeout(() => updateEditCategoriaForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    updateEditSubtipoForReceiving();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaForReceiving();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
            }
        };
        
        // Funções auxiliares para edição (RECEBIMENTO)
        window.updateEditSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const btnManage = document.getElementById('btn-manage-edit-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obra.id}">${obraName}</option>`;
                        });
                    }
                } catch (error) {
                    console.error('Erro:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                }
            } else if (tipo === 'OUTROS') {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('edit-categoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        window.updateEditCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            const btnManage = document.getElementById('btn-manage-edit-categoria-rec');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManage) {
                        btnManage.disabled = true;
                        btnManage.style.opacity = '0.5';
                        btnManage.style.pointerEvents = 'none';
                        btnManage.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        }
                    } catch (error) {
                        console.error('Erro:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    }
                }
            } else if (tipo === 'OUTROS') {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
            }
        };


        // ===================================================================
        // INTEGRAÇÃO COM SISTEMA DE MEDIÇÕES
        // ===================================================================
        
        // Variável global para armazenar obra selecionada
        window.obraIdSelecionadaFluxoCaixa = null;
        
        // Função para verificar se deve mostrar botão Nova Medição
        function checkAndShowNovaMedicaoButton(listType) {
            const novaMedicaoSection = document.getElementById('novaMedicaoSection');
            
            if (!novaMedicaoSection) return;
            
            // Verificar condições:
            // 1. Tipo de evento = RECEBIMENTO
            // 2. TIPO = OBRAS
            // 3. SUBTIPO = uma obra selecionada
            // 4. listType = 'recebimento_outros_categorias' (gerenciando categorias de recebimento)
            
            const eventTypeRadio = document.querySelector('input[name="eventType"]:checked');
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            const isRecebimento = eventTypeRadio && eventTypeRadio.value === 'RECEBIMENTO';
            const isTipoObras = tipoSelect && tipoSelect.value === 'OBRAS';
            const obraSelecionada = subtipoSelect && subtipoSelect.value !== '';
            const isCategoriasRec = listType === 'recebimento_outros_categorias';
            
            // Mostrar botão apenas se todas as condições forem atendidas
            if (isRecebimento && isTipoObras && obraSelecionada && isCategoriasRec) {
                novaMedicaoSection.style.display = 'block';
                
                // Armazenar obra_id para uso posterior
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                window.obraIdSelecionadaFluxoCaixa = selectedOption.getAttribute('data-obra-id');
                
                console.log('✅ Botão Nova Medição habilitado para obra:', window.obraIdSelecionadaFluxoCaixa);
            } else {
                novaMedicaoSection.style.display = 'none';
                window.obraIdSelecionadaFluxoCaixa = null;
            }
        }
        
        
        // ===================================================================
        
        // Variáveis globais para medições
        window.obraSelecionadaMedicaoInline = null;
        window.obraIdMedicaoInline = null;
        
        // Função para abrir modal de Nova Medição do fluxo de caixa
        async function abrirNovaMedicaoDoFluxoCaixa() {
            console.log('🚀 Abrindo modal de Nova Medição inline...');
            
            // Fechar modal de gerenciar listas
            closeManageListModal();
            
            // Abrir modal inline
            await abrirModalMedicaoInline();
        }
        
        // Abrir modal de medição inline
        async function abrirModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (!modal) return;
            
            // Limpar formulário
            document.getElementById('data-medicao-inline').value = new Date().toISOString().split('T')[0];
            
            const dataFutura = new Date();
            dataFutura.setDate(dataFutura.getDate() + 30);
            document.getElementById('data-recebimento-inline').value = dataFutura.toISOString().split('T')[0];
            
            document.getElementById('valor-medicao-inline').value = '';
            document.getElementById('status-medicao-inline').value = 'pendente';
            document.getElementById('observacoes-medicao-inline').value = '';
            
            // Resetar obra selecionada
            window.obraSelecionadaMedicaoInline = null;
            window.obraIdMedicaoInline = window.obraIdSelecionadaFluxoCaixa;
            
            // Se já tem obra selecionada do fluxo de caixa, pré-selecionar
            if (window.obraIdSelecionadaFluxoCaixa) {
                await preSelecionarObraNoModal(window.obraIdSelecionadaFluxoCaixa);
            } else {
                const container = document.getElementById('obra-selecionada-container-inline');
                if (container) {
                    container.innerHTML = `
                        <button type="button" class="btn-secondary" onclick="abrirModalObrasInline()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-building"></i>
                            Selecionar Obra
                        </button>
                    `;
                }
            }
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Pré-selecionar obra no modal
        async function preSelecionarObraNoModal(obraId) {
            try {
                const { data: obra, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .eq('id', obraId)
                    .single();
                
                if (error) throw error;
                
                if (obra) {
                    window.obraSelecionadaMedicaoInline = obra;
                    window.obraIdMedicaoInline = obra.id;
                    
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    const container = document.getElementById('obra-selecionada-container-inline');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #4CAF50;">${obraName}</strong>
                                </div>
                                <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                                    Trocar
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Erro ao pré-selecionar obra:', error);
            }
        }
        
        // Fechar modal de medição
        function fecharModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Abrir modal de obras
        async function abrirModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (!modal) return;
            
            // Carregar obras
            await carregarObrasParaModal();
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Fechar modal de obras
        function fecharModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Carregar obras para o modal
        async function carregarObrasParaModal() {
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('obras-list-inline');
                if (!container) return;
                
                if (obras && obras.length > 0) {
                    container.innerHTML = obras.map(obra => {
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        return `
                            <div class="obras-list-item" onclick="selecionarObraInline(${obra.id}, '${obraName}')" style="padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                                <strong style="color: #fff;">${obraName}</strong>
                            </div>
                        `;
                    }).join('');
                } else {
                    container.innerHTML = '<p style="text-align: center; color: #b0c4de;">Nenhuma obra cadastrada</p>';
                }
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
            }
        }
        
        // Selecionar obra
        function selecionarObraInline(obraId, obraName) {
            window.obraIdMedicaoInline = obraId;
            
            const container = document.getElementById('obra-selecionada-container-inline');
            if (container) {
                container.innerHTML = `
                    <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #4CAF50;">${obraName}</strong>
                        </div>
                        <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                            Trocar
                        </button>
                    </div>
                `;
            }
            
            // Fechar modal de obras
            fecharModalObrasInline();
        }
        
        // Salvar medição
        async function salvarMedicaoInline(event) {
            event.preventDefault();
            
            const dataMedicao = document.getElementById('data-medicao-inline').value;
            const dataRecebimento = document.getElementById('data-recebimento-inline').value;
            const valor = parseFloat(document.getElementById('valor-medicao-inline').value);
            const status = document.getElementById('status-medicao-inline').value;
            const observacoes = document.getElementById('observacoes-medicao-inline').value;
            const obraId = window.obraIdMedicaoInline;
            
            if (!obraId) {
                alert('Por favor, selecione uma obra');
                return;
            }
            
            try {
                // Gerar número da medição
                const { data: ultimaMedicao } = await supabase
                    .from('medicoes_hvc')
                    .select('numero')
                    .order('numero', { ascending: false })
                    .limit(1)
                    .single();
                
                const proximoNumero = ultimaMedicao ? parseInt(ultimaMedicao.numero.replace('MED-', '')) + 1 : 1;
                const numeroMedicao = `MED-${String(proximoNumero).padStart(3, '0')}`;
                
                // Salvar no Supabase
                const { data, error } = await supabase
                    .from('medicoes_hvc')
                    .insert([{
                        numero: numeroMedicao,
                        obra_id: obraId,
                        data_medicao: dataMedicao,
                        data_recebimento: dataRecebimento,
                        valor: valor,
                        status: status,
                        observacoes: observacoes
                    }])
                    .select();
                
                if (error) throw error;
                
                alert('Medição criada com sucesso!');
                fecharModalMedicaoInline();
                
                // Atualizar lista de categorias
                if (typeof updateCategoriaForReceiving === 'function') {
                    await updateCategoriaForReceiving();
                }
                
            } catch (error) {
                console.error('Erro ao salvar medição:', error);
                alert('Erro ao salvar medição: ' + error.message);
            }
        }
        
    </script>

    <!-- Carregamento robusto das APIs Google com retry e fallback -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        console.log('🚀 Iniciando carregamento robusto das APIs Google...');
        
        // Função para carregar script com retry
        function carregarScript(url, nome, maxTentativas = 3) {
            return new Promise((resolve, reject) => {
                let tentativas = 0;
                
                function tentar() {
                    tentativas++;
                    console.log(`📥 Carregando ${nome} (tentativa ${tentativas}/${maxTentativas})...`);
                    
                    const script = document.createElement('script');
                    script.src = url;
                    script.async = true;
                    script.defer = true;
                    
                    script.onload = function() {
                        console.log(`✅ ${nome} carregado com sucesso!`);
                        resolve();
                    };
                    
                    script.onerror = function() {
                        console.error(`❌ Erro ao carregar ${nome}`);
                        if (tentativas < maxTentativas) {
                            console.log(`⏳ Tentando novamente em 2 segundos...`);
                            setTimeout(tentar, 2000);
                        } else {
                            reject(new Error(`Falha ao carregar ${nome} após ${maxTentativas} tentativas`));
                        }
                    };
                    
                    document.head.appendChild(script);
                }
                
                tentar();
            });
        }
        
        // Carregar APIs sequencialmente com verificação
        async function inicializarAPIs() {
            try {
                // Verificar se já estão carregadas
                if (typeof gapi !== 'undefined' && typeof google !== 'undefined' && google.accounts) {
                    console.log('✅ APIs Google já estavam carregadas!');
                    return;
                }
                
                // Carregar GAPI primeiro
                if (typeof gapi === 'undefined') {
                    await carregarScript('https://apis.google.com/js/api.js', 'GAPI');
                    
                    // Aguardar GAPI estar disponível globalmente
                    let tentativasGapi = 0;
                    while (typeof gapi === 'undefined' && tentativasGapi < 20) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        tentativasGapi++;
                    }
                    
                    if (typeof gapi !== 'undefined') {
                        console.log('✅ GAPI disponível globalmente');
                        if (typeof window.gapiLoaded === 'function') {
                            console.log('🔄 Chamando gapiLoaded...');
                            window.gapiLoaded();
                        }
                    } else {
                        throw new Error('GAPI não ficou disponível após carregamento');
                    }
                }
                
                // Carregar GIS
                if (typeof google === 'undefined' || !google.accounts) {
                    await carregarScript('https://accounts.google.com/gsi/client', 'Google Identity Services');
                    
                    // Aguardar GIS estar disponível globalmente
                    let tentativasGis = 0;
                    while ((typeof google === 'undefined' || !google.accounts) && tentativasGis < 20) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        tentativasGis++;
                    }
                    
                    if (typeof google !== 'undefined' && google.accounts) {
                        console.log('✅ Google Identity Services disponível globalmente');
                        if (typeof window.gisLoaded === 'function') {
                            console.log('🔄 Chamando gisLoaded...');
                            window.gisLoaded();
                        }
                    } else {
                        throw new Error('Google Identity Services não ficou disponível após carregamento');
                    }
                }
                
                console.log('🎉 Todas as APIs Google carregadas e inicializadas com sucesso!');
                
                // Remover aviso se existir
                const avisoElement = document.querySelector('.api-loading-warning');
                if (avisoElement) {
                    avisoElement.remove();
                }
                
            } catch (error) {
                console.error('❌ Erro ao carregar APIs Google:', error);
                
                // Mostrar mensagem de erro para o usuário
                const errorDiv = document.createElement('div');
                errorDiv.className = 'api-loading-error';
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #dc3545;
                    color: white;
                    padding: 15px;
                    border-radius: 8px;
                    z-index: 9999;
                    max-width: 350px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    font-family: Arial, sans-serif;
                `;
                errorDiv.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 18px; margin-right: 8px;">⚠️</span>
                        <strong>Erro de Conectividade</strong>
                    </div>
                    <div style="font-size: 14px; line-height: 1.4;">
                        Não foi possível carregar as APIs do Google.<br>
                        <small style="opacity: 0.9;">
                            • Verifique sua conexão com a internet<br>
                            • Tente recarregar a página<br>
                            • Verifique se não há bloqueios de firewall
                        </small>
                    </div>
                    <button onclick="location.reload()" style="
                        background: rgba(255,255,255,0.2);
                        border: 1px solid rgba(255,255,255,0.3);
                        color: white;
                        padding: 6px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                        margin-top: 10px;
                        font-size: 12px;
                    ">🔄 Recarregar Página</button>
                `;
                document.body.appendChild(errorDiv);
                
                // Remover mensagem após 15 segundos
                setTimeout(async () => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 15000);
            }
        }
        
        // Mostrar aviso de carregamento
        const avisoDiv = document.createElement('div');
        avisoDiv.className = 'api-loading-warning';
        avisoDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ffc107;
            color: #856404;
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 9999;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        `;
        avisoDiv.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 16px; margin-right: 8px;">⏳</span>
                <span>Carregando APIs do Google...</span>
            </div>
        `;
        document.body.appendChild(avisoDiv);
        
        // Iniciar carregamento após 2 segundos
        setTimeout(inicializarAPIs, 2000);
    });
    
        /**
         * Reconecta uma conta específica
         */
        window.reconnectAccount = function(email) {
            console.log('🔄 Reconectando conta:', email);
            
            // Encontrar a conta
            const account = window.connectedAccounts.find(acc => acc.email === email);
            if (!account) {
                console.error('❌ Conta não encontrada:', email);
                return;
            }
            
            // Marcar como reconectando
            updateAccountStatus(email, 'connecting');
            
            // Limpar token anterior
            if (gapi && gapi.client) {
                gapi.client.setToken(null);
            }
            
            // Definir que estamos reconectando esta conta específica
            currentAuthAccount = email;
            
            // Solicitar nova autenticação
            try {
                if (!tokenClient) {
                    console.error('❌ tokenClient não inicializado');
                    updateAccountStatus(email, 'error');
                    if (typeof showMessage === 'function') {
                        showMessage(`Erro: Sistema de autenticação não inicializado`, 'error');
                    } else {
                        alert(`Erro: Sistema de autenticação não inicializado`);
                    }
                    return;
                }
                
                tokenClient.requestAccessToken({ 
                    prompt: 'select_account consent',
                    include_granted_scopes: true,
                    login_hint: email // Sugerir o email específico
                });
            } catch (error) {
                console.error('❌ Erro ao reconectar:', error);
                updateAccountStatus(email, 'error');
                if (typeof showMessage === 'function') {
                    showMessage(`Erro ao reconectar ${email}`, 'error');
                } else {
                    alert(`Erro ao reconectar ${email}`);
                }
            }
        };

        /**
         * Desconecta todas as contas e limpa completamente o estado
         */
        window.disconnectAllAccounts = async function() {
            console.log('🔄 Desconectando todas as contas...');
            
            try {
                // 1. Limpar array de contas
                if (window.connectedAccounts) {
                    window.connectedAccounts = [];
                }
                
                // 2. Limpar localStorage
                localStorage.removeItem('connectedAccounts');
                localStorage.removeItem('googleConnected');
                
                // 3. Limpar tokens do gapi
                if (gapi && gapi.client) {
                    gapi.client.setToken(null);
                }
                
                // 4. Tentar revogar tokens (se possível)
                if (window.google && window.google.accounts && window.google.accounts.oauth2) {
                    try {
                        // Não há método direto, mas limpar estado
                        console.log('🔄 Limpando estado OAuth2...');
                    } catch (e) {
                        console.log('⚠️ Aviso ao limpar OAuth2:', e.message);
                    }
                }
                
                // 5. Atualizar interface
                if (typeof updateAccountsDisplay === 'function') {
                    updateAccountsDisplay();
                }
                
                // 6. Resetar variáveis globais
                isGoogleConnected = false;
                
                console.log('✅ Todas as contas desconectadas com sucesso');
                showMessage('Todas as contas foram desconectadas. Agora você pode conectar contas novas.', 'success');
                
                // 7. Recarregar página para garantir estado limpo
                setTimeout(async () => {
                    if (confirm('Deseja recarregar a página para garantir limpeza completa?')) {
                        location.reload();
                    }
                }, 2000);
                
            } catch (error) {
                console.error('❌ Erro ao desconectar contas:', error);
                showMessage('Erro ao desconectar contas. Recarregue a página.', 'error');
            }
        };

        /**
         * Método alternativo usando iframe para isolamento completo
         */
        window.addNewAccountIframe = function() {
            console.log('🔄 Método alternativo: usando iframe...');
            
            // Criar iframe oculto
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = 'about:blank';
            document.body.appendChild(iframe);
            
            // Aguardar iframe carregar
            iframe.onload = function() {
                console.log('✅ Iframe carregado');
                
                // Criar script no iframe
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const script = iframeDoc.createElement('script');
                script.src = 'https://apis.google.com/js/api.js';
                
                script.onload = function() {
                    console.log('✅ GAPI carregado no iframe');
                    
                    // Inicializar GAPI no iframe
                    const iframeGapi = iframe.contentWindow.gapi;
                    
                    iframeGapi.load('auth2', function() {
                        const auth2 = iframeGapi.auth2.init({
                            client_id: CLIENT_ID,
                            scope: SCOPES
                        });
                        
                        // Fazer logout primeiro
                        if (auth2.isSignedIn.get()) {
                            auth2.signOut().then(function() {
                                console.log('✅ Logout realizado no iframe');
                                
                                // Agora fazer login com nova conta
                                auth2.signIn({
                                    prompt: 'select_account consent'
                                }).then(function(googleUser) {
                                    const authResponse = googleUser.getAuthResponse();
                                    console.log('✅ Nova autenticação obtida:', authResponse.access_token.substring(0, 20) + '...');
                                    
                                    // Processar token
                                    handleTokenResponse({
                                        access_token: authResponse.access_token,
                                        token_type: 'Bearer',
                                        expires_in: authResponse.expires_in
                                    });
                                    
                                    // Remover iframe
                                    document.body.removeChild(iframe);
                                    
                                }).catch(function(error) {
                                    console.error('❌ Erro na autenticação iframe:', error);
                                    document.body.removeChild(iframe);
                                });
                            });
                        } else {
                            // Fazer login direto
                            auth2.signIn({
                                prompt: 'select_account consent'
                            }).then(function(googleUser) {
                                const authResponse = googleUser.getAuthResponse();
                                console.log('✅ Autenticação obtida:', authResponse.access_token.substring(0, 20) + '...');
                                
                                handleTokenResponse({
                                    access_token: authResponse.access_token,
                                    token_type: 'Bearer',
                                    expires_in: authResponse.expires_in
                                });
                                
                                document.body.removeChild(iframe);
                                
                            }).catch(function(error) {
                                console.error('❌ Erro na autenticação iframe:', error);
                                document.body.removeChild(iframe);
                            });
                        }
                    });
                };
                
                iframeDoc.head.appendChild(script);
            };
        };

        /**
         * Mostra todas as seções da interface após conexão bem-sucedida
         */
        function showAllSections() {
            console.log('🔄 Mostrando todas as seções da interface...');
            
            // Lista de IDs de seções que devem aparecer
            const sectionIds = [
                'calendarSection',
                'monthlySummarySection',
                'paymentsListSection',
                'receivingsListSection',
                'paymentsList',
                'receivingsList'
            ];
            
            sectionIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.style.display = 'block';
                    console.log(`✅ Seção ${id} mostrada`);
                } else {
                    console.log(`⚠️ Seção ${id} não encontrada`);
                }
            });
            
            // Mostrar elementos por classe também
            const classNames = [
                'calendar-section',
                'monthly-summary-container',
                'payments-list-section',
                'receivings-list-section'
            ];
            
            classNames.forEach(className => {
                const elements = document.getElementsByClassName(className);
                for (let i = 0; i < elements.length; i++) {
                    elements[i].style.display = 'block';
                    console.log(`✅ Elemento da classe ${className} mostrado`);
                }
            });
            
            // Forçar reflow da página
            document.body.offsetHeight;
            
            console.log('✅ Todas as seções foram processadas');
        }
        
        /**
         * Força atualização completa da interface
         */
        function forceInterfaceUpdate() {
            console.log('🔄 Forçando atualização completa da interface...');
            
            // Mostrar seções
            showAllSections();
            
            // Aguardar um pouco e tentar renderizar componentes
            setTimeout(async () => {
                console.log('🔄 Tentando renderizar componentes...');
                
                // Tentar renderizar calendário
                if (typeof renderCalendar === 'function') {
                    try {
                        renderCalendar();
                        console.log('✅ Calendário renderizado');
                    } catch (e) {
                        console.error('❌ Erro ao renderizar calendário:', e);
                    }
                }
                
                // Tentar atualizar listas
                if (typeof updateEventsList === 'function') {
                    try {
                        updateEventsList();
                        console.log('✅ Lista de eventos atualizada');
                    } catch (e) {
                        console.error('❌ Erro ao atualizar lista de eventos:', e);
                    }
                }
                
                // Tentar inicializar Google Calendar se não estiver
                if (typeof initializeGoogleCalendar === 'function') {
                    try {
                        initializeGoogleCalendar();
                        console.log('✅ Google Calendar inicializado');
                    } catch (e) {
                        console.error('❌ Erro ao inicializar Google Calendar:', e);
                    }
                }
                
                // Recarregar página como último recurso (opcional)
                // setTimeout(async () => {
                //     if (confirm('Interface não atualizou completamente. Deseja recarregar a página?')) {
                //         location.reload();
                //     }
                // }, 5000);
                
            }, 1000);
        }
        
        // Disponibilizar globalmente
        window.showAllSections = showAllSections;
        window.forceInterfaceUpdate = forceInterfaceUpdate;
</script>

    <!-- Modais para gerenciamento -->
    <div id="manageListModal" class="manage-list-modal">
        <div class="manage-list-modal-content">
            <div class="manage-list-modal-header">
                <h3 id="manageListTitle">Gerenciar Lista</h3>
                <button class="close-modal-btn" onclick="closeManageListModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <!-- Botão Nova Medição (condicional) -->
            <div id="novaMedicaoSection" style="display: none; padding: 15px; background: rgba(76, 175, 80, 0.1); border-radius: 8px; margin-bottom: 15px;">
                <button class="btn-primary" onclick="abrirNovaMedicaoDoFluxoCaixa()" style="width: 100%; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fas fa-plus"></i>
                    Nova Medição
                </button>
                <p style="margin: 10px 0 0 0; font-size: 12px; color: #b0c4de; text-align: center;">
                    Criar nova medição para esta obra
                </p>
            </div>
            
            <div class="add-list-item-section">
                <div class="add-list-item-form">
                    <input type="text" id="newListItemInput" placeholder="Digite o nome do novo item..." onkeypress="if(event.key==='Enter') addItemToManageList()">
                    <button class="add-list-item-btn" onclick="addItemToManageList()">
                        <i class="fas fa-plus"></i> Adicionar
                    </button>
                </div>
            </div>
            <div class="manage-list-search">
                <input type="text" id="manageListSearch" placeholder="🔍 Buscar..." oninput="filterManageListItems()">
            </div>
            <div class="manage-list-items-container" id="manageListItems"></div>
        </div>
    </div>

    <div id="editItemModal" class="edit-item-modal">
        <div class="edit-item-modal-content">
            <div class="manage-list-modal-header">
                <h3><i class="fas fa-edit"></i> Editar Item</h3>
                <button class="close-modal-btn" onclick="closeEditItemModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Tipo</label>
                        <select id="editItemTipo" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="">Nenhum</option>
                            <option value="INTERNO">INTERNO</option>
                            <option value="EXTERNO">EXTERNO</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Subtipo</label>
                        <select id="editItemSubtipo" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="">Nenhum</option>
                            <option value="OBRA">OBRA</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Categoria</label>
                        <select id="editItemCategoria" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="">Nenhum</option>
                        </select>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 15px;">
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Nome *</label>
                        <input type="text" id="editItemNome" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                    </div>
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Valor *</label>
                        <input type="text" id="editItemValor" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 15px;">
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Status *</label>
                        <select id="editItemStatus" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                            <option value="">Selecione...</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #fff; display: block; margin-bottom: 5px;">Detalhe</label>
                        <input type="text" id="editItemDetalhe" style="width: 100%; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);">
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <button class="cancel-edit-btn" onclick="closeEditItemModal()">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                    <button class="save-edit-btn" onclick="saveEditedItem()">
                        <i class="fas fa-save"></i> Salvar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // SISTEMA DE GERENCIAMENTO DE LISTAS PERSONALIZADAS
        // ============================================================================

        // ============================================
        // MAPEAMENTO DE TABELAS DO SUPABASE
        // ============================================
        const SUPABASE_TABLES = {
            // PAGAMENTO - INTERNO
            'pagamento_interno_subtipos': 'custom_subtipos_pagamento_interno',
            'pagamento_interno_categorias': 'custom_categorias_pagamento_interno',
            
            // PAGAMENTO - EXTERNO
            'pagamento_externo_subtipos': 'custom_subtipos_pagamento_externo',
            'pagamento_externo_categorias': 'custom_categorias_pagamento_externo',
            
            // RECEBIMENTO - OUTROS
            'recebimento_outros_subtipos': 'custom_subtipos_recebimento_outros',
            'recebimento_outros_categorias': 'custom_categorias_recebimento_outros',
            
            // Compatibilidade com código antigo (será removido)
            'subtipos': 'custom_subtipos_pagamento_interno',
            'categorias': 'custom_categorias_pagamento_interno',
            'recebimento_outros_subtipos': 'custom_subtipos_recebimento_outros',
            'recebimento_outros_categorias': 'custom_categorias_recebimento_outros',
            'hvc_subtipos_pagamento': 'custom_subtipos_pagamento_interno',
            'hvc_categorias_pagamento': 'custom_categorias_pagamento_interno'
        };

        // ============================================
        // FUNÇÃO AUXILIAR: Carregar lista específica do Supabase
        // ============================================
        
        async function loadListFromSupabase(key) {
            try {
                const tableName = SUPABASE_TABLES[key];
                if (!tableName) {
                    console.error('Tabela não encontrada para:', key);
                    return [];
                }
                
                const { data, error } = await supabase
                    .from(tableName)
                    .select('nome')
                    .order('nome', { ascending: true });
                
                if (error) throw error;
                
                return data ? data.map(item => item.nome) : [];
            } catch (error) {
                console.error(`Erro ao carregar lista ${key}:`, error);
                return [];
            }
        }



        // ============================================
        // FUNÇÕES PARA CARREGAR LISTAS DO SUPABASE
        // ============================================
        
        async function loadCustomLists() {
            try {
                // Se currentManagingList é uma chave específica
                if (currentManagingList && currentManagingList.includes('_')) {
                    const tableName = SUPABASE_TABLES[currentManagingList];
                    if (!tableName) {
                        console.error('Tabela não encontrada para:', currentManagingList);
                        return { [currentManagingList]: [] };
                    }
                    
                    const { data, error } = await supabase
                        .from(tableName)
                        .select('nome')
                        .order('nome', { ascending: true });
                    
                    if (error) throw error;
                    
                    const items = data ? data.map(item => item.nome) : [];
                    return { [currentManagingList]: items };
                }
                
                // Senão carregar subtipos e categorias de PAGAMENTO
                const [subtiposResult, categoriasResult] = await Promise.all([
                    supabase.from('custom_subtipos_pagamento').select('nome').order('nome', { ascending: true }),
                    supabase.from('custom_categorias_pagamento').select('nome').order('nome', { ascending: true })
                ]);
                
                if (subtiposResult.error) throw subtiposResult.error;
                if (categoriasResult.error) throw categoriasResult.error;
                
                return {
                    subtipos: subtiposResult.data ? subtiposResult.data.map(item => item.nome) : [],
                    categorias: categoriasResult.data ? categoriasResult.data.map(item => item.nome) : []
                };
            } catch (error) {
                console.error('Erro ao carregar listas do Supabase:', error);
                return currentManagingList && currentManagingList.includes('_') 
                    ? { [currentManagingList]: [] }
                    : { subtipos: [], categorias: [] };
            }
        }

        // ============================================
        // FUNÇÕES PARA ADICIONAR ITENS NO SUPABASE
        // ============================================
        
        async function addToList(listType, value) {
            if (!value || value.trim() === '') return false;
            
            try {
                const tableName = SUPABASE_TABLES[listType];
                if (!tableName) {
                    console.error('Tabela não encontrada para:', listType);
                    return false;
                }
                
                // Verificar se já existe
                const { data: existing, error: checkError } = await supabase
                    .from(tableName)
                    .select('id')
                    .eq('nome', value.trim())
                    .maybeSingle();
                
                if (checkError && checkError.code !== 'PGRST116') {
                    throw checkError;
                }
                
                if (existing) {
                    console.warn('Item já existe:', value);
                    return false;
                }
                
                // Inserir novo item
                const { error: insertError } = await supabase
                    .from(tableName)
                    .insert({ nome: value.trim() });
                
                if (insertError) throw insertError;
                
                console.log('Item adicionado com sucesso:', value);
                return true;
            } catch (error) {
                console.error('Erro ao adicionar item:', error);
                alert('Erro ao adicionar item: ' + error.message);
                return false;
            }
        }

        // ============================================
        // FUNÇÕES PARA REMOVER ITENS DO SUPABASE
        // ============================================
        
        async function removeFromList(listType, value) {
            if (!value) return false;
            
            try {
                const tableName = SUPABASE_TABLES[listType];
                if (!tableName) {
                    console.error('Tabela não encontrada para:', listType);
                    return false;
                }
                
                // Remover item
                const { error } = await supabase
                    .from(tableName)
                    .delete()
                    .eq('nome', value);
                
                if (error) throw error;
                
                console.log('Item removido com sucesso:', value);
                return true;
            } catch (error) {
                console.error('Erro ao remover item:', error);
                alert('Erro ao remover item: ' + error.message);
                return false;
            }
        }

        // ============================================
        // FUNÇÃO AUXILIAR: Salvar listas (deprecated, mantida para compatibilidade)
        // ============================================
        
        function saveCustomLists(subtipos, categorias) {
            // Esta função não é mais necessária com Supabase
            // Mantida apenas para compatibilidade com código legado
            console.warn('saveCustomLists() está deprecated. Use addToList() para adicionar itens.');
        }



        async function populateSubtipoSelect() {
            const select = document.getElementById('itemSubtipo');
            if (!select) return;
            const lists = await loadCustomLists();
            const currentValue = select.value;
            select.innerHTML = '<option value="">Nenhum</option><option value="OBRA">OBRA</option>';
            lists.subtipos.forEach(subtipo => {
                const option = document.createElement('option');
                option.value = subtipo;
                option.textContent = subtipo;
                select.appendChild(option);
            });
            if (currentValue) select.value = currentValue;
        }

        async function populateCategoriaSelect() {
            const select = document.getElementById('itemCategoria');
            if (!select) return;
            const lists = await loadCustomLists();
            const currentValue = select.value;
            select.innerHTML = '<option value="">Nenhum</option>';
            lists.categorias.forEach(categoria => {
                const option = document.createElement('option');
                option.value = categoria;
                option.textContent = categoria;
                select.appendChild(option);
            });
            if (currentValue) select.value = currentValue;
        }

        async function populateCategoriaWithObras() {
            const select = document.getElementById('itemCategoria');
            if (!select) return;
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Erro ao carregar obras:', error);
                    select.innerHTML = '<option value="">Nenhuma obra encontrada</option>';
                    return;
                }
                
                select.innerHTML = '<option value="">Selecione uma obra...</option>';
                
                if (!obras || obras.length === 0) {
                    select.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    return;
                }
                
                obras.forEach(obra => {
                    const option = document.createElement('option');
                    // Usar numero_obra se existir, senão usar id
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    option.value = obraName;
                    option.textContent = obraName;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
                select.innerHTML = '<option value="">Erro ao carregar obras</option>';
            }
        }

        async function onSubtipoChange() {
            const subtipo = document.getElementById('itemSubtipo').value;
            const manageCategoriaBtn = document.getElementById('manageCategoriaBtn');
            if (subtipo === 'OBRA') {
                await populateCategoriaWithObras();
                if (manageCategoriaBtn) {
                    manageCategoriaBtn.disabled = true;
                    manageCategoriaBtn.style.opacity = '0.5';
                }
            } else {
                populateCategoriaSelect();
                if (manageCategoriaBtn) {
                    manageCategoriaBtn.disabled = false;
                    manageCategoriaBtn.style.opacity = '1';
                }
            }
        }

        // Modal de gerenciamento
        let currentManagingList = null;
        let currentManagingCallback = null;

        function openManageListModal(listType, customTitle, callback) {
            // Verificar se deve mostrar botão Nova Medição
            checkAndShowNovaMedicaoButton(listType);
            currentManagingList = listType;
            currentManagingCallback = callback || null;
            const modal = document.getElementById('manageListModal');
            const title = document.getElementById('manageListTitle');
            // Usar título personalizado se fornecido, senão usar padrão
            if (customTitle) {
                title.textContent = customTitle;
            } else {
                title.textContent = listType === 'subtipos' ? 'Gerenciar Subtipos' : 'Gerenciar Categorias';
            }
            refreshManageListItems();
            modal.style.display = 'flex';
        }

        function closeManageListModal() {
            document.getElementById('manageListModal').style.display = 'none';
            
            // Chamar callback se existir
            if (currentManagingCallback && typeof currentManagingCallback === 'function') {
                currentManagingCallback();
            }
            
            currentManagingList = null;
            currentManagingCallback = null;
        }

        async function refreshManageListItems() {
            const listContainer = document.getElementById('manageListItems');
            const lists = await loadCustomLists();
            const items = lists[currentManagingList] || [];
            if (items.length === 0) {
                listContainer.innerHTML = '<p style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">Nenhum item na lista</p>';
                return;
            }
            listContainer.innerHTML = items.map(item => `
                <div class="manage-list-item">
                    <span>${item}</span>
                    <button onclick="removeItemFromManageList('${item.replace(/'/g, "'")}');" class="remove-list-item-btn">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function addItemToManageList() {
            const input = document.getElementById('newListItemInput');
            const value = input.value.trim();
            if (!value) {
                alert('Digite um valor para adicionar');
                return;
            }
            if (addToList(currentManagingList, value)) {
                input.value = '';
                refreshManageListItems();
            } else {
                alert('Este item já existe na lista');
            }
        }

        function removeItemFromManageList(value) {
            if (confirm(`Tem certeza que deseja remover "${value}"?`)) {
                removeFromList(currentManagingList, value);
                refreshManageListItems();
            }
        }

        function filterManageListItems() {
            const searchInput = document.getElementById('manageListSearch');
            const filter = searchInput.value.toLowerCase();
            const items = document.querySelectorAll('.manage-list-item');
            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(filter) ? 'flex' : 'none';
            });
        }

        // Modal de edição
        let currentEditingItem = null;

        function openEditItemModal(itemId) {
            const item = window.paymentItems.find(i => i.id === itemId);
            if (!item) return;
            currentEditingItem = item;
            document.getElementById('editItemTipo').value = item.tipo || '';
            document.getElementById('editItemSubtipo').value = item.subtipo || '';
            document.getElementById('editItemCategoria').value = item.categoria || '';
            document.getElementById('editItemNome').value = item.nome || '';
            document.getElementById('editItemValor').value = formatCurrency(item.valor);
            document.getElementById('editItemStatus').value = item.status || '';
            document.getElementById('editItemDetalhe').value = item.detalhe || '';
            populateEditSelects();
            if (item.subtipo === 'OBRA') {
                populateEditCategoriaWithObras();
            }
            document.getElementById('editItemModal').style.display = 'flex';
        }

        function closeEditItemModal() {
            document.getElementById('editItemModal').style.display = 'none';
            currentEditingItem = null;
        }

        async function populateEditSelects() {
            const lists = await loadCustomLists();
            const subtipoSelect = document.getElementById('editItemSubtipo');
            subtipoSelect.innerHTML = '<option value="">Nenhum</option><option value="OBRA">OBRA</option>';
            lists.subtipos.forEach(subtipo => {
                const option = document.createElement('option');
                option.value = subtipo;
                option.textContent = subtipo;
                subtipoSelect.appendChild(option);
            });
            const categoriaSelect = document.getElementById('editItemCategoria');
            categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            lists.categorias.forEach(categoria => {
                const option = document.createElement('option');
                option.value = categoria;
                option.textContent = categoria;
                categoriaSelect.appendChild(option);
            });
        }

        async function populateEditCategoriaWithObras() {
            const select = document.getElementById('editItemCategoria');
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Erro ao carregar obras:', error);
                    select.innerHTML = '<option value="">Nenhuma obra encontrada</option>';
                    return;
                }
                
                select.innerHTML = '<option value="">Selecione uma obra...</option>';
                
                if (!obras || obras.length === 0) {
                    select.innerHTML = '<option value="">Nenhuma obra cadastrada</option>';
                    return;
                }
                
                obras.forEach(obra => {
                    const option = document.createElement('option');
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    option.value = obraName;
                    option.textContent = obraName;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
                select.innerHTML = '<option value="">Erro ao carregar obras</option>';
            }
        }

        async function onEditSubtipoChange() {
            const subtipo = document.getElementById('editItemSubtipo').value;
            if (subtipo === 'OBRA') {
                await populateEditCategoriaWithObras();
            } else {
                populateEditSelects();
            }
        }

        function saveEditedItem() {
            if (!currentEditingItem) return;
            const tipo = document.getElementById('editItemTipo').value;
            const subtipo = document.getElementById('editItemSubtipo').value;
            const categoria = document.getElementById('editItemCategoria').value;
            const nome = document.getElementById('editItemNome').value.trim();
            const valorText = document.getElementById('editItemValor').value;
            const valor = parseFloat(valorText.replace(/[^\d,]/g, '').replace(',', '.'));
            const status = document.getElementById('editItemStatus').value;
            const detalhe = document.getElementById('editItemDetalhe').value.trim();
            if (!nome) {
                alert('Nome é obrigatório');
                return;
            }
            if (!valor || valor <= 0) {
                alert('Valor deve ser maior que zero');
                return;
            }
            if (!status) {
                alert('Status é obrigatório');
                return;
            }
            currentEditingItem.tipo = tipo;
            currentEditingItem.subtipo = subtipo;
            currentEditingItem.categoria = categoria;
            currentEditingItem.nome = nome;
            currentEditingItem.valor = valor;
            currentEditingItem.status = status;
            currentEditingItem.detalhe = detalhe;
            renderPaymentItems();
            closeEditItemModal();
        }

        // Inicialização
        document.addEventListener('DOMContentLoaded', function() {
            populateSubtipoSelect();
            populateCategoriaSelect();
            const subtipoSelect = document.getElementById('itemSubtipo');
            if (subtipoSelect) {
                subtipoSelect.addEventListener('change', onSubtipoChange);
            }
            const editSubtipoSelect = document.getElementById('editItemSubtipo');
            if (editSubtipoSelect) {
                editSubtipoSelect.addEventListener('change', onEditSubtipoChange);
            }
            const editItemValorInput = document.getElementById('editItemValor');
            if (editItemValorInput) {
                editItemValorInput.addEventListener('input', function(e) {
                    let value = e.target.value.replace(/\D/g, '');
                    if (value === '') {
                        e.target.value = '';
                        return;
                    }
                    const numValue = parseInt(value) / 100;
                    e.target.value = formatCurrency(numValue);
                });
            }
        });

        // Função para renderizar campos TIPO, SUBTIPO e CATEGORIA na edição do modal
        window.renderEditFieldsBasedOnEventType = function(eventType, itemData) {
            const tipoInput = document.querySelector('#editItemForm input[placeholder*="Tipo"]')?.closest('.form-group');
            const subtipoInput = document.querySelector('#editItemForm input[placeholder*="Subtipo"]')?.closest('.form-group');
            const categoriaInput = document.querySelector('#editItemForm input[placeholder*="Categoria"]')?.closest('.form-group');
            
            if (!tipoInput || !subtipoInput || !categoriaInput) return;
            
            if (eventType === 'pagamento') {
                // PAGAMENTO: mesma lógica atual
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control">
                        <option value="">Nenhum</option>
                        <option value="INTERNO" ${itemData.tipo === 'INTERNO' ? 'selected' : ''}>INTERNO</option>
                        <option value="EXTERNO" ${itemData.tipo === 'EXTERNO' ? 'selected' : ''}>EXTERNO</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaBasedOnSubtipo()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" onclick="openManageListModal(\'subtipos\'); setTimeout(() => populateEditSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria" onclick="openManageListModal(\'categorias\'); setTimeout(() => updateEditCategoriaBasedOnSubtipo(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    populateEditSubtipo();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaBasedOnSubtipo();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
                
            } else if (eventType === 'recebimento') {
                // RECEBIMENTO: nova lógica
                tipoInput.innerHTML = `
                    <label>TIPO:</label>
                    <select id="edit-tipo" class="form-control" onchange="updateEditSubtipoForReceiving()">
                        <option value="">Nenhum</option>
                        <option value="OBRAS" ${itemData.tipo === 'OBRAS' ? 'selected' : ''}>OBRAS</option>
                        <option value="OUTROS" ${itemData.tipo === 'OUTROS' ? 'selected' : ''}>OUTROS</option>
                    </select>
                `;
                
                subtipoInput.innerHTML = `
                    <label>SUBTIPO:</label>
                    <div class="field-with-manage">
                        <select id="edit-subtipo" class="form-control" onchange="updateEditCategoriaForReceiving()">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-subtipo-rec" onclick="openManageSubtiposRecModal(); setTimeout(() => updateEditSubtipoForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                categoriaInput.innerHTML = `
                    <label>CATEGORIA:</label>
                    <div class="field-with-manage">
                        <select id="edit-categoria" class="form-control">
                            <option value="">Nenhum</option>
                        </select>
                        <button type="button" class="btn-manage-list-small" id="btn-manage-edit-categoria-rec" onclick="openManageCategoriasRecModal(); setTimeout(() => updateEditCategoriaForReceiving(), 500);">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                `;
                
                // Popular campos
                setTimeout(async () => {
                    updateEditSubtipoForReceiving();
                    setTimeout(async () => {
                        if (itemData.subtipo) {
                            document.getElementById('edit-subtipo').value = itemData.subtipo;
                            updateEditCategoriaForReceiving();
                            setTimeout(async () => {
                                if (itemData.categoria) {
                                    document.getElementById('edit-categoria').value = itemData.categoria;
                                }
                            }, 300);
                        }
                    }, 200);
                }, 100);
            }
        };
        
        // Funções auxiliares para edição (RECEBIMENTO)
        window.updateEditSubtipoForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const btnManage = document.getElementById('btn-manage-edit-subtipo-rec');
            
            if (!tipoSelect || !subtipoSelect) return;
            
            const tipo = tipoSelect.value;
            
            if (tipo === 'OBRAS') {
                subtipoSelect.innerHTML = '<option value="">Carregando obras...</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
                
                try {
                    const { data: obras, error } = await supabase
                        .from('obras_hvc')
                        .select('*')
                        .order('created_at', { ascending: false });
                    
                    if (error) throw error;
                    
                    subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                    
                    if (obras && obras.length > 0) {
                        obras.forEach(obra => {
                            const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                            subtipoSelect.innerHTML += `<option value="${obraName}" data-obra-id="${obra.id}">${obraName}</option>`;
                        });
                    }
                } catch (error) {
                    console.error('Erro:', error);
                    subtipoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                }
            } else if (tipo === 'OUTROS') {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customSubtipos = await loadListFromSupabase('recebimento_outros_subtipos');
                customSubtipos.forEach(st => {
                    subtipoSelect.innerHTML += `<option value="${st}">${st}</option>`;
                });
            } else {
                subtipoSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                }
            }
            
            // Limpar categoria
            const categoriaSelect = document.getElementById('edit-categoria');
            if (categoriaSelect) {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
            }
        };
        
        window.updateEditCategoriaForReceiving = async function() {
            const tipoSelect = document.getElementById('edit-tipo');
            const subtipoSelect = document.getElementById('edit-subtipo');
            const categoriaSelect = document.getElementById('edit-categoria');
            const btnManage = document.getElementById('btn-manage-edit-categoria-rec');
            
            if (!tipoSelect || !subtipoSelect || !categoriaSelect) return;
            
            const tipo = tipoSelect.value;
            const subtipo = subtipoSelect.value;
            
            if (tipo === 'OBRAS' && subtipo) {
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                const obraId = selectedOption.getAttribute('data-obra-id');
                
                if (obraId) {
                    categoriaSelect.innerHTML = '<option value="">Carregando medições...</option>';
                    if (btnManage) {
                        btnManage.disabled = true;
                        btnManage.style.opacity = '0.5';
                        btnManage.style.pointerEvents = 'none';
                        btnManage.style.cursor = 'not-allowed';
                    }
                    
                    try {
                        const { data: medicoes, error } = await supabase
                            .from('medicoes_hvc')
                            .select('*')
                            .eq('obra_id', obraId)
                            .order('created_at', { ascending: false });
                        
                        if (error) throw error;
                        
                        categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                        
                        if (medicoes && medicoes.length > 0) {
                            medicoes.forEach(medicao => {
                                const medicaoName = medicao.numero_medicao || `Medição ${medicao.id}`;
                                categoriaSelect.innerHTML += `<option value="${medicaoName}">${medicaoName}</option>`;
                            });
                        }
                    } catch (error) {
                        console.error('Erro:', error);
                        categoriaSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                    }
                }
            } else if (tipo === 'OUTROS') {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = false;
                    btnManage.style.opacity = '1';
                    btnManage.style.pointerEvents = 'auto';
                    btnManage.style.cursor = 'pointer';
                }
                
                const customCategorias = await loadListFromSupabase('recebimento_outros_categorias');
                customCategorias.forEach(cat => {
                    categoriaSelect.innerHTML += `<option value="${cat}">${cat}</option>`;
                });
            } else {
                categoriaSelect.innerHTML = '<option value="">Nenhum</option>';
                if (btnManage) {
                    btnManage.disabled = true;
                    btnManage.style.opacity = '0.5';
                    btnManage.style.pointerEvents = 'none';
                    btnManage.style.cursor = 'not-allowed';
                }
            }
        };


        // ===================================================================
        // INTEGRAÇÃO COM SISTEMA DE MEDIÇÕES
        // ===================================================================
        
        // Variável global para armazenar obra selecionada
        window.obraIdSelecionadaFluxoCaixa = null;
        
        // Função para verificar se deve mostrar botão Nova Medição
        function checkAndShowNovaMedicaoButton(listType) {
            const novaMedicaoSection = document.getElementById('novaMedicaoSection');
            
            if (!novaMedicaoSection) return;
            
            // Verificar condições:
            // 1. Tipo de evento = RECEBIMENTO
            // 2. TIPO = OBRAS
            // 3. SUBTIPO = uma obra selecionada
            // 4. listType = 'recebimento_outros_categorias' (gerenciando categorias de recebimento)
            
            const eventTypeRadio = document.querySelector('input[name="eventType"]:checked');
            const tipoSelect = document.getElementById('itemTipo');
            const subtipoSelect = document.getElementById('itemSubtipo');
            
            const isRecebimento = eventTypeRadio && eventTypeRadio.value === 'RECEBIMENTO';
            const isTipoObras = tipoSelect && tipoSelect.value === 'OBRAS';
            const obraSelecionada = subtipoSelect && subtipoSelect.value !== '';
            const isCategoriasRec = listType === 'recebimento_outros_categorias';
            
            // Mostrar botão apenas se todas as condições forem atendidas
            if (isRecebimento && isTipoObras && obraSelecionada && isCategoriasRec) {
                novaMedicaoSection.style.display = 'block';
                
                // Armazenar obra_id para uso posterior
                const selectedOption = subtipoSelect.options[subtipoSelect.selectedIndex];
                window.obraIdSelecionadaFluxoCaixa = selectedOption.getAttribute('data-obra-id');
                
                console.log('✅ Botão Nova Medição habilitado para obra:', window.obraIdSelecionadaFluxoCaixa);
            } else {
                novaMedicaoSection.style.display = 'none';
                window.obraIdSelecionadaFluxoCaixa = null;
            }
        }
        
        
        // ===================================================================
        
        // Variáveis globais para medições
        window.obraSelecionadaMedicaoInline = null;
        window.obraIdMedicaoInline = null;
        
        // Função para abrir modal de Nova Medição do fluxo de caixa
        async function abrirNovaMedicaoDoFluxoCaixa() {
            console.log('🚀 Abrindo modal de Nova Medição inline...');
            
            // Fechar modal de gerenciar listas
            closeManageListModal();
            
            // Abrir modal inline
            await abrirModalMedicaoInline();
        }
        
        // Abrir modal de medição inline
        async function abrirModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (!modal) return;
            
            // Limpar formulário
            document.getElementById('data-medicao-inline').value = new Date().toISOString().split('T')[0];
            
            const dataFutura = new Date();
            dataFutura.setDate(dataFutura.getDate() + 30);
            document.getElementById('data-recebimento-inline').value = dataFutura.toISOString().split('T')[0];
            
            document.getElementById('valor-medicao-inline').value = '';
            document.getElementById('status-medicao-inline').value = 'pendente';
            document.getElementById('observacoes-medicao-inline').value = '';
            
            // Resetar obra selecionada
            window.obraSelecionadaMedicaoInline = null;
            window.obraIdMedicaoInline = window.obraIdSelecionadaFluxoCaixa;
            
            // Se já tem obra selecionada do fluxo de caixa, pré-selecionar
            if (window.obraIdSelecionadaFluxoCaixa) {
                await preSelecionarObraNoModal(window.obraIdSelecionadaFluxoCaixa);
            } else {
                const container = document.getElementById('obra-selecionada-container-inline');
                if (container) {
                    container.innerHTML = `
                        <button type="button" class="btn-secondary" onclick="abrirModalObrasInline()" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            <i class="fas fa-building"></i>
                            Selecionar Obra
                        </button>
                    `;
                }
            }
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Pré-selecionar obra no modal
        async function preSelecionarObraNoModal(obraId) {
            try {
                const { data: obra, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .eq('id', obraId)
                    .single();
                
                if (error) throw error;
                
                if (obra) {
                    window.obraSelecionadaMedicaoInline = obra;
                    window.obraIdMedicaoInline = obra.id;
                    
                    const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                    const container = document.getElementById('obra-selecionada-container-inline');
                    if (container) {
                        container.innerHTML = `
                            <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="color: #4CAF50;">${obraName}</strong>
                                </div>
                                <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                                    Trocar
                                </button>
                            </div>
                        `;
                    }
                }
            } catch (error) {
                console.error('Erro ao pré-selecionar obra:', error);
            }
        }
        
        // Fechar modal de medição
        function fecharModalMedicaoInline() {
            const modal = document.getElementById('modal-medicao-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Abrir modal de obras
        async function abrirModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (!modal) return;
            
            // Carregar obras
            await carregarObrasParaModal();
            
            // Mostrar modal
            modal.style.display = 'block';
        }
        
        // Fechar modal de obras
        function fecharModalObrasInline() {
            const modal = document.getElementById('modal-obras-inline');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Carregar obras para o modal
        async function carregarObrasParaModal() {
            try {
                const { data: obras, error } = await supabase
                    .from('obras_hvc')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('obras-list-inline');
                if (!container) return;
                
                if (obras && obras.length > 0) {
                    container.innerHTML = obras.map(obra => {
                        const obraName = obra.numero_obra || obra.nome || `Obra ${obra.id}`;
                        return `
                            <div class="obras-list-item" onclick="selecionarObraInline(${obra.id}, '${obraName}')" style="padding: 15px; margin: 10px 0; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                                <strong style="color: #fff;">${obraName}</strong>
                            </div>
                        `;
                    }).join('');
                } else {
                    container.innerHTML = '<p style="text-align: center; color: #b0c4de;">Nenhuma obra cadastrada</p>';
                }
            } catch (error) {
                console.error('Erro ao carregar obras:', error);
            }
        }
        
        // Selecionar obra
        function selecionarObraInline(obraId, obraName) {
            window.obraIdMedicaoInline = obraId;
            
            const container = document.getElementById('obra-selecionada-container-inline');
            if (container) {
                container.innerHTML = `
                    <div style="padding: 12px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #4CAF50;">${obraName}</strong>
                        </div>
                        <button type="button" onclick="abrirModalObrasInline()" style="padding: 6px 12px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer;">
                            Trocar
                        </button>
                    </div>
                `;
            }
            
            // Fechar modal de obras
            fecharModalObrasInline();
        }
        
        // Salvar medição
        async function salvarMedicaoInline(event) {
            event.preventDefault();
            
            const dataMedicao = document.getElementById('data-medicao-inline').value;
            const dataRecebimento = document.getElementById('data-recebimento-inline').value;
            const valor = parseFloat(document.getElementById('valor-medicao-inline').value);
            const status = document.getElementById('status-medicao-inline').value;
            const observacoes = document.getElementById('observacoes-medicao-inline').value;
            const obraId = window.obraIdMedicaoInline;
            
            if (!obraId) {
                alert('Por favor, selecione uma obra');
                return;
            }
            
            try {
                // Gerar número da medição
                const { data: ultimaMedicao } = await supabase
                    .from('medicoes_hvc')
                    .select('numero')
                    .order('numero', { ascending: false })
                    .limit(1)
                    .single();
                
                const proximoNumero = ultimaMedicao ? parseInt(ultimaMedicao.numero.replace('MED-', '')) + 1 : 1;
                const numeroMedicao = `MED-${String(proximoNumero).padStart(3, '0')}`;
                
                // Salvar no Supabase
                const { data, error } = await supabase
                    .from('medicoes_hvc')
                    .insert([{
                        numero: numeroMedicao,
                        obra_id: obraId,
                        data_medicao: dataMedicao,
                        data_recebimento: dataRecebimento,
                        valor: valor,
                        status: status,
                        observacoes: observacoes
                    }])
                    .select();
                
                if (error) throw error;
                
                alert('Medição criada com sucesso!');
                fecharModalMedicaoInline();
                
                // Atualizar lista de categorias
                if (typeof updateCategoriaForReceiving === 'function') {
                    await updateCategoriaForReceiving();
                }
                
            } catch (error) {
                console.error('Erro ao salvar medição:', error);
                alert('Erro ao salvar medição: ' + error.message);
            }
        }
        
    </script>


    </body>
</html>
