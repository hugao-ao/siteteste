<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluxo de Caixa HVC - Agenda e Pagamentos</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="multi_account_styles.css" />
    
    <style>
        /* Tema específico HVC - Elegante e sofisticado */
        body {
            display: flex;
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #000080, #800080);
            color: #e0e0e0;
        }

        /* Layout responsivo para sidebar */
        #main-content-fluxo-caixa-hvc {
            flex-grow: 1;
            padding: 2rem;
            transition: margin-left 0.3s ease;
            background: linear-gradient(135deg, #000080, #800080);
            margin-left: 250px;
            width: calc(100vw - 250px);
            box-sizing: border-box;
        }

        #main-content-fluxo-caixa-hvc.sidebar-collapsed {
            margin-left: 60px;
            width: calc(100vw - 60px);
        }

        @media (max-width: 768px) {
            #main-content-fluxo-caixa-hvc {
                margin-left: 0;
                width: 100vw;
            }
            
            #main-content-fluxo-caixa-hvc.sidebar-collapsed {
                margin-left: 0;
                width: 100vw;
            }
        }

        .hvc-container {
            background: rgba(25, 25, 112, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 128, 0.3);
            backdrop-filter: blur(10px);
            max-width: 100%;
            box-sizing: border-box;
        }

        .hvc-title {
            color: #ffffff;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            text-align: center;
            word-wrap: break-word;
        }

        /* Seção de Resumo Mensal */
        .monthly-summary {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            text-align: center;
        }

        .monthly-summary h3 {
            color: #ffc107;
            font-size: 1.5rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .monthly-total {
            color: #ffffff;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .monthly-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            color: #ffc107;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* ✅ NOVO: Estatísticas por Status com Montantes */
        .status-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .status-stat-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
        }

        .status-stat-item.pg {
            border-color: #34a853;
            background: rgba(52, 168, 83, 0.2);
        }

        .status-stat-item.pendente {
            border-color: #ea4335;
            background: rgba(234, 67, 53, 0.2);
        }

        .status-stat-item.recalculado {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.2);
        }

        .status-stat-value {
            color: #ffffff;
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-stat-amount {
            color: #ffc107;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .status-stat-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8rem;
            margin-top: 5px;
        }

        /* Lista de Pagamentos */
        .payments-list-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .payments-list-section h3 {
            color: #ffffff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ✅ NOVO: Filtros de Pagamentos */
        .payments-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .filter-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #ffffff;
            font-size: 0.9rem;
        }

        .filter-input:focus {
            outline: none;
            border-color: #4285f4;
            background: rgba(255, 255, 255, 0.15);
        }

        .filter-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .filter-select {
            background: rgba(66, 133, 244, 0.8) !important; /* ✅ NOVO: Fundo azul para visibilidade */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 8px 12px;
            color: #ffffff !important;
            font-size: 0.9rem;
        }

        .filter-select option {
            background: rgba(66, 133, 244, 0.9) !important; /* ✅ NOVO: Fundo azul para opções */
            color: #ffffff !important;
        }

        .clear-filters-btn {
            background: rgba(234, 67, 53, 0.3);
            border: 1px solid #ea4335;
            border-radius: 6px;
            padding: 8px 16px;
            color: #ea4335;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            align-self: flex-end;
        }

        .clear-filters-btn:hover {
            background: rgba(234, 67, 53, 0.5);
            color: #ffffff;
        }

        .payments-list {
            max-height: 500px;
            overflow-y: auto;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .payments-list::-webkit-scrollbar {
            width: 8px;
        }

        .payments-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .payments-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .payment-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .payment-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .payment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .payment-name {
            color: #ffffff;
            font-weight: bold;
            font-size: 1.1rem;
            flex: 1;
            min-width: 200px;
        }

        .payment-value {
            color: #ffc107;
            font-weight: bold;
            font-size: 1.2rem;
            background: rgba(255, 193, 7, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .payment-details {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .payment-date {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .payment-status {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .payment-status.pg {
            background: rgba(52, 168, 83, 0.3);
            color: #34a853;
        }

        .payment-status.pendente {
            background: rgba(234, 67, 53, 0.3);
            color: #ea4335;
        }

        .payment-status.recalculado {
            background: rgba(66, 133, 244, 0.3);
            color: #4285f4;
        }

        .payment-type {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(66, 133, 244, 0.3);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .payment-type.pagamento {
            background: rgba(234, 67, 53, 0.3);
        }

        .payment-type.hvc {
            background: rgba(156, 39, 176, 0.3);
        }

        .no-payments {
            text-align: center;
            padding: 40px;
            color: rgba(255, 255, 255, 0.6);
        }

        .no-payments i {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
        }

        /* Google Calendar Section */
        .google-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .google-section h2 {
            color: #ffffff;
            font-size: 1.8rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-size: 16px;
            font-weight: 500;
            flex-wrap: wrap;
        }

        .status-disconnected {
            background: rgba(234, 67, 53, 0.2);
            border: 1px solid rgba(234, 67, 53, 0.4);
            color: #ea4335;
        }

        .status-connected {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            color: #34a853;
        }

        .google-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: flex-start;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4285f4, #34a853);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Calendar View */
        .calendar-section {
            background: rgba(25, 25, 112, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: auto;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .calendar-nav button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .calendar-nav button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .calendar-title {
            color: #ffffff;
            font-size: 1.5rem;
            font-weight: 500;
            text-align: center;
            min-width: 200px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            min-width: 700px;
        }

        .calendar-day-header {
            background: rgba(66, 133, 244, 0.3);
            color: white;
            padding: 15px 5px;
            text-align: center;
            font-weight: 500;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            min-width: 100px;
        }

        .calendar-day {
            background: rgba(255, 255, 255, 0.05);
            min-height: 140px;
            max-height: 140px;
            padding: 8px;
            position: relative;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-width: 100px;
        }

        .calendar-day:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .calendar-day.today {
            background: rgba(66, 133, 244, 0.2) !important;
            border: 2px solid #4285f4 !important;
        }

        .day-number {
            color: white;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 12px;
            flex-shrink: 0;
        }

        .day-total {
            background: rgba(255, 193, 7, 0.8);
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 3px;
            text-align: center;
            flex-shrink: 0;
            word-wrap: break-word;
            line-height: 1.1;
        }

        .day-events {
            display: flex;
            flex-direction: column;
            gap: 2px;
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }

        .event-item {
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
            flex-shrink: 0;
        }

        .event-item:hover {
            transform: scale(1.02);
            z-index: 10;
            position: relative;
            white-space: normal;
            word-wrap: break-word;
        }

        .event-item.completed {
            background: linear-gradient(135deg, #34a853, #2e7d32);
        }

        .event-item.overdue {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
        }

        .event-item.upcoming {
            background: linear-gradient(135deg, #4285f4, #1976d2);
        }

        /* ✅ NOVO: Estilos para eventos agrupados por status */
        .event-item.event-pg {
            background: linear-gradient(135deg, #34a853, #2e7d32);
        }

        .event-item.event-pendente {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
        }

        .event-item.event-recalculado {
            background: linear-gradient(135deg, #4285f4, #1976d2);
        }

        .event-item.event-mixed {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        /* ✅ NOVO: Estilos para modal de eventos agrupados */
        .day-summary {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .day-total-value {
            font-size: 28px;
            font-weight: bold;
            color: #ffc107;
            margin: 10px 0;
        }

        .day-stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .day-stats span {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        .grouped-event-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .grouped-event-section h4 {
            color: #ffc107;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .grouped-event-section h5 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 16px;
        }

        /* Filter Section */
        .filter-section {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .filter-info {
            color: #34a853;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            flex-wrap: wrap;
        }

        .filter-stats {
            margin-top: 10px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            word-wrap: break-word;
        }

        /* Event Details Modal */
        .event-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }

        .event-modal-content {
            background: linear-gradient(135deg, #000080, #800080);
            margin: 5% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            box-sizing: border-box;
        }

        .event-total-section {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .event-total-title {
            color: #ffc107;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .event-total-value {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            word-wrap: break-word;
        }

        .event-values-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .event-values-list h4 {
            color: #ffc107;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .value-item {
            background: rgba(255, 193, 7, 0.3);
            color: #fff;
            padding: 8px 12px;
            border-radius: 5px;
            margin: 8px 0;
            font-family: monospace;
            font-size: 13px;
            word-wrap: break-word;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .value-item-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .value-item-status.pg {
            background: rgba(52, 168, 83, 0.8);
            color: white;
        }

        .value-item-status.pendente {
            background: rgba(234, 67, 53, 0.8);
            color: white;
        }

        .value-item-status.recalculado {
            background: rgba(66, 133, 244, 0.8);
            color: white;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #000080, #800080);
            margin: 10% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            animation: modalSlideIn 0.3s ease;
            box-sizing: border-box;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .modal-header h2 {
            color: #ffffff;
            font-size: 1.5rem;
            word-wrap: break-word;
            flex: 1;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
            min-width: 30px;
            text-align: center;
        }

        .close:hover {
            color: white;
        }

        .modal-body p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 15px;
            word-wrap: break-word;
        }

        .modal-body ul {
            color: #e0e0e0;
            margin-left: 20px;
        }

        .modal-body li {
            margin-bottom: 8px;
            word-wrap: break-word;
        }

        .attachment-link {
            color: #4285f4;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-right: 15px;
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .attachment-link:hover {
            color: #34a853;
            text-decoration: underline;
        }

        /* Messages */
        .message {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 100%;
            box-sizing: border-box;
        }

        .message.success {
            background: rgba(52, 168, 83, 0.2);
            border: 1px solid rgba(52, 168, 83, 0.4);
            color: #34a853;
        }

        .message.error {
            background: rgba(234, 67, 53, 0.2);
            border: 1px solid rgba(234, 67, 53, 0.4);
            color: #ea4335;
        }

        .message.warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.4);
            color: #ffc107;
        }

        /* Loading Spinner */
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .calendar-grid {
                min-width: 600px;
            }
            
            .calendar-day {
                min-height: 120px;
                max-height: 120px;
            }
        }

        @media (max-width: 768px) {
            #main-content-fluxo-caixa-hvc {
                padding: 1rem;
                margin-left: 0;
                width: 100vw;
            }
            
            #main-content-fluxo-caixa-hvc.sidebar-collapsed {
                margin-left: 0;
                width: 100vw;
            }
            
            .hvc-container,
            .google-section,
            .calendar-section,
            .filter-section,
            .monthly-summary,
            .payments-list-section {
                padding: 20px;
            }
            
            .hvc-title {
                font-size: 1.5rem;
            }
            
            .google-section h2 {
                font-size: 1.4rem;
            }
            
            .calendar-grid {
                font-size: 12px;
                min-width: 500px;
            }
            
            .calendar-day {
                min-height: 100px;
                max-height: 100px;
                padding: 4px;
            }
            
            .google-controls {
                flex-direction: column;
            }

            .calendar-header {
                flex-direction: column;
                gap: 15px;
            }

            .event-item {
                font-size: 9px;
            }

            .day-total {
                font-size: 8px;
            }
            
            .calendar-title {
                font-size: 1.2rem;
                min-width: auto;
            }
            
            .event-modal-content {
                margin: 2% auto;
                padding: 20px;
                width: 95%;
            }
            
            .modal-content {
                margin: 5% auto;
                padding: 20px;
                width: 95%;
            }

            .monthly-total {
                font-size: 2rem;
            }

            .monthly-stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .payment-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .payment-name {
                min-width: auto;
            }

            .payments-filters {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .calendar-grid {
                min-width: 350px;
            }
            
            .calendar-day {
                min-height: 80px;
                max-height: 80px;
                padding: 2px;
            }
            
            .day-total {
                font-size: 7px;
                padding: 1px 2px;
            }
            
            .event-item {
                font-size: 8px;
                padding: 1px 3px;
            }

            .monthly-stats {
                grid-template-columns: 1fr;
            }

            .status-stats {
                grid-template-columns: 1fr;
            }
        }

        /* ✅ NOVO: Estilos para criação de eventos */
        .event-creator-section {
            background: rgba(25, 25, 112, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
        }

        .payment-items-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .add-item-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            color: #ffffff;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: #ffffff;
            font-size: 14px;
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        .add-item-btn {
            background: linear-gradient(135deg, #4285f4, #1976d2);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .add-item-btn:hover {
            background: linear-gradient(135deg, #1976d2, #1565c0);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }

        .items-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .item-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            color: #ffffff;
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .item-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .item-value {
            color: #4285f4;
            font-weight: 500;
            font-size: 16px;
        }

        .remove-item-btn {
            background: rgba(234, 67, 53, 0.8);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-item-btn:hover {
            background: rgba(234, 67, 53, 1);
            transform: scale(1.05);
        }

        .create-event-form {
            background: rgba(52, 168, 83, 0.1);
            border: 1px solid rgba(52, 168, 83, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .form-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .create-event-btn {
            background: linear-gradient(135deg, #34a853, #2e7d32);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .create-event-btn:hover {
            background: linear-gradient(135deg, #2e7d32, #1b5e20);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
        }

        .cancel-event-btn {
            background: rgba(108, 117, 125, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cancel-event-btn:hover {
            background: rgba(108, 117, 125, 1);
            transform: translateY(-2px);
        }

        /* ✅ NOVO: Estilos para ações de eventos */
        .event-actions {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
        }

        .btn-delete {
            background: linear-gradient(135deg, #ea4335, #d33b2c);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-delete:hover {
            background: linear-gradient(135deg, #d33b2c, #b71c1c);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(234, 67, 53, 0.3);
        }

        .btn-delete:active {
            transform: translateY(0);
        }

        /* ✅ NOVO: Estilos para edição de eventos */
                .edit-description-section {
                    background: rgba(255, 255, 255, 0.1);
                    border-radius: 8px;
                    padding: 15px;
                    margin: 15px 0;
                }
                
                .edit-description-textarea {
                    width: 100%;
                    min-height: 120px;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    border-radius: 6px;
                    padding: 10px;
                    color: #ffffff;
                    font-size: 14px;
                    font-family: inherit;
                    resize: vertical;
                    box-sizing: border-box;
                }
                
                .edit-description-textarea:focus {
                    outline: none;
                    border-color: #4285f4;
                    background: rgba(255, 255, 255, 0.15);
                }
                
                .edit-description-textarea::placeholder {
                    color: rgba(255, 255, 255, 0.5);
                }
                
                .edit-buttons {
                    display: flex;
                    gap: 10px;
                    margin-top: 10px;
                    flex-wrap: wrap;
                }
                
                .btn-edit {
                    background: rgba(66, 133, 244, 0.3);
                    border: 1px solid #4285f4;
                    color: #4285f4;
                    padding: 8px 16px;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                }
                
                .btn-edit:hover {
                    background: rgba(66, 133, 244, 0.5);
                    color: #ffffff;
                }
                
                .btn-save {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                }
                
                .btn-save:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }
                
                .btn-cancel {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                }
                
                .btn-cancel:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }
                
                .btn-edit:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                
                .edit-loading {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 14px;
                }

                /* ✅ NOVO: CSS para seção de criação de eventos */
                .event-creator-section {
                    background: rgba(25, 25, 112, 0.3);
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 15px;
                    padding: 30px;
                    margin-bottom: 30px;
                }

                .event-creator-section h3, .event-creator-section h4 {
                    color: #ffffff;
                    margin-bottom: 20px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .payment-items-container {
                    margin-bottom: 30px;
                }

                .add-item-form {
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 10px;
                    padding: 20px;
                    margin-bottom: 20px;
                }

                .form-row {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 15px;
                    margin-bottom: 15px;
                }

                .form-group {
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                }

                .form-group.full-width {
                    grid-column: 1 / -1;
                }

                .form-group label {
                    color: rgba(255, 255, 255, 0.8);
                    font-size: 0.9rem;
                    font-weight: 500;
                }

                .form-group input, .form-group select {
                    background: rgba(66, 133, 244, 0.8) !important; /* ✅ NOVO: Fundo azul para visibilidade */
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 6px;
                    padding: 10px 12px;
                    color: #ffffff !important;
                    font-size: 0.9rem;
                }

                .form-group input:focus, .form-group select:focus {
                    outline: none;
                    border-color: #4285f4;
                    background: rgba(66, 133, 244, 0.9) !important;
                }

                .form-group input::placeholder {
                    color: rgba(255, 255, 255, 0.7) !important;
                }

                .form-group select option {
                    background: rgba(66, 133, 244, 0.9) !important;
                    color: #ffffff !important;
                }

                .add-item-btn {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .add-item-btn:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }

                .items-list {
                    max-height: 300px;
                    overflow-y: auto;
                    border-radius: 8px;
                    background: rgba(255, 255, 255, 0.05);
                }

                .item-card {
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 8px;
                    padding: 15px;
                    margin-bottom: 10px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    gap: 15px;
                }

                .item-info {
                    flex: 1;
                }

                .item-name {
                    color: #ffffff;
                    font-weight: bold;
                    font-size: 1.1rem;
                    margin-bottom: 5px;
                }

                .item-details {
                    color: rgba(255, 255, 255, 0.7);
                    font-size: 0.9rem;
                }

                .item-value {
                    color: #ffc107;
                    font-weight: bold;
                    font-size: 1.2rem;
                    background: rgba(255, 193, 7, 0.2);
                    padding: 5px 10px;
                    border-radius: 5px;
                }

                .remove-item-btn {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                    padding: 8px;
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                }

                .remove-item-btn:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }

                .create-event-form {
                    background: rgba(255, 255, 255, 0.05);
                    border-radius: 10px;
                    padding: 20px;
                    margin-top: 20px;
                }

                .form-actions {
                    display: flex;
                    gap: 15px;
                    margin-top: 20px;
                    flex-wrap: wrap;
                }

                .create-event-btn {
                    background: rgba(52, 168, 83, 0.3);
                    border: 1px solid #34a853;
                    color: #34a853;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .create-event-btn:hover {
                    background: rgba(52, 168, 83, 0.5);
                    color: #ffffff;
                }

                .cancel-event-btn {
                    background: rgba(234, 67, 53, 0.3);
                    border: 1px solid #ea4335;
                    color: #ea4335;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }

                .cancel-event-btn:hover {
                    background: rgba(234, 67, 53, 0.5);
                    color: #ffffff;
                }

                .btn-success {
                    background: linear-gradient(135deg, #34a853, #2e7d32);
                    color: white;
                }

                .btn-success:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
                }

                /* =================================================================
                   MODAL DE RECORRÊNCIA - Estilo Google Calendar
                   ================================================================= */
                .recurrence-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(5px);
                }

                .recurrence-modal-content {
                    background: linear-gradient(135deg, #1a1a2e, #16213e);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 16px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    animation: modalSlideIn 0.3s ease-out;
                }

                @keyframes modalSlideIn {
                    from {
                        opacity: 0;
                        transform: translateY(-30px) scale(0.95);
                    }
                    to {
                        opacity: 1;
                        transform: translateY(0) scale(1);
                    }
                }

                .recurrence-modal-content h3 {
                    color: #ffffff;
                    font-size: 1.5rem;
                    margin-bottom: 15px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .recurrence-modal-content h3 i {
                    color: #ffc107;
                }

                .recurrence-modal-content p {
                    color: rgba(255, 255, 255, 0.8);
                    margin-bottom: 15px;
                    line-height: 1.5;
                }

                .recurrence-modal-content p strong {
                    color: #ffffff;
                }

                .recurrence-options {
                    display: flex;
                    flex-direction: column;
                    gap: 12px;
                    margin: 25px 0;
                }

                .recurrence-btn {
                    background: rgba(255, 255, 255, 0.05);
                    border: 2px solid rgba(255, 255, 255, 0.2);
                    border-radius: 12px;
                    padding: 18px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: left;
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    color: #ffffff;
                }

                .recurrence-btn:hover {
                    background: rgba(255, 255, 255, 0.1);
                    border-color: rgba(255, 255, 255, 0.4);
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
                }

                .recurrence-btn i {
                    font-size: 1.5rem;
                    color: #4285f4;
                    min-width: 24px;
                }

                .recurrence-btn-content {
                    flex: 1;
                }

                .recurrence-btn span {
                    display: block;
                    font-weight: 600;
                    font-size: 1.1rem;
                    margin-bottom: 5px;
                }

                .recurrence-btn small {
                    display: block;
                    color: rgba(255, 255, 255, 0.6);
                    font-size: 0.9rem;
                }

                .recurrence-actions {
                    display: flex;
                    justify-content: flex-end;
                    gap: 15px;
                    margin-top: 25px;
                    padding-top: 20px;
                    border-top: 1px solid rgba(255, 255, 255, 0.1);
                }

                .recurrence-cancel {
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    color: #ffffff;
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.3s ease;
                }

                .recurrence-cancel:hover {
                    background: rgba(255, 255, 255, 0.2);
                    transform: translateY(-1px);
                }

                /* Responsividade para o modal */
                @media (max-width: 768px) {
                    .recurrence-modal-content {
                        margin: 20px;
                        padding: 25px;
                        max-width: none;
                        width: calc(100% - 40px);
                    }

                    .recurrence-btn {
                        padding: 15px;
                        gap: 12px;
                    }

                    .recurrence-btn i {
                        font-size: 1.3rem;
                    }

                    .recurrence-btn span {
                        font-size: 1rem;
                    }

                    .recurrence-actions {
                        flex-direction: column;
                    }

                    .recurrence-cancel {
                        width: 100%;
                        text-align: center;
                    }
                }

        /* =================================================================
           MODAL DE RECORRÊNCIA PERSONALIZADA - Estilo Google Calendar
           ================================================================= */
        .custom-recurrence-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            backdrop-filter: blur(5px);
        }

        .custom-recurrence-modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
            max-height: 80vh;
            overflow-y: auto;
        }

        .custom-recurrence-modal-content h3 {
            color: #ffffff;
            font-size: 1.4rem;
            margin-bottom: 25px;
            text-align: center;
        }

        .recurrence-form-group {
            margin-bottom: 20px;
        }

        .recurrence-form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .recurrence-form-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .recurrence-form-row span {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.95rem;
        }

        .recurrence-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            color: #ffffff;
            font-size: 0.95rem;
            width: 60px;
            text-align: center;
        }

        .recurrence-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            color: #ffffff;
            font-size: 0.95rem;
            min-width: 120px;
        }

        .recurrence-input:focus,
        .recurrence-select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
        }

        .weekdays-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .weekday-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .weekday-btn:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.2);
        }

        .weekday-btn.selected {
            background: #4285f4;
            border-color: #4285f4;
            color: #ffffff;
        }

        .end-options {
            margin-top: 20px;
        }

        .end-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .end-option input[type="radio"] {
            margin: 0;
            transform: scale(1.2);
        }

        .end-option label {
            margin: 0;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .end-date-input,
        .end-count-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px 10px;
            color: #ffffff;
            font-size: 0.9rem;
            width: 120px;
        }

        .custom-recurrence-actions {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .custom-recurrence-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .custom-recurrence-cancel {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }

        .custom-recurrence-cancel:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .custom-recurrence-confirm {
            background: #4285f4;
            color: #ffffff;
        }

        .custom-recurrence-confirm:hover {
            background: #3367d6;
            transform: translateY(-1px);
        }

        /* Responsividade para o modal personalizado */
        @media (max-width: 768px) {
            .custom-recurrence-modal-content {
                margin: 20px;
                padding: 25px;
                max-width: none;
                width: calc(100% - 40px);
            }

            .recurrence-form-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .weekdays-selector {
                justify-content: center;
            }

            .custom-recurrence-actions {
                flex-direction: column;
            }

            .custom-recurrence-btn {
                width: 100%;
                text-align: center;
            }
        }

        /* ✅ NOVO: Estilos para upload de PDF */
        .pdf-upload-container {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #fafafa;
            transition: all 0.3s ease;
            position: relative;
        }

        .pdf-upload-container:hover {
            border-color: #007bff;
            background: #f0f8ff;
        }

        .pdf-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .pdf-upload-info {
            pointer-events: none;
            color: #666;
        }

        .pdf-upload-info i {
            font-size: 2em;
            color: #007bff;
            margin-bottom: 10px;
            display: block;
        }

        .pdf-preview-list {
            margin-top: 15px;
            text-align: left;
        }

        .pdf-preview-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .pdf-preview-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .pdf-preview-info i {
            color: #dc3545;
            margin-right: 10px;
            font-size: 1.2em;
        }

        .pdf-preview-details {
            flex: 1;
        }

        .pdf-preview-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 2px;
        }

        .pdf-preview-size {
            font-size: 0.9em;
            color: #666;
        }

        .pdf-preview-actions {
            display: flex;
            gap: 5px;
        }

        .pdf-remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .pdf-remove-btn:hover {
            background: #c82333;
        }

        .pdf-view-btn {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .pdf-view-btn:hover {
            background: #0056b3;
        }

        .pdf-upload-container.dragover {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .pdf-upload-error {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .pdf-upload-success {
            color: #28a745;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* ✅ NOVO: Estilos para seção de anexos no modal */
        .event-attachments-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #f9f9f9;
        }

        .event-attachments-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1em;
        }

        .event-attachments-list {
            margin-bottom: 15px;
        }

        .attachment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .attachment-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .attachment-info i {
            color: #dc3545;
            margin-right: 10px;
            font-size: 1.2em;
        }

        .attachment-name {
            font-weight: bold;
            color: #333;
        }

        .attachment-actions {
            display: flex;
            gap: 5px;
        }

        .btn-view-attachment, .btn-remove-attachment {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background 0.3s ease;
        }

        .btn-remove-attachment {
            background: #dc3545;
        }

        .btn-view-attachment:hover {
            background: #0056b3;
        }

        .btn-remove-attachment:hover {
            background: #c82333;
        }

        .attachment-upload-section {
            text-align: center;
        }

        .btn-add-pdf {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s ease;
        }

        .btn-add-pdf:hover {
            background: #218838;
        }

        .no-attachments {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 10px 0;
        }


    </style>

    <script>
        // =================================================================
        // DEFINIR FUNÇÕES GLOBAIS ANTES DOS SCRIPTS DO GOOGLE
        // =================================================================
        
        // Configurações
        const CLIENT_ID = '314578730498-ghkttnk7g4729g206tk3gsac1qtghhme.apps.googleusercontent.com';
        const DISCOVERY_DOC = ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest', 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
        const SCOPES = 'https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/drive.file';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let isGoogleConnected = false;
        let filteredEvents = [];
        let currentDate = new Date();
        let allPaymentsList = []; // ✅ NOVO: Lista completa de pagamentos
        let filteredPaymentsList = []; // ✅ NOVO: Lista filtrada
        // ✅ NOVO: Variáveis para criação de eventos
        let paymentItems = [];
        let currentEditingEvent = null;
        let isEditingDescription = false;
        let originalDescription = '';
        // ✅ NOVO:        let paymentItems = [];
        let allEventAttachments = []; // Todos os anexos do evento

        // ✅ NOVO: Funções para gerenciar itens de pagamento
        function addPaymentItem() {
            const tipo = document.getElementById('itemTipo').value.trim();
            const subtipo = document.getElementById('itemSubtipo').value.trim();
            const categoria = document.getElementById('itemCategoria').value.trim();
            const nome = document.getElementById('itemNome').value.trim();
            
            // ✅ NOVO: Parsing correto do valor formatado
            const valorText = document.getElementById('itemValor').value;
            const valor = parseFloat(valorText.replace(/[^\d,]/g, '').replace(',', '.'));
            
            const status = document.getElementById('itemStatus').value;
            const detalhe = document.getElementById('itemDetalhe').value.trim();

            // Validação
            if (!nome) {
                alert('Nome do item é obrigatório!');
                return;
            }
            if (!valor || valor <= 0) {
                alert('Valor deve ser maior que zero!');
                return;
            }

            // Criar item
            const item = {
                id: Date.now(),
                tipo,
                subtipo,
                categoria,
                nome,
                valor,
                status,
                detalhe
            };

            paymentItems.push(item);
            renderPaymentItems();
            clearItemForm();
            
            // Mostrar formulário de evento se houver itens
            if (paymentItems.length > 0) {
                document.getElementById('createEventForm').style.display = 'block';
            }
        }

        function removePaymentItem(itemId) {
            paymentItems = paymentItems.filter(item => item.id !== itemId);
            renderPaymentItems();
            
            // Esconder formulário de evento se não houver itens
            if (paymentItems.length === 0) {
                document.getElementById('createEventForm').style.display = 'none';
            }
        }

        function renderPaymentItems() {
            const itemsList = document.getElementById('itemsList');
            
            if (paymentItems.length === 0) {
                itemsList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.6); text-align: center; padding: 20px;">Nenhum item adicionado ainda.</p>';
                return;
            }

            itemsList.innerHTML = paymentItems.map(item => `
                <div class="item-card">
                    <div class="item-info">
                        <div class="item-name">${item.nome}</div>
                        <div class="item-details">
                            ${item.tipo ? `<span>Tipo: ${item.tipo}</span>` : ''}
                            ${item.subtipo ? `<span>Subtipo: ${item.subtipo}</span>` : ''}
                            ${item.categoria ? `<span>Categoria: ${item.categoria}</span>` : ''}
                            ${item.status ? `<span>Status: ${item.status}</span>` : ''}
                            ${item.detalhe ? `<span>Detalhe: ${item.detalhe}</span>` : ''}
                            ${item.pdfs && item.pdfs.length > 0 ? `<span><i class="fas fa-file-pdf"></i> ${item.pdfs.length} PDF(s) anexado(s)</span>` : ''}
                        </div>
                    </div>
                    <div class="item-value">${formatCurrency(item.valor)}</div>
                    <button class="remove-item-btn" onclick="removePaymentItem(${item.id})">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function clearItemForm() {
            document.getElementById('itemTipo').value = '';
            document.getElementById('itemSubtipo').value = '';
            document.getElementById('itemCategoria').value = '';
            document.getElementById('itemNome').value = '';
            document.getElementById('itemValor').value = '';
            document.getElementById('itemStatus').value = '';
            document.getElementById('itemDetalhe').value = '';
        }

        function generateEventDescription() {
            return paymentItems.map(item => {
                const parts = [];
                if (item.tipo) parts.push(item.tipo);
                if (item.subtipo) parts.push(item.subtipo);
                if (item.categoria) parts.push(item.categoria);
                parts.push(item.nome);
                
                // Formatar valor com status (sem hífen entre eles)
                let valorFormatado = formatCurrency(item.valor);
                if (item.status) {
                    valorFormatado += ` (${item.status})`;
                }
                parts.push(valorFormatado);
                
                if (item.detalhe) parts.push(item.detalhe);
                
                return parts.join(' - ');
            }).join('\n');
        }

        async function createPaymentEvent() {
            if (paymentItems.length === 0) {
                alert('Adicione pelo menos um item de pagamento!');
                return;
            }

            const eventDate = document.getElementById('eventDate').value;
            const eventTime = document.getElementById('eventTime').value;
            const recurrence = document.getElementById('eventRecurrence').value;

            if (!eventDate) {
                alert('Data é obrigatória!');
                return;
            }
            if (!recurrence || recurrence === '') {
                alert('Recorrência é obrigatória!');
                return;
            }

            try {
                // Preparar data e hora
                const startDateTime = new Date(`${eventDate}T${eventTime}:00`);
                const endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // 1 hora depois

                // Preparar recorrência
                let rrule = null;
                if (recurrence !== 'NONE') {
                    console.log('🔄 Gerando RRULE para:', recurrence, 'Data:', eventDate);
                    
                    // Usar a mesma data base para evitar problemas de fuso horário
                    // Criar data no fuso horário local para garantir consistência
                    const [year, month, day] = eventDate.split('-').map(Number);
                    const date = new Date(year, month - 1, day, 12, 0, 0); // Meio-dia local
                    const dayOfWeek = date.getDay();
                    const dayOfMonth = date.getDate();
                    const monthNum = date.getMonth() + 1;
                    
                    console.log('📅 Data processada:', date.toString());
                    console.log('📅 Dia da semana:', dayOfWeek, '(0=Dom, 1=Seg, 2=Ter, 3=Qua, 4=Qui, 5=Sex, 6=Sab)');
                    
                    // Mapear dias da semana para RRULE
                    const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
                    const currentDay = rruleDays[dayOfWeek];
                    
                    console.log('📅 RRULE Day:', currentDay);
                    
                    let rruleString = null;
                    
                    switch (recurrence) {
                        case 'DAILY':
                            rruleString = 'FREQ=DAILY';
                            break;
                            
                        case 'WEEKLY':
                            rruleString = `FREQ=WEEKLY;BYDAY=${currentDay}`;
                            break;
                            
                        case 'MONTHLY':
                            // Calcular qual semana do mês (primeira, segunda, terceira, etc.)
                            const weekOfMonth = Math.ceil(dayOfMonth / 7);
                            rruleString = `FREQ=MONTHLY;BYDAY=${weekOfMonth}${currentDay}`;
                            break;
                            
                        case 'YEARLY':
                            rruleString = `FREQ=YEARLY;BYMONTH=${monthNum};BYMONTHDAY=${dayOfMonth}`;
                            break;
                            
                        case 'WEEKDAYS':
                            rruleString = 'FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR';
                            break;
                            
                        case 'CUSTOM_GENERATED':
                            rruleString = window.customRRule || null;
                            break;
                            
                        default:
                            rruleString = null;
                    }
                    
                    console.log('📝 RRULE gerada:', rruleString);
                    if (rruleString) {
                        rrule = [`RRULE:${rruleString}`];
                        console.log('✅ RRULE final:', rrule);
                    }
                }

                // Criar evento
                const event = {
                    summary: 'PAGAMENTO',
                    description: generateEventDescription(),
                    start: {
                        dateTime: startDateTime.toISOString(),
                        timeZone: 'America/Sao_Paulo'
                    },
                    end: {
                        dateTime: endDateTime.toISOString(),
                        timeZone: 'America/Sao_Paulo'
                    }
                };

                if (rrule) {
                    event.recurrence = rrule;
                }

                const response = await gapi.client.calendar.events.insert({
                    calendarId: 'primary',
                    resource: event
                });

                console.log('✅ Evento criado:', response.result);
                alert('Evento criado com sucesso!');
                
                // Limpar formulário
                paymentItems = [];
                renderPaymentItems();
                document.getElementById('createEventForm').style.display = 'none';
                document.getElementById('eventDate').value = '';
                document.getElementById('eventTime').value = '09:00';
                document.getElementById('eventRecurrence').value = '';
                
                // Recarregar calendário
                handleSyncClick();
                
            } catch (error) {
                console.error('❌ Erro ao criar evento:', error);
                alert('Erro ao criar evento. Verifique sua conexão e tente novamente.');
            }
        }

        function cancelEventCreation() {
            if (paymentItems.length > 0) {
                if (confirm('Tem certeza que deseja cancelar? Todos os itens serão perdidos.')) {
                    paymentItems = [];
                    renderPaymentItems();
                    document.getElementById('createEventForm').style.display = 'none';
                }
            } else {
                document.getElementById('createEventForm').style.display = 'none';
            }
        }

        // ✅ NOVO: Função para alternar seção de criação de eventos
        function toggleEventCreator() {
            const eventCreatorSection = document.getElementById('eventCreatorSection');
            const isVisible = eventCreatorSection.style.display !== 'none';
            
            if (isVisible) {
                eventCreatorSection.style.display = 'none';
            } else {
                eventCreatorSection.style.display = 'block';
                // Inicializar lista vazia se necessário
                if (paymentItems.length === 0) {
                    renderPaymentItems();
                }
            }
        }

        // CORREÇÃO: Definir as funções ANTES dos scripts carregarem
        window.gapiLoaded = function() {
            console.log('🔄 Carregando GAPI...');
            gapi.load('client', initializeGapiClient);
        }

        window.gisLoaded = function() {
            console.log('🔄 Carregando GIS...');
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: handleTokenResponse,
                });
                gisInited = true;
                maybeEnableButtons();
                console.log('✅ GIS inicializado com sucesso!');
            } catch (error) {
                console.error('❌ Erro ao inicializar GIS:', error);
                showMessage('Erro ao carregar sistema de autenticação do Google', 'error');
            }
        }

        async function initializeGapiClient() {
            try {
                console.log('🔄 Inicializando GAPI client...');
                console.log('📋 Discovery docs:', DISCOVERY_DOC);
                
                await gapi.client.init({
                    discoveryDocs: DISCOVERY_DOC,
                });
                
                console.log('✅ GAPI client inicializado');
                
                // Verificar se as APIs foram carregadas corretamente
                if (gapi.client.calendar) {
                    console.log('✅ Google Calendar API carregada');
                } else {
                    console.warn('⚠️ Google Calendar API não foi carregada');
                }
                
                if (gapi.client.drive) {
                    console.log('✅ Google Drive API carregada');
                } else {
                    console.warn('⚠️ Google Drive API não foi carregada');
                }
                
                gapiInited = true;
                maybeEnableButtons();
                console.log('✅ GAPI inicializado com sucesso!');
                
                // Tentar restaurar sessão
                await tryRestoreSession();
            } catch (error) {
                console.error('❌ Erro ao inicializar GAPI:', error);
                console.error('❌ Detalhes do erro:', error.message);
                showMessage('Erro ao carregar APIs do Google', 'error');
            }
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                const authorizeButton = document.getElementById('authorizeButton');
                if (authorizeButton) {
                    authorizeButton.style.display = 'block';
                    console.log('✅ APIs do Google carregadas com sucesso');
                    showMessage('APIs do Google carregadas com sucesso!', 'success');
                }
            }
        }

        // =================================================================
        // ✅ SISTEMA DE EXTRAÇÃO COM STATUS MELHORADO
        // =================================================================
        function extractPaymentInfo(text) {
            if (!text) return [];
            
            // Regex para detectar padrões como "Nome do pagamento - R$ 1.234,56 (STATUS)"
            const paymentRegex = /([^-\n\r]+?)\s*-\s*R\$\s*([\d.]+,\d{2})\s*(\([^)]*\))?/gi;
            const matches = [];
            let match;
            
            while ((match = paymentRegex.exec(text)) !== null) {
                let paymentName = match[1].trim();
                
                // Remover "PAGAMENTO" do início se existir
                if (paymentName.toLowerCase().startsWith('pagamento ')) {
                    paymentName = paymentName.substring(10).trim(); // Remove "PAGAMENTO "
                }
                
                const valueStr = match[2];
                const statusText = match[3] ? match[3].replace(/[()]/g, '').trim() : '';
                const numericValue = parseFloat(valueStr.replace(/\./g, '').replace(',', '.'));
                
                // Determinar status baseado no texto entre parênteses
                let status = 'PENDENTE'; // Status padrão
                
                if (statusText) {
                    const statusLower = statusText.toLowerCase();
                    if (statusLower.includes('pg')) {
                        status = 'PG';
                    } else if (statusLower.includes('recalculado')) {
                        status = 'RECALCULADO';
                    }
                }
                
                matches.push({
                    name: paymentName,
                    original: `${paymentName} - R$ ${valueStr}${match[3] ? ' ' + match[3] : ''}`,
                    value: numericValue,
                    formattedValue: `R$ ${valueStr}`,
                    status: status,
                    statusText: statusText
                });
            }
            
            // Fallback: se não encontrar o padrão com "-", usar o método antigo
            if (matches.length === 0) {
                const moneyRegex = /R\$\s*([\d.]+,\d{2})/gi;
                const moneyMatches = text.match(moneyRegex) || [];
                
                moneyMatches.forEach(match => {
                    const valueStr = match.replace(/R\$\s*/, '');
                    const numericValue = parseFloat(valueStr.replace(/\./g, '').replace(',', '.'));
                    
                    matches.push({
                        name: 'Pagamento',
                        original: match,
                        value: numericValue,
                        formattedValue: match,
                        status: 'PENDENTE',
                        statusText: ''
                    });
                });
            }
            
            return matches;
        }

        function calculateEventTotal(event) {
            const description = event.description || '';
            const summary = event.summary || '';
            const fullText = `${summary} ${description}`;
            
            const payments = extractPaymentInfo(fullText);
            
            // Só contar PG e PENDENTE para o total
            const countablePayments = payments.filter(p => p.status === 'PG' || p.status === 'PENDENTE');
            const total = countablePayments.reduce((sum, item) => sum + item.value, 0);
            
            return {
                total: total,
                payments: payments,
                countablePayments: countablePayments,
                count: payments.length,
                countableCount: countablePayments.length
            };
        }

        function formatCurrency(value) {
            return new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
            }).format(value);
        }

        function calculateDayTotal(date) {
            const eventsForDay = getEventsForDay(date);
            let dayTotal = 0;
            
            eventsForDay.forEach(event => {
                const eventCalc = calculateEventTotal(event);
                dayTotal += eventCalc.total; // Já considera apenas PG e PENDENTE
            });
            
            return dayTotal;
        }

        // =================================================================
        // ✅ CÁLCULOS MENSAIS COM MONTANTES POR STATUS
        // =================================================================
        function calculateMonthlyTotals() {
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            
            let monthlyTotal = 0;
            let totalEvents = 0;
            let totalPayments = 0;
            
            // ✅ NOVO: Contadores e montantes por status
            let totalPG = 0;
            let totalPendente = 0;
            let totalRecalculado = 0;
            let amountPG = 0;
            let amountPendente = 0;
            let amountRecalculado = 0;
            
            const paymentsList = [];
            
            filteredEvents.forEach(event => {
                const eventDate = parseEventDate(event);
                
                if (eventDate.getMonth() === currentMonth && eventDate.getFullYear() === currentYear) {
                    const eventCalc = calculateEventTotal(event);
                    monthlyTotal += eventCalc.total; // Já considera apenas PG e PENDENTE
                    totalEvents++;
                    totalPayments += eventCalc.count;
                    
                    // Contar por status e somar montantes
                    eventCalc.payments.forEach(payment => {
                        if (payment.status === 'PG') {
                            totalPG++;
                            amountPG += payment.value;
                        } else if (payment.status === 'PENDENTE') {
                            totalPendente++;
                            amountPendente += payment.value;
                        } else if (payment.status === 'RECALCULADO') {
                            totalRecalculado++;
                            amountRecalculado += payment.value;
                        }
                        
                        // Adicionar pagamentos à lista
                        paymentsList.push({
                            ...payment,
                            eventTitle: event.summary || 'Sem título',
                            eventDate: eventDate,
                            eventType: getEventType(event),
                            eventId: event.id
                        });
                    });
                }
            });
            
            // ✅ NOVO: Ordenar pagamentos por data (mais recente primeiro)
            paymentsList.sort((a, b) => b.eventDate - a.eventDate);
            
            return {
                total: monthlyTotal,
                events: totalEvents,
                payments: totalPayments,
                totalPG: totalPG,
                totalPendente: totalPendente,
                totalRecalculado: totalRecalculado,
                amountPG: amountPG,
                amountPendente: amountPendente,
                amountRecalculado: amountRecalculado,
                paymentsList: paymentsList
            };
        }

        function updateMonthlySummary() {
            const monthlyData = calculateMonthlyTotals();
            
            // Atualizar total mensal
            const monthlyTotalElement = document.getElementById('monthlyTotal');
            if (monthlyTotalElement) {
                monthlyTotalElement.textContent = formatCurrency(monthlyData.total);
            }
            
            // Atualizar estatísticas gerais
            const totalEventsElement = document.getElementById('totalEvents');
            const totalPaymentsElement = document.getElementById('totalPayments');
            const avgPaymentElement = document.getElementById('avgPayment');
            
            if (totalEventsElement) {
                totalEventsElement.textContent = monthlyData.events;
            }
            
            if (totalPaymentsElement) {
                totalPaymentsElement.textContent = monthlyData.payments;
            }
            
                if (avgPaymentElement) {
                    // ✅ NOVO: Calcular valor médio por dia do mês
                    const currentMonth = currentDate.getMonth();
                    const currentYear = currentDate.getFullYear();
                    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
                    const avgValue = monthlyData.total > 0 ? monthlyData.total / daysInMonth : 0;
                    avgPaymentElement.textContent = formatCurrency(avgValue);
                }

            
            // ✅ NOVO: Atualizar estatísticas por status com montantes
            const totalPGElement = document.getElementById('totalPG');
            const totalPendenteElement = document.getElementById('totalPendente');
            const totalRecalculadoElement = document.getElementById('totalRecalculado');
            const amountPGElement = document.getElementById('amountPG');
            const amountPendenteElement = document.getElementById('amountPendente');
            const amountRecalculadoElement = document.getElementById('amountRecalculado');
            
            if (totalPGElement) {
                totalPGElement.textContent = monthlyData.totalPG;
            }
            
            if (totalPendenteElement) {
                totalPendenteElement.textContent = monthlyData.totalPendente;
            }
            
            if (totalRecalculadoElement) {
                totalRecalculadoElement.textContent = monthlyData.totalRecalculado;
            }
            
            if (amountPGElement) {
                amountPGElement.textContent = formatCurrency(monthlyData.amountPG);
            }
            
            if (amountPendenteElement) {
                amountPendenteElement.textContent = formatCurrency(monthlyData.amountPendente);
            }
            
            if (amountRecalculadoElement) {
                amountRecalculadoElement.textContent = formatCurrency(monthlyData.amountRecalculado);
            }
            
            // ✅ NOVO: Atualizar lista de pagamentos com filtros
            allPaymentsList = monthlyData.paymentsList;
            filteredPaymentsList = [...allPaymentsList];
            updatePaymentsList();
        }

        // =================================================================
        // ✅ NOVO: SISTEMA DE FILTROS DE PAGAMENTOS
        // =================================================================
        function initializePaymentFilters() {
            const nameFilter = document.getElementById('nameFilter');
            const dateFilter = document.getElementById('dateFilter');
            const statusFilter = document.getElementById('statusFilter');
            const clearFiltersBtn = document.getElementById('clearFilters');
            
            if (nameFilter) {
                nameFilter.addEventListener('input', applyFilters);
            }
            
            if (dateFilter) {
                dateFilter.addEventListener('change', applyFilters);
            }
            
            if (statusFilter) {
                statusFilter.addEventListener('change', applyFilters);
            }
            
            if (clearFiltersBtn) {
                clearFiltersBtn.addEventListener('click', clearFilters);
            }
        }

        function applyFilters() {
            const nameFilter = document.getElementById('nameFilter')?.value.toLowerCase() || '';
            const dateFilter = document.getElementById('dateFilter')?.value || '';
            const statusFilter = document.getElementById('statusFilter')?.value || '';
            
            filteredPaymentsList = allPaymentsList.filter(payment => {
                // Filtro por nome
                const nameMatch = !nameFilter || 
                    payment.name.toLowerCase().includes(nameFilter) ||
                    payment.eventTitle.toLowerCase().includes(nameFilter);
                
                // Filtro por data
                const dateMatch = !dateFilter || 
                    payment.eventDate.toISOString().split('T')[0] === dateFilter;
                
                // Filtro por status
                const statusMatch = !statusFilter || 
                    payment.status === statusFilter;
                
                return nameMatch && dateMatch && statusMatch;
            });
            
            updatePaymentsList();
        }

        function clearFilters() {
            const nameFilter = document.getElementById('nameFilter');
            const dateFilter = document.getElementById('dateFilter');
            const statusFilter = document.getElementById('statusFilter');
            
            if (nameFilter) nameFilter.value = '';
            if (dateFilter) dateFilter.value = '';
            if (statusFilter) statusFilter.value = '';
            
            filteredPaymentsList = [...allPaymentsList];
            updatePaymentsList();
        }

        function updatePaymentsList() {
            const paymentsListElement = document.getElementById('paymentsList');
            if (!paymentsListElement) return;
            
            if (filteredPaymentsList.length === 0) {
                paymentsListElement.innerHTML = `
                    <div class="no-payments">
                        <i class="fas fa-inbox"></i>
                        <p>Nenhum pagamento encontrado</p>
                        ${allPaymentsList.length > 0 ? '<p style="font-size: 0.9rem;">Tente ajustar os filtros</p>' : ''}
                    </div>
                `;
                return;
            }
            
            paymentsListElement.innerHTML = filteredPaymentsList.map(payment => `
                <div class="payment-item" onclick="showPaymentEvent('${payment.eventId}')">
                    <div class="payment-header">
                        <div class="payment-name">${payment.name}</div>
                        <div class="payment-value">${payment.formattedValue}</div>
                    </div>
                    <div class="payment-details">
                        <div class="payment-date">
                            <i class="fas fa-calendar"></i>
                            ${payment.eventDate.toLocaleDateString('pt-BR')}
                        </div>
                        <div class="payment-status ${payment.status.toLowerCase()}">
                            <i class="fas fa-tag"></i>
                            ${payment.status}
                        </div>
                        <div style="color: rgba(255, 255, 255, 0.6);">
                            ${payment.eventTitle}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function showPaymentEvent(eventId) {
            const event = filteredEvents.find(e => e.id === eventId);
            if (event) {
                showEventDetails(event);
            }
        }

        // =================================================================
        // LÓGICA DE CORES BASEADA EM STATUS E DATA
        // =================================================================
        function getEventColorClass(event) {
            const eventCalc = calculateEventTotal(event);
            const eventDate = parseEventDate(event);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            eventDate.setHours(0, 0, 0, 0);
            
            // Verificar se todos os pagamentos estão com PG ou RECALCULADO
            const allCompleted = eventCalc.payments.length > 0 && 
                eventCalc.payments.every(p => p.status === 'PG' || p.status === 'RECALCULADO');
            
            if (allCompleted) {
                return 'completed'; // Verde
            } else if (eventDate < today) {
                return 'overdue'; // Vermelho (data anterior)
            } else {
                return 'upcoming'; // Azul (data posterior)
            }
        }

        // =================================================================
        // CORREÇÃO DE FUSO HORÁRIO - FUNÇÃO PRINCIPAL
        // =================================================================
        function parseEventDate(event) {
            let eventDate;
            
            if (event.start.date) {
                // Evento de dia inteiro - usar apenas a data sem conversão de fuso
                eventDate = new Date(event.start.date + 'T00:00:00');
            } else if (event.start.dateTime) {
                // Evento com horário específico - converter para data local
                eventDate = new Date(event.start.dateTime);
            } else {
                // Fallback
                eventDate = new Date();
            }
            
            return eventDate;
        }

        function getDateString(date) {
            // Retorna string no formato YYYY-MM-DD para comparação
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function getCalendarDateString(date) {
            // Para datas do calendário, usar a data local sem conversão
            return getDateString(date);
        }

        // =================================================================
        // PERSISTÊNCIA DE LOGIN
        // =================================================================
        function saveConnectionState() {
            try {
                const connectionData = {
                    connected: isGoogleConnected,
                    timestamp: Date.now(),
                    clientId: CLIENT_ID
                };
                localStorage.setItem('google_calendar_connection', JSON.stringify(connectionData));
                sessionStorage.setItem('google_calendar_session', 'active');
                console.log('✅ Estado de conexão salvo');
            } catch (error) {
                console.error('❌ Erro ao salvar estado:', error);
            }
        }

        function getConnectionState() {
            try {
                const connectionData = localStorage.getItem('google_calendar_connection');
                const sessionData = sessionStorage.getItem('google_calendar_session');
                
                if (!connectionData || !sessionData) return null;
                
                const data = JSON.parse(connectionData);
                
                // Verificar se não passou muito tempo (24 horas)
                const timeElapsed = Date.now() - data.timestamp;
                if (timeElapsed > 24 * 60 * 60 * 1000) {
                    clearConnectionState();
                    return null;
                }
                
                return data;
            } catch (error) {
                console.error('❌ Erro ao recuperar estado:', error);
                return null;
            }
        }

        function clearConnectionState() {
            try {
                localStorage.removeItem('google_calendar_connection');
                sessionStorage.removeItem('google_calendar_session');
                console.log('✅ Estado de conexão removido');
            } catch (error) {
                console.error('❌ Erro ao remover estado:', error);
            }
        }

        async function tryRestoreSession() {
            const savedState = getConnectionState();
            if (savedState && savedState.connected && gapiInited && gisInited) {
                try {
                    // Tentar uma nova autenticação silenciosa
                    tokenClient.requestAccessToken({ prompt: '' });
                } catch (error) {
                    console.log('❌ Não foi possível restaurar sessão automaticamente');
                    clearConnectionState();
                }
            }
        }

        // =================================================================
        // MODAL FUNCTIONS
        // =================================================================
        function closeEventModal() {
            document.getElementById('eventModal').style.display = 'none';
        }

        // =================================================================
        // MESSAGE SYSTEM
        // =================================================================
        function showMessage(message, type = 'info') {
            const container = document.getElementById('messagesContainer');
            if (!container) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const icon = getMessageIcon(type);
            messageDiv.innerHTML = `<i class="fas ${icon}"></i> ${message}`;
            
            // Remove mensagem anterior se existir
            const existingMessage = container.querySelector('.message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            container.appendChild(messageDiv);
            
            // Auto-remove após 5 segundos
            setTimeout(() => {
                messageDiv.remove();
            }, 5000);
        }

        function getMessageIcon(type) {
            switch (type) {
                case 'success': return 'fa-check-circle';
                case 'error': return 'fa-exclamation-triangle';
                case 'warning': return 'fa-exclamation-circle';
                default: return 'fa-info-circle';
            }
        }

        // =================================================================
        // GOOGLE AUTHENTICATION
        // =================================================================
        function handleAuthClick() {
            if (!gapiInited || !gisInited) {
                showMessage('APIs do Google ainda não foram carregadas. Aguarde...', 'error');
                return;
            }

            try {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } catch (error) {
                console.error('❌ Erro na autenticação:', error);
                showMessage('Erro ao tentar conectar com o Google Calendar', 'error');
            }
        }

        async function handleTokenResponse(resp) {
            if (resp.error) {
                console.error('❌ Erro de autenticação:', resp.error);
                showMessage(`Erro de autenticação: ${resp.error}`, 'error');
                return;
            }

            try {
                // Definir token temporariamente para obter informações do usuário
                gapi.client.setToken(resp);
                
                // Obter informações do usuário
                const userInfoResponse = await gapi.client.request({
                    path: 'https://www.googleapis.com/oauth2/v2/userinfo'
                });
                
                const userInfo = userInfoResponse.result;
                console.log('✅ Informações do usuário obtidas:', userInfo.email);
                
                // Chamar função do gerenciador de múltiplas contas
                if (typeof window.onAuthSuccess === 'function') {
                    window.onAuthSuccess(userInfo, resp.access_token);
                } else {
                    console.error('❌ Função onAuthSuccess não encontrada');
                    showMessage('Erro interno: sistema de múltiplas contas não carregado', 'error');
                    return;
                }
                
                // Manter compatibilidade com sistema antigo se for a primeira conta
                const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                if (connectedAccounts.length === 1) {
                    isGoogleConnected = true;
                    saveConnectionState();
                    console.log('✅ Primeira conta conectada, ativando sistema legado');
                    
                    // Carregar eventos filtrados
                    await loadFilteredEvents();
                }
                
            } catch (error) {
                console.error('❌ Erro ao processar token:', error);
                showMessage('Erro ao processar autenticação', 'error');
            }
        }

        function handleSignoutClick() {
            try {
                const token = gapi.client.getToken();
                if (token !== null) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                    isGoogleConnected = false;
                    
                    // Limpar estado de conexão
                    clearConnectionState();
                    
                    console.log('✅ Desconectado do Google Calendar');
                    updateConnectionStatus(false);
                    document.getElementById('calendarSection').style.display = 'none';
                    document.getElementById('filterSection').style.display = 'none';
                    document.getElementById('monthlySummarySection').style.display = 'none';
                    document.getElementById('paymentsListSection').style.display = 'none';
                    showMessage('Desconectado do Google Calendar', 'success');
                }
            } catch (error) {
                console.error('❌ Erro ao desconectar:', error);
                showMessage('Erro ao desconectar', 'error');
            }
        }

        // =================================================================
        // CONNECTION STATUS
        // =================================================================
        function updateConnectionStatus(connected) {
            const connectionStatus = document.getElementById('connectionStatus');
            const authorizeButton = document.getElementById('authorizeButton');
            const signoutButton = document.getElementById('signoutButton');
            const syncButton = document.getElementById('syncButton');
            const createEventButton = document.getElementById('createEventButton'); // ✅ NOVO
            const calendarSection = document.getElementById('calendarSection');
            const filterSection = document.getElementById('filterSection');
            const monthlySummarySection = document.getElementById('monthlySummarySection');
            const paymentsListSection = document.getElementById('paymentsListSection');
            
            if (connected) {
                connectionStatus.className = 'status-indicator status-connected';
                connectionStatus.innerHTML = '<i class="fas fa-check-circle"></i><span>Conectado ao Google Calendar</span>';
                authorizeButton.style.display = 'none';
                signoutButton.style.display = 'block';
                syncButton.disabled = false;
                createEventButton.style.display = 'block'; // ✅ NOVO: Mostrar botão de criar evento
                calendarSection.style.display = 'block';
                filterSection.style.display = 'block';
                monthlySummarySection.style.display = 'block';
                paymentsListSection.style.display = 'block';
            } else {
                connectionStatus.className = 'status-indicator status-disconnected';
                connectionStatus.innerHTML = '<i class="fas fa-times-circle"></i><span>Desconectado do Google Calendar</span>';
                authorizeButton.style.display = 'block';
                signoutButton.style.display = 'none';
                syncButton.disabled = true;
                createEventButton.style.display = 'none'; // ✅ NOVO: Esconder botão de criar evento
                calendarSection.style.display = 'none';
                filterSection.style.display = 'none';
                monthlySummarySection.style.display = 'none';
                paymentsListSection.style.display = 'none';
            }
        }

        // =================================================================
        // EVENT FILTERING
        // =================================================================
        function filterEvents(events) {
            const keywords = ['pagamento', 'pagamentos', 'hvc'];
            
            return events.filter(event => {
                const title = (event.summary || '').toLowerCase();
                const description = (event.description || '').toLowerCase();
                
                return keywords.some(keyword => 
                    title.includes(keyword) || description.includes(keyword)
                );
            });
        }

        function getEventType(event) {
            const title = (event.summary || '').toLowerCase();
            
            if (title.includes('pagamento')) {
                return 'pagamento';
            } else if (title.includes('hvc')) {
                return 'hvc';
            }
            return 'default';
        }

        // =================================================================
        // GOOGLE CALENDAR OPERATIONS
        // =================================================================
        async function loadFilteredEvents() {
            try {
                const now = new Date();
                const startOfYear = new Date(now.getFullYear(), 0, 1);
                const endOfYear = new Date(now.getFullYear(), 11, 31);

                // ✅ NOVO: Verificar se há múltiplas contas conectadas
                const connectedAccounts = window.getConnectedAccounts ? window.getConnectedAccounts() : [];
                
                if (connectedAccounts.length > 1) {
                    console.log(`🔄 Carregando eventos de ${connectedAccounts.length} contas conectadas`);
                    
                    // Carregar eventos de todas as contas
                    const allEventsFromAllAccounts = [];
                    let totalEventsCount = 0;
                    
                    for (const account of connectedAccounts) {
                        try {
                            console.log(`📅 Carregando eventos da conta: ${account.email}`);
                            
                            // Definir token da conta atual
                            gapi.client.setToken({ access_token: account.accessToken });
                            
                            const response = await gapi.client.calendar.events.list({
                                calendarId: 'primary',
                                timeMin: startOfYear.toISOString(),
                                timeMax: endOfYear.toISOString(),
                                showDeleted: false,
                                singleEvents: true,
                                maxResults: 250,
                                orderBy: 'startTime'
                            });

                            const accountEvents = response.result.items || [];
                            totalEventsCount += accountEvents.length;
                            
                            // Adicionar informação da conta a cada evento
                            accountEvents.forEach(event => {
                                event._accountEmail = account.email;
                                event._accountName = account.name || account.email;
                            });
                            
                            allEventsFromAllAccounts.push(...accountEvents);
                            console.log(`✅ ${accountEvents.length} eventos carregados da conta ${account.email}`);
                            
                        } catch (error) {
                            console.error(`❌ Erro ao carregar eventos da conta ${account.email}:`, error);
                            
                            // Marcar conta com erro
                            if (typeof window.multiAccountManager?.updateAccountStatus === 'function') {
                                window.multiAccountManager.updateAccountStatus(account.email, 'error');
                            }
                        }
                    }
                    
                    // Filtrar todos os eventos
                    filteredEvents = filterEvents(allEventsFromAllAccounts);
                    
                    console.log(`✅ Total de eventos carregados: ${totalEventsCount} de ${connectedAccounts.length} contas`);
                    console.log(`✅ Eventos filtrados: ${filteredEvents.length}`);
                    
                    updateFilterStats(totalEventsCount, filteredEvents.length);
                    updateMonthlySummary();
                    renderCalendar();
                    
                    showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados em ${connectedAccounts.length} contas`, 'success');
                    
                } else if (connectedAccounts.length === 1) {
                    // Uma conta conectada - usar sistema tradicional
                    console.log('📅 Carregando eventos da conta única conectada');
                    
                    const account = connectedAccounts[0];
                    gapi.client.setToken({ access_token: account.accessToken });
                    
                    const response = await gapi.client.calendar.events.list({
                        calendarId: 'primary',
                        timeMin: startOfYear.toISOString(),
                        timeMax: endOfYear.toISOString(),
                        showDeleted: false,
                        singleEvents: true,
                        maxResults: 250,
                        orderBy: 'startTime'
                    });

                    const allEvents = response.result.items || [];
                    
                    // Adicionar informação da conta
                    allEvents.forEach(event => {
                        event._accountEmail = account.email;
                        event._accountName = account.name || account.email;
                    });
                    
                    filteredEvents = filterEvents(allEvents);
                    
                    console.log(`✅ Eventos carregados: ${allEvents.length} total, ${filteredEvents.length} filtrados`);
                    
                    updateFilterStats(allEvents.length, filteredEvents.length);
                    updateMonthlySummary();
                    renderCalendar();
                    
                    showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados`, 'success');
                    
                } else {
                    // Nenhuma conta conectada - usar sistema legado se isGoogleConnected for true
                    if (isGoogleConnected && gapi.client.getToken()) {
                        console.log('📅 Usando sistema legado - nenhuma conta no gerenciador');
                        
                        const response = await gapi.client.calendar.events.list({
                            calendarId: 'primary',
                            timeMin: startOfYear.toISOString(),
                            timeMax: endOfYear.toISOString(),
                            showDeleted: false,
                            singleEvents: true,
                            maxResults: 250,
                            orderBy: 'startTime'
                        });

                        const allEvents = response.result.items || [];
                        filteredEvents = filterEvents(allEvents);
                        
                        console.log(`✅ Eventos carregados (legado): ${allEvents.length} total, ${filteredEvents.length} filtrados`);
                        
                        updateFilterStats(allEvents.length, filteredEvents.length);
                        updateMonthlySummary();
                        renderCalendar();
                        
                        showMessage(`${filteredEvents.length} eventos de pagamento/HVC encontrados`, 'success');
                    } else {
                        console.log('⚠️ Nenhuma conta conectada');
                        showMessage('Nenhuma conta conectada ao Google Calendar', 'warning');
                    }
                }
                
            } catch (error) {
                console.error('❌ Erro ao carregar eventos:', error);
                showMessage('Erro ao carregar eventos', 'error');
                
                // Se erro de autenticação, limpar estado
                if (error.status === 401 || error.status === 403) {
                    clearConnectionState();
                    isGoogleConnected = false;
                    updateConnectionStatus(false);
                }
            }
        }

        function updateFilterStats(total, filtered) {
            const statsElement = document.getElementById('filterStats');
            if (statsElement) {
                statsElement.innerHTML = `
                    Total de eventos: ${total} | 
                    Eventos filtrados: ${filtered} | 
                    Palavras-chave: "PAGAMENTO", "PAGAMENTOS", "HVC"
                `;
            }
        }

        // =================================================================
        // CALENDAR RENDERING
        // =================================================================
        function renderCalendar() {
            const calendarGrid = document.getElementById('calendarGrid');
            const calendarTitle = document.getElementById('calendarTitle');
            
            if (!calendarGrid || !calendarTitle) return;
            
            // Update title
            const monthNames = [
                'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
                'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
            ];
            calendarTitle.textContent = `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
            
            // Clear grid
            calendarGrid.innerHTML = '';
            
            // Add day headers - COMEÇANDO NA SEGUNDA-FEIRA
            const dayHeaders = ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb', 'Dom'];
            dayHeaders.forEach(day => {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'calendar-day-header';
                headerDiv.textContent = day;
                calendarGrid.appendChild(headerDiv);
            });
            
            // Get first day of month and number of days
            const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            const startDate = new Date(firstDay);
            
            // Ajustar para começar na segunda-feira (1 = segunda, 0 = domingo)
            const dayOfWeek = firstDay.getDay();
            const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            startDate.setDate(startDate.getDate() - daysToSubtract);
            
            // Generate calendar days
            const today = new Date();
            const todayString = getCalendarDateString(today);
            
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                
                if (cellDate.getMonth() !== currentDate.getMonth()) {
                    dayDiv.classList.add('other-month');
                }
                
                // CORREÇÃO: Comparação precisa para o dia de hoje usando strings de data
                if (getCalendarDateString(cellDate) === todayString) {
                    dayDiv.classList.add('today');
                }
                
                // Day number
                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = cellDate.getDate();
                dayDiv.appendChild(dayNumber);
                
                // Total do dia (apenas PG e PENDENTE)
                const dayTotal = calculateDayTotal(cellDate);
                if (dayTotal > 0) {
                    const totalDiv = document.createElement('div');
                    totalDiv.className = 'day-total';
                    totalDiv.textContent = formatCurrency(dayTotal);
                    dayDiv.appendChild(totalDiv);
                }
                
                // Events for this day - AGRUPADOS
                const dayEvents = document.createElement('div');
                dayEvents.className = 'day-events';
                
                const eventsForDay = getEventsForDay(cellDate);
                if (eventsForDay.length > 0) {
                    // Se há eventos, criar um único "eventão" agrupado
                    const groupedEvent = createGroupedEvent(eventsForDay, cellDate);
                    const eventDiv = document.createElement('div');
                    eventDiv.className = `event-item ${groupedEvent.colorClass}`;
                    eventDiv.textContent = groupedEvent.title;
                    eventDiv.onclick = () => showGroupedEventDetails(eventsForDay, cellDate);
                    dayEvents.appendChild(eventDiv);
                }
                
                dayDiv.appendChild(dayEvents);
                calendarGrid.appendChild(dayDiv);
            }
            
            // Atualizar resumo mensal após renderizar calendário
            updateMonthlySummary();
        }

        // NOVA: Função para criar evento agrupado
        function createGroupedEvent(events, date) {
            const totalEvents = events.length;
            let title = '';
            
            if (totalEvents === 1) {
                title = events[0].summary || 'Pagamento';
            } else {
                title = `${totalEvents} Pagamentos`;
            }
            
            // Determinar cor baseada em todos os itens do dia
            const colorClass = getDayColorClass(events);
            
            return {
                title: title,
                colorClass: colorClass,
                events: events
            };
        }

        // NOVA: Função para determinar cor do dia baseada em todos os eventos
        function getDayColorClass(events) {
            let hasPG = false;
            let hasPendente = false;
            let hasRecalculado = false;
            
            // Analisar todos os itens de todos os eventos do dia
            events.forEach(event => {
                const eventCalc = calculateEventTotal(event);
                eventCalc.payments.forEach(payment => {
                    if (payment.status === 'PG') hasPG = true;
                    else if (payment.status === 'PENDENTE') hasPendente = true;
                    else if (payment.status === 'RECALCULADO') hasRecalculado = true;
                });
            });
            
            // Prioridade: PG > PENDENTE > RECALCULADO
            if (hasPG && !hasPendente && !hasRecalculado) return 'event-pg';
            if (hasPendente && !hasPG && !hasRecalculado) return 'event-pendente';
            if (hasRecalculado && !hasPG && !hasPendente) return 'event-recalculado';
            
            // Se há mistura, usar cor mista
            return 'event-mixed';
        }

        // NOVA: Função para mostrar detalhes do evento agrupado
        async function showGroupedEventDetails(events, date) {
            const modal = document.getElementById('eventModal');
            const title = document.getElementById('eventModalTitle');
            const body = document.getElementById('eventModalBody');
            
            if (!modal || !title || !body) return;
            
            const dateStr = date.toLocaleDateString('pt-BR');
            title.textContent = `Pagamentos de ${dateStr} (${events.length} evento${events.length > 1 ? 's' : ''})`;
            
            let detailsHTML = '';
            let totalDay = 0;
            let allPayments = [];
            
            // Processar todos os eventos do dia
            events.forEach((event, index) => {
                const eventCalc = calculateEventTotal(event);
                totalDay += eventCalc.total;
                allPayments = allPayments.concat(eventCalc.payments);
                
                detailsHTML += `
                    <div class="grouped-event-section">
                        <h4><i class="fas fa-calendar-alt"></i> ${event.summary || 'Evento sem título'}</h4>
                        <div class="event-total-value">
                            ${formatCurrency(eventCalc.total)}
                        </div>
                `;
                
                if (eventCalc.payments.length > 0) {
                    detailsHTML += `
                        <div class="event-values-list">
                            <h5><i class="fas fa-list"></i> Pagamentos (${eventCalc.count}):</h5>
                    `;
                    eventCalc.payments.forEach(payment => {
                        detailsHTML += `
                            <div class="value-item">
                                <div>
                                    <strong>${payment.name}</strong> - ${payment.formattedValue}
                                </div>
                                <div class="value-item-status ${payment.status.toLowerCase()}">
                                    ${payment.status}
                                </div>
                            </div>
                        `;
                    });
                    detailsHTML += '</div>';
                }
                
                detailsHTML += `
                        <div class="event-actions">
                            <button class="btn-secondary" onclick="showEventDetails(${JSON.stringify(event).replace(/"/g, '&quot;')})">
                                <i class="fas fa-eye"></i> Ver Detalhes
                            </button>
                        </div>
                    </div>
                `;
            });
            
            // Resumo do dia
            detailsHTML = `
                <div class="day-summary">
                    <h3><i class="fas fa-chart-line"></i> Resumo do Dia</h3>
                    <div class="day-total-value">
                        Total: ${formatCurrency(totalDay)}
                    </div>
                    <div class="day-stats">
                        <span>📅 ${events.length} evento${events.length > 1 ? 's' : ''}</span>
                        <span>💰 ${allPayments.length} pagamento${allPayments.length > 1 ? 's' : ''}</span>
                    </div>
                </div>
                <hr>
            ` + detailsHTML;
            
            body.innerHTML = detailsHTML;
            modal.style.display = 'block';
        }

        // CORREÇÃO: Função principal para comparar datas dos eventos
        function getEventsForDay(date) {
            const targetDateString = getCalendarDateString(date);
            
            return filteredEvents.filter(event => {
                const eventDate = parseEventDate(event);
                const eventDateString = getCalendarDateString(eventDate);
                
                return eventDateString === targetDateString;
            });
        }

        async function showEventDetails(event) {
            const modal = document.getElementById('eventModal');
            const title = document.getElementById('eventModalTitle');
            const body = document.getElementById('eventModalBody');
            
            if (!modal || !title || !body) return;
            
            title.textContent = event.summary || 'Sem título';
            
            const eventDate = parseEventDate(event);
            const start = eventDate;
            const end = event.end.dateTime ? new Date(event.end.dateTime) : eventDate;
            
            // Calcular valores do evento
            const eventCalc = calculateEventTotal(event);
            
            let detailsHTML = `
                <p><strong><i class="fas fa-calendar"></i> Data:</strong> ${start.toLocaleDateString('pt-BR')}</p>
                <p><strong><i class="fas fa-clock"></i> Horário:</strong> ${event.start.dateTime ? 
                    `${start.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })} - ${end.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}` : 
                    'Dia inteiro'}</p>
                                <div id="descriptionSection">
                                    <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                                    ${event.description ? `
                                        <div id="descriptionDisplay" class="description-display">${event.description}</div>
                                    ` : `
                                        <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                                    `}
                                    <button onclick="startEditingDescription('${event.id}')" class="btn-edit">
                                        <i class="fas fa-edit"></i> ${event.description ? 'Editar Descrição' : 'Adicionar Descrição'}
                                    </button>
                                </div>

                ${event.location ? `<p><strong><i class="fas fa-map-marker-alt"></i> Local:</strong> ${event.location}</p>` : ''}
                <p><strong><i class="fas fa-tag"></i> Tipo:</strong> ${getEventType(event).toUpperCase()}</p>
            `;
            
            // Seção de valores encontrados
            if (eventCalc.count > 0) {
                detailsHTML += `
                    <div class="event-total-section">
                        <div class="event-total-title">
                            <i class="fas fa-calculator"></i> TOTAL CONTABILIZADO (PG + PENDENTE)
                        </div>
                        <div class="event-total-value">
                            ${formatCurrency(eventCalc.total)}
                        </div>
                    </div>
                `;
                
                if (eventCalc.payments.length > 0) {
                    detailsHTML += `
                        <div class="event-values-list">
                            <h4><i class="fas fa-list"></i> Pagamentos Encontrados (${eventCalc.count}):</h4>
                    `;
                    eventCalc.payments.forEach((payment, index) => {
                        detailsHTML += `
                            <div class="value-item">
                                <div>
                                    <strong>${payment.name}</strong> - ${payment.formattedValue}
                                </div>
                                <div class="value-item-status ${payment.status.toLowerCase()}">
                                    ${payment.status}
                                </div>
                            </div>
                        `;
                    });
                    detailsHTML += '</div>';
                }
            }
            
            // ✅ NOVO: Seção de anexos PDF
            detailsHTML += `
                <div class="event-attachments-section">
                    <h4><i class="fas fa-paperclip"></i> Anexos PDF</h4>
                    <div id="eventAttachmentsList" class="event-attachments-list">
                        <!-- Lista de anexos será carregada aqui -->
                    </div>
                    <div class="attachment-upload-section">
                        <input type="file" id="eventPdfInput" multiple accept=".pdf" style="display: none;">
                        <button onclick="document.getElementById('eventPdfInput').click()" class="btn-add-pdf">
                            <i class="fas fa-plus"></i> Adicionar PDF
                        </button>
                    </div>
                </div>
            `;
            
            // ✅ NOVO: Adicionar botão de excluir evento
            detailsHTML += `
                <div class="event-actions">
                    <button onclick="deleteEvent('${event.id}', '${event.summary}')" class="btn-delete">
                        <i class="fas fa-trash"></i> Excluir Evento
                    </button>
                </div>
            `;
            
            body.innerHTML = detailsHTML;
            
            // Configurar upload de PDFs para este evento
            setupEventPdfUpload(event);
            
            // Carregar anexos existentes
            loadEventAttachments(event);
            
            modal.style.display = 'block';
        }

        // =================================================================
        // EVENT PDF MANAGEMENT
        // =================================================================
        
        let currentEventForPdf = null;
        
        function setupEventPdfUpload(event) {
            currentEventForPdf = event;
            const pdfInput = document.getElementById('eventPdfInput');
            if (pdfInput) {
                pdfInput.addEventListener('change', handleEventPdfUpload);
            }
        }
        
        async function handleEventPdfUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0 || !currentEventForPdf) return;
            
            // Mostrar indicador de carregamento
            const uploadSection = document.querySelector('.attachment-upload-section');
            const originalHTML = uploadSection.innerHTML;
            uploadSection.innerHTML = '<p style="color: #007bff;"><i class="fas fa-spinner fa-spin"></i> Fazendo upload...</p>';
            
            let successCount = 0;
            let errorCount = 0;
            const errors = [];
            
            for (const file of files) {
                if (file.type !== 'application/pdf') {
                    errors.push(`${file.name}: Apenas arquivos PDF são permitidos`);
                    errorCount++;
                    continue;
                }
                
                if (file.size > 10 * 1024 * 1024) {
                    errors.push(`${file.name}: Arquivo muito grande (máx. 10MB)`);
                    errorCount++;
                    continue;
                }
                
                try {
                    console.log(`📤 Processando: ${file.name}`);
                    await uploadPdfToEvent(file, currentEventForPdf);
                    successCount++;
                    console.log(`✅ Sucesso: ${file.name}`);
                } catch (error) {
                    console.error(`❌ Erro em ${file.name}:`, error);
                    errors.push(`${file.name}: ${error.message}`);
                    errorCount++;
                }
            }
            
            // Restaurar interface
            uploadSection.innerHTML = originalHTML;
            
            // Mostrar resultado
            let message = '';
            if (successCount > 0) {
                message += `✅ ${successCount} arquivo(s) anexado(s) com sucesso!`;
            }
            if (errorCount > 0) {
                if (message) message += '\n\n';
                message += `❌ ${errorCount} erro(s):\n${errors.join('\n')}`;
            }
            
            if (message) {
                alert(message);
            }
            
            // Limpar input
            event.target.value = '';
        }
        
        async function uploadPdfToEvent(file, event) {
            try {
                console.log('📤 Fazendo upload do PDF para o evento:', file.name);
                
                // Verificar autenticação
                if (!gapi.client.getToken()) {
                    throw new Error('Usuário não está autenticado');
                }
                
                // Converter arquivo para base64
                const base64 = await convertFileToBase64(file);
                
                // Upload para Google Drive
                const driveFile = await uploadPdfToDrive({
                    name: file.name,
                    base64: base64
                }, event.summary);
                
                // Atualizar evento com novo anexo
                await addAttachmentToEvent(event.id, driveFile);
                
                // Recarregar anexos
                await loadEventAttachments(event);
                
                alert(`${file.name} anexado com sucesso!`);
                
            } catch (error) {
                console.error('Erro no upload:', error);
                throw error;
            }
        }
        
        function convertFileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function uploadPdfToDrive(pdfData, eventTitle) {
            try {
                console.log('📤 Iniciando upload para Google Drive:', pdfData.name);
                
                // Verificar se o usuário está autenticado
                const token = gapi.client.getToken();
                if (!token || !token.access_token) {
                    console.error('❌ Token não encontrado, solicitando nova autenticação...');
                    
                    // Solicitar nova autenticação com escopos corretos
                    await new Promise((resolve, reject) => {
                        tokenClient.callback = async (resp) => {
                            if (resp.error !== undefined) {
                                reject(resp);
                            } else {
                                console.log('✅ Nova autenticação realizada');
                                resolve(resp);
                            }
                        };
                        tokenClient.requestAccessToken({prompt: 'consent'});
                    });
                }
                
                // Verificar novamente após autenticação
                const newToken = gapi.client.getToken();
                if (!newToken || !newToken.access_token) {
                    throw new Error('Falha na autenticação. Tente novamente.');
                }
                
                console.log('🔑 Token válido encontrado, prosseguindo com upload...');
                
                // Converter base64 para blob
                const byteCharacters = atob(pdfData.base64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/pdf' });
                
                console.log('📄 Arquivo preparado:', blob.size, 'bytes');
                
                // Metadados do arquivo
                const metadata = {
                    name: `${eventTitle} - ${pdfData.name}`,
                    parents: [] // Salvar na raiz do Drive
                };
                
                // Criar FormData para upload
                const form = new FormData();
                form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
                form.append('file', blob);
                
                console.log('📤 Enviando para Google Drive...');
                
                // Fazer upload usando fetch
                const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${newToken.access_token}`
                    },
                    body: form
                });
                
                console.log('📡 Resposta do Drive:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Erro detalhado:', errorText);
                    
                    if (response.status === 403) {
                        throw new Error('Permissão negada. Você precisa reautenticar com permissões do Google Drive. Clique em "Sincronizar" novamente.');
                    } else if (response.status === 401) {
                        throw new Error('Token expirado. Faça login novamente.');
                    } else {
                        throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
                    }
                }
                
                const fileData = await response.json();
                console.log('✅ Arquivo enviado com sucesso:', fileData.id);
                
                // Tentar tornar arquivo público (opcional)
                try {
                    console.log('🔓 Tornando arquivo público...');
                    await gapi.client.drive.permissions.create({
                        fileId: fileData.id,
                        resource: {
                            role: 'reader',
                            type: 'anyone'
                        }
                    });
                    console.log('✅ Arquivo tornado público');
                } catch (permError) {
                    console.warn('⚠️ Não foi possível tornar o arquivo público (não é crítico):', permError);
                }
                
                return {
                    fileId: fileData.id,
                    fileUrl: `https://drive.google.com/file/d/${fileData.id}/view`,
                    title: `${eventTitle} - ${pdfData.name}`,
                    mimeType: 'application/pdf'
                };
                
            } catch (error) {
                console.error('❌ Erro completo no upload:', error);
                throw error;
            }
        }
        
        async function addAttachmentToEvent(eventId, attachment) {
            try {
                // Buscar evento atual
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                
                // Adicionar novo anexo
                if (!event.attachments) {
                    event.attachments = [];
                }
                event.attachments.push(attachment);
                
                // Atualizar evento
                await gapi.client.calendar.events.update({
                    calendarId: 'primary',
                    eventId: eventId,
                    resource: event,
                    supportsAttachments: true
                });
                
                console.log('✅ Anexo adicionado ao evento');
                
            } catch (error) {
                console.error('Erro ao adicionar anexo ao evento:', error);
                throw error;
            }
        }
        
        async function loadEventAttachments(event) {
            const attachmentsList = document.getElementById('eventAttachmentsList');
            if (!attachmentsList) return;
            
            try {
                // Buscar evento completo com anexos
                const fullEventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: event.id
                });
                
                const fullEvent = fullEventResponse.result;
                
                if (fullEvent.attachments && fullEvent.attachments.length > 0) {
                    const attachmentsHTML = fullEvent.attachments.map(attachment => `
                        <div class="attachment-item">
                            <div class="attachment-info">
                                <i class="fas fa-file-pdf"></i>
                                <span class="attachment-name">${attachment.title || 'Anexo'}</span>
                            </div>
                            <div class="attachment-actions">
                                <button onclick="window.open('${attachment.fileUrl}', '_blank')" class="btn-view-attachment" title="Visualizar">
                                    <i class="fas fa-eye"></i>
                                </button>
                                <button onclick="removeAttachmentFromEvent('${event.id}', '${attachment.fileId}')" class="btn-remove-attachment" title="Remover">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `).join('');
                    
                    attachmentsList.innerHTML = attachmentsHTML;
                } else {
                    attachmentsList.innerHTML = '<p class="no-attachments">Nenhum anexo encontrado</p>';
                }
                
            } catch (error) {
                console.error('Erro ao carregar anexos:', error);
                attachmentsList.innerHTML = '<p class="no-attachments">Erro ao carregar anexos</p>';
            }
        }
        
        async function removeAttachmentFromEvent(eventId, fileId) {
            if (!confirm('Tem certeza que deseja remover este anexo?')) return;
            
            try {
                // Buscar evento atual
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                
                // Remover anexo da lista
                if (event.attachments) {
                    event.attachments = event.attachments.filter(att => att.fileId !== fileId);
                }
                
                // Atualizar evento
                await gapi.client.calendar.events.update({
                    calendarId: 'primary',
                    eventId: eventId,
                    resource: event,
                    supportsAttachments: true
                });
                
                // Recarregar anexos
                await loadEventAttachments(currentEventForPdf);
                
                alert('Anexo removido com sucesso!');
                
            } catch (error) {
                console.error('Erro ao remover anexo:', error);
                alert('Erro ao remover anexo');
            }
        }

        // =================================================================
        // EVENT DELETION
        // =================================================================
        // EVENT DELETION WITH RECURRENCE SUPPORT
        // =================================================================
        async function deleteEvent(eventId, eventTitle) {
            if (!isGoogleConnected) {
                alert('Conecte-se ao Google Calendar primeiro');
                return;
            }
            
            try {
                // Buscar detalhes completos do evento para verificar recorrência
                const eventResponse = await gapi.client.calendar.events.get({
                    calendarId: 'primary',
                    eventId: eventId
                });
                
                const event = eventResponse.result;
                const isRecurring = event.recurringEventId || event.recurrence;
                
                if (isRecurring) {
                    // Evento recorrente - mostrar opções
                    const choice = await showRecurrenceDeleteDialog(eventTitle);
                    if (!choice) return; // Usuário cancelou
                    
                    await handleRecurringEventDeletion(event, choice);
                } else {
                    // Evento único - confirmação simples
                    const confirmMessage = `Tem certeza que deseja excluir o evento "${eventTitle}"?\n\nEsta ação não pode ser desfeita.`;
                    if (!confirm(confirmMessage)) {
                        return;
                    }
                    
                    await gapi.client.calendar.events.delete({
                        calendarId: 'primary',
                        eventId: eventId
                    });
                    
                    console.log('✅ Evento excluído:', eventTitle);
                    alert('Evento excluído com sucesso!');
                }
                
                // Fechar modal e recarregar
                const eventModal = document.getElementById('eventModal');
                if (eventModal) {
                    eventModal.style.display = 'none';
                }
                await handleSyncClick();
                
            } catch (error) {
                console.error('❌ Erro ao excluir evento:', error);
                alert('Erro ao excluir evento. Verifique sua conexão e tente novamente.');
            }
        }

        // Função para mostrar dialog de opções de recorrência para exclusão
        function showRecurrenceDeleteDialog(eventTitle) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'recurrence-modal';
                modal.innerHTML = `
                    <div class="recurrence-modal-content">
                        <h3><i class="fas fa-exclamation-triangle"></i> Excluir Evento Recorrente</h3>
                        <p>O evento "<strong>${eventTitle}</strong>" faz parte de uma série recorrente.</p>
                        <p>Como você gostaria de excluir?</p>
                        
                        <div class="recurrence-options">
                            <button class="recurrence-btn" data-choice="this">
                                <i class="fas fa-calendar-day"></i>
                                <div class="recurrence-btn-content">
                                    <span>Apenas este evento</span>
                                    <small>Exclui somente esta ocorrência</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="following">
                                <i class="fas fa-calendar-week"></i>
                                <div class="recurrence-btn-content">
                                    <span>Este e eventos seguintes</span>
                                    <small>Exclui esta ocorrência e todas as futuras</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="all">
                                <i class="fas fa-calendar"></i>
                                <div class="recurrence-btn-content">
                                    <span>Todos os eventos da série</span>
                                    <small>Exclui toda a série recorrente</small>
                                </div>
                            </button>
                        </div>
                        
                        <div class="recurrence-actions">
                            <button class="recurrence-cancel">Cancelar</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Event listeners
                modal.querySelectorAll('.recurrence-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
                
                modal.querySelector('.recurrence-cancel').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
                
                // Fechar ao clicar fora
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                        resolve(null);
                    }
                });
            });
        }

        // Função para mostrar dialog de opções de recorrência para edição
        function showRecurrenceEditDialog(eventTitle) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'recurrence-modal';
                modal.innerHTML = `
                    <div class="recurrence-modal-content">
                        <h3><i class="fas fa-edit"></i> Editar Evento Recorrente</h3>
                        <p>O evento "<strong>${eventTitle}</strong>" faz parte de uma série recorrente.</p>
                        <p>Como você gostaria de editar?</p>
                        
                        <div class="recurrence-options">
                            <button class="recurrence-btn" data-choice="this">
                                <i class="fas fa-calendar-day"></i>
                                <div class="recurrence-btn-content">
                                    <span>Apenas este evento</span>
                                    <small>Edita somente esta ocorrência</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="following">
                                <i class="fas fa-calendar-week"></i>
                                <div class="recurrence-btn-content">
                                    <span>Este e eventos seguintes</span>
                                    <small>Edita esta ocorrência e todas as futuras</small>
                                </div>
                            </button>
                            
                            <button class="recurrence-btn" data-choice="all">
                                <i class="fas fa-calendar"></i>
                                <div class="recurrence-btn-content">
                                    <span>Todos os eventos da série</span>
                                    <small>Edita toda a série recorrente</small>
                                </div>
                            </button>
                        </div>
                        
                        <div class="recurrence-actions">
                            <button class="recurrence-cancel">Cancelar</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Event listeners
                modal.querySelectorAll('.recurrence-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const choice = btn.dataset.choice;
                        document.body.removeChild(modal);
                        resolve(choice);
                    });
                });
                
                modal.querySelector('.recurrence-cancel').addEventListener('click', () => {
                    document.body.removeChild(modal);
                    resolve(null);
                });
                
                // Fechar ao clicar fora
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                        resolve(null);
                    }
                });
            });
        }

        // Função para lidar com exclusão de eventos recorrentes
        async function handleRecurringEventDeletion(event, choice) {
            switch (choice) {
                case 'this':
                    // Excluir apenas esta instância
                    if (event.recurringEventId) {
                        // É uma instância de evento recorrente
                        await gapi.client.calendar.events.delete({
                            calendarId: 'primary',
                            eventId: event.id
                        });
                    } else {
                        // É o evento principal - criar exceção
                        // Isso é mais complexo, por simplicidade vamos excluir a instância
                        await gapi.client.calendar.events.delete({
                            calendarId: 'primary',
                            eventId: event.id
                        });
                    }
                    break;
                    
                case 'following':
                    // Excluir este e eventos seguintes
                    if (event.recurringEventId) {
                        // Buscar evento principal e modificar até esta data
                        const masterEvent = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: event.recurringEventId
                        });
                        
                        // Modificar recorrência para terminar antes desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000); // Um dia antes
                        
                        const updatedRecurrence = masterEvent.result.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.recurringEventId,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                    } else {
                        // É o evento principal - modificar recorrência
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000);
                        
                        const updatedRecurrence = event.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                    }
                    break;
                    
                case 'all':
                    // Excluir toda a série
                    const masterEventId = event.recurringEventId || event.id;
                    await gapi.client.calendar.events.delete({
                        calendarId: 'primary',
                        eventId: masterEventId
                    });
                    break;
            }
            
            console.log('✅ Evento(s) excluído(s) com sucesso');
            alert('Evento(s) excluído(s) com sucesso!');
        }

        // Função para lidar com edição de eventos recorrentes
        async function handleRecurringEventEdit(event, choice, newDescription) {
            switch (choice) {
                case 'this':
                    // Editar apenas esta instância
                    if (event.recurringEventId) {
                        // É uma instância de evento recorrente - editar diretamente
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                description: newDescription
                            }
                        });
                    } else {
                        // É o evento principal - criar uma exceção
                        // Para simplificar, vamos editar o evento principal
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                description: newDescription
                            }
                        });
                    }
                    break;
                    
                case 'following':
                    // Editar este e eventos seguintes
                    if (event.recurringEventId) {
                        // Buscar evento principal e modificar a partir desta data
                        const masterEvent = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: event.recurringEventId
                        });
                        
                        // Terminar a série original antes desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000); // Um dia antes
                        
                        const updatedRecurrence = masterEvent.result.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.recurringEventId,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                        
                        // Criar nova série a partir desta data com a nova descrição
                        const newEvent = {
                            ...masterEvent.result,
                            description: newDescription,
                            start: event.start,
                            end: event.end
                        };
                        delete newEvent.id;
                        delete newEvent.etag;
                        delete newEvent.htmlLink;
                        delete newEvent.iCalUID;
                        delete newEvent.created;
                        delete newEvent.updated;
                        
                        await gapi.client.calendar.events.insert({
                            calendarId: 'primary',
                            resource: newEvent
                        });
                    } else {
                        // É o evento principal - modificar a partir desta data
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const until = new Date(eventDate.getTime() - 24 * 60 * 60 * 1000);
                        
                        const updatedRecurrence = event.recurrence.map(rule => {
                            if (rule.startsWith('RRULE:')) {
                                return rule + `;UNTIL=${until.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`;
                            }
                            return rule;
                        });
                        
                        await gapi.client.calendar.events.patch({
                            calendarId: 'primary',
                            eventId: event.id,
                            resource: {
                                recurrence: updatedRecurrence
                            }
                        });
                        
                        // Criar nova série com a nova descrição
                        const newEvent = {
                            ...event,
                            description: newDescription
                        };
                        delete newEvent.id;
                        delete newEvent.etag;
                        delete newEvent.htmlLink;
                        delete newEvent.iCalUID;
                        delete newEvent.created;
                        delete newEvent.updated;
                        
                        await gapi.client.calendar.events.insert({
                            calendarId: 'primary',
                            resource: newEvent
                        });
                    }
                    break;
                    
                case 'all':
                    // Editar toda a série
                    console.log('🔄 Editando toda a série de eventos recorrentes');
                    console.log('📋 Evento atual:', event);
                    
                    let masterEventId;
                    let masterEvent;
                    
                    if (event.recurringEventId) {
                        // É uma instância - buscar o evento principal
                        masterEventId = event.recurringEventId;
                        console.log('📌 Evento é uma instância, buscando master ID:', masterEventId);
                        
                        try {
                            const masterResponse = await gapi.client.calendar.events.get({
                                calendarId: 'primary',
                                eventId: masterEventId
                            });
                            masterEvent = masterResponse.result;
                            console.log('📋 Evento master encontrado:', masterEvent);
                        } catch (error) {
                            console.error('❌ Erro ao buscar evento master:', error);
                            throw new Error('Não foi possível encontrar o evento principal da série');
                        }
                    } else {
                        // É o evento principal
                        masterEventId = event.id;
                        masterEvent = event;
                        console.log('📌 Evento é o principal, ID:', masterEventId);
                    }
                    
                    console.log('🎯 Atualizando evento master:', masterEventId);
                    console.log('📝 Nova descrição:', newDescription);
                    
                    const updateResult = await gapi.client.calendar.events.patch({
                        calendarId: 'primary',
                        eventId: masterEventId,
                        resource: {
                            description: newDescription
                        }
                    });
                    
                    console.log('✅ Resultado da atualização:', updateResult);
                    
                    // Verificar se a atualização foi bem-sucedida
                    if (updateResult.status === 200) {
                        console.log('✅ Evento master atualizado com sucesso');
                        
                        // Aguardar um pouco para que o Google Calendar processe a mudança
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        console.log('🔄 Verificando se a atualização foi aplicada...');
                        const verificationResponse = await gapi.client.calendar.events.get({
                            calendarId: 'primary',
                            eventId: masterEventId
                        });
                        
                        console.log('📋 Descrição após atualização:', verificationResponse.result.description);
                    } else {
                        throw new Error(`Falha na atualização: status ${updateResult.status}`);
                    }
                    break;
            }
            
            console.log('✅ Evento(s) editado(s) com sucesso');
            return true;
        }

        // =================================================================
        // CALENDAR NAVIGATION
        // =================================================================
        function previousMonth() {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        }

        function nextMonth() {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        }

        function goToToday() {
            currentDate = new Date();
            renderCalendar();
        }

        async function handleSyncClick() {
            if (!isGoogleConnected) {
                showMessage('Conecte-se ao Google Calendar primeiro', 'error');
                return;
            }

            const syncButton = document.getElementById('syncButton');
            syncButton.innerHTML = '<div class="spinner"></div> Sincronizando...';
            syncButton.disabled = true;

            try {
                await loadFilteredEvents();
                showMessage('Sincronização concluída com sucesso!', 'success');
            } catch (error) {
                console.error('❌ Erro na sincronização:', error);
                showMessage('Erro durante a sincronização', 'error');
            } finally {
                syncButton.innerHTML = '<i class="fas fa-sync-alt"></i> Sincronizar';
                syncButton.disabled = false;
            }
        }

        // =================================================================
        // WINDOW CLICK HANDLER
        // =================================================================
        window.onclick = function(event) {
            const eventModal = document.getElementById('eventModal');
            if (event.target === eventModal) {
                eventModal.style.display = 'none';
            }
        }


                    // =================================================================
                    // ✅ NOVO: SISTEMA COMPLETO DE EDIÇÃO DE DESCRIÇÃO
                    // =================================================================
            
                    /**
                     * Inicia o modo de edição da descrição do evento
                     * @param {string} eventId - ID do evento a ser editado
                     */
                    function startEditingDescription(eventId) {
                        console.log('🔄 Iniciando edição da descrição para evento:', eventId);
                        
                        // Verificar se já está editando
                        if (isEditingDescription) {
                            showMessage('Já existe uma edição em andamento. Finalize a edição atual primeiro.', 'warning');
                            return;
                        }
                        
                        // Encontrar o evento
                        const event = filteredEvents.find(e => e.id === eventId);
                        if (!event) {
                            console.error('❌ Evento não encontrado:', eventId);
                            showMessage('Evento não encontrado', 'error');
                            return;
                        }
                        
                        // Configurar estado de edição
                        currentEditingEvent = event;
                        isEditingDescription = true;
                        originalDescription = event.description || '';
                        
                        console.log('✅ Modo de edição ativado para:', event.summary);
                        
                        // Obter elemento da seção de descrição
                        const descriptionSection = document.getElementById('descriptionSection');
                        if (!descriptionSection) {
                            console.error('❌ Elemento descriptionSection não encontrado');
                            showMessage('Erro interno: elemento não encontrado', 'error');
                            return;
                        }
                        
                        // Gerar HTML do modo de edição
                        descriptionSection.innerHTML = `
                            <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                            <div class="edit-description-section">
                                <textarea 
                                    id="editDescriptionTextarea" 
                                    class="edit-description-textarea" 
                                    placeholder="Digite a descrição do evento...&#10;&#10;Dica: Você pode usar quebras de linha e formatação de texto."
                                >${originalDescription}</textarea>
                                
                                <div class="edit-hint">
                                    <i class="fas fa-info-circle"></i> 
                                    Pressione Ctrl+Enter para salvar rapidamente
                                </div>
                                
                                <div class="edit-buttons">
                                    <button onclick="saveEventDescription()" class="btn-edit btn-save" id="saveDescriptionBtn">
                                        <i class="fas fa-save"></i> Salvar
                                    </button>
                                    <button onclick="cancelEditingDescription()" class="btn-edit btn-cancel" id="cancelDescriptionBtn">
                                        <i class="fas fa-times"></i> Cancelar
                                    </button>
                                </div>
                                
                                <div id="editLoadingIndicator" class="edit-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <span>Salvando alterações no Google Calendar...</span>
                                </div>
                            </div>
                        `;
                        
                        // Focar no textarea e posicionar cursor no final
                        setTimeout(() => {
                            const textarea = document.getElementById('editDescriptionTextarea');
                            if (textarea) {
                                textarea.focus();
                                // Posicionar cursor no final do texto
                                const textLength = textarea.value.length;
                                textarea.setSelectionRange(textLength, textLength);
                                
                                console.log('✅ Textarea focado e cursor posicionado');
                            }
                        }, 100);
                    }
            
                    /**
                     * Cancela a edição da descrição e restaura o estado original
                     */
                    function cancelEditingDescription() {
                        console.log('🔄 Cancelando edição da descrição');
                        
                        if (!currentEditingEvent) {
                            console.warn('⚠️ Nenhum evento sendo editado');
                            return;
                        }
                        
                        // Resetar estado
                        const event = currentEditingEvent;
                        isEditingDescription = false;
                        currentEditingEvent = null;
                        originalDescription = '';
                        
                        // Restaurar visualização original
                        const descriptionSection = document.getElementById('descriptionSection');
                        if (!descriptionSection) {
                            console.error('❌ Elemento descriptionSection não encontrado');
                            return;
                        }
                        
                        descriptionSection.innerHTML = `
                            <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                            ${event.description ? `
                                <div id="descriptionDisplay" class="description-display">${event.description}</div>
                            ` : `
                                <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                            `}
                            <button onclick="startEditingDescription('${event.id}')" class="btn-edit">
                                <i class="fas fa-edit"></i> ${event.description ? 'Editar Descrição' : 'Adicionar Descrição'}
                            </button>
                        `;
                        
                        console.log('✅ Edição cancelada e interface restaurada');
                    }
            
                    /**
                     * Salva a descrição editada no Google Calendar
                     */
                    async function saveEventDescription() {
                        console.log('🔄 Iniciando salvamento da descrição');
                        
                        // Validações iniciais
                        if (!currentEditingEvent || !isEditingDescription) {
                            console.error('❌ Estado de edição inválido');
                            showMessage('Erro interno: estado de edição inválido', 'error');
                            return;
                        }
                        
                        // Obter elementos
                        const textarea = document.getElementById('editDescriptionTextarea');
                        const loadingIndicator = document.getElementById('editLoadingIndicator');
                        const saveBtn = document.getElementById('saveDescriptionBtn');
                        const cancelBtn = document.getElementById('cancelDescriptionBtn');
                        
                        if (!textarea) {
                            console.error('❌ Textarea não encontrado');
                            showMessage('Erro interno: campo de texto não encontrado', 'error');
                            return;
                        }
                        
                        // Obter nova descrição
                        const newDescription = textarea.value.trim();
                        const eventId = currentEditingEvent.id;
                        
                        console.log('📝 Nova descrição:', newDescription.substring(0, 100) + (newDescription.length > 100 ? '...' : ''));
                        
                        // Verificar se houve mudança
                        if (newDescription === originalDescription) {
                            console.log('ℹ️ Descrição não foi alterada');
                            showMessage('Nenhuma alteração foi feita', 'warning');
                            cancelEditingDescription();
                            return;
                        }
                        
                        // Mostrar loading e desabilitar botões
                        if (loadingIndicator) loadingIndicator.style.display = 'flex';
                        if (saveBtn) saveBtn.disabled = true;
                        if (cancelBtn) cancelBtn.disabled = true;
                        
                        try {
                            console.log('🔄 Verificando se o evento é recorrente...');
                            
                            // Buscar detalhes completos do evento para verificar recorrência
                            const eventResponse = await gapi.client.calendar.events.get({
                                calendarId: 'primary',
                                eventId: eventId
                            });
                            
                            const event = eventResponse.result;
                            const isRecurring = event.recurringEventId || event.recurrence;
                            
                            if (isRecurring) {
                                // Evento recorrente - mostrar opções
                                console.log('🔄 Evento recorrente detectado, mostrando opções...');
                                
                                // Esconder loading temporariamente
                                if (loadingIndicator) loadingIndicator.style.display = 'none';
                                if (saveBtn) saveBtn.disabled = false;
                                if (cancelBtn) cancelBtn.disabled = false;
                                
                                const choice = await showRecurrenceEditDialog(event.summary || 'Evento');
                                if (!choice) {
                                    console.log('ℹ️ Usuário cancelou a edição');
                                    return; // Usuário cancelou
                                }
                                
                                // Mostrar loading novamente
                                if (loadingIndicator) loadingIndicator.style.display = 'flex';
                                if (saveBtn) saveBtn.disabled = true;
                                if (cancelBtn) cancelBtn.disabled = true;
                                
                                console.log('🔄 Aplicando edição com escolha:', choice);
                                await handleRecurringEventEdit(event, choice, newDescription);
                                
                                // Forçar sincronização para garantir que as mudanças sejam refletidas
                                console.log('🔄 Forçando sincronização após edição de evento recorrente...');
                                await loadFilteredEvents();
                                console.log('✅ Sincronização concluída');
                                
                            } else {
                                // Evento único - edição simples
                                console.log('🔄 Evento único, editando diretamente...');
                                
                                const response = await gapi.client.calendar.events.patch({
                                    calendarId: 'primary',
                                    eventId: eventId,
                                    resource: {
                                        description: newDescription
                                    }
                                });
                                
                                console.log('📡 Resposta da API:', response.status);
                                
                                if (response.status !== 200) {
                                    throw new Error(`Resposta inesperada da API: ${response.status}`);
                                }
                            }
                            
                            console.log('✅ Descrição salva com sucesso no Google Calendar');
                            
                            // Atualizar evento local
                            currentEditingEvent.description = newDescription;
                            
                            // Atualizar na lista de eventos filtrados
                            const eventIndex = filteredEvents.findIndex(e => e.id === eventId);
                            if (eventIndex !== -1) {
                                filteredEvents[eventIndex].description = newDescription;
                                console.log('✅ Evento atualizado na lista local');
                            }
                            
                            // Resetar estado de edição
                            const eventForDisplay = currentEditingEvent;
                            isEditingDescription = false;
                            currentEditingEvent = null;
                            originalDescription = '';
                            
                            // Restaurar visualização com nova descrição
                            const descriptionSection = document.getElementById('descriptionSection');
                            if (descriptionSection) {
                                descriptionSection.innerHTML = `
                                    <p><strong><i class="fas fa-info-circle"></i> Descrição:</strong></p>
                                    ${newDescription ? `
                                        <div id="descriptionDisplay" class="description-display">${newDescription}</div>
                                    ` : `
                                        <div id="descriptionDisplay" class="description-display description-empty">Nenhuma descrição</div>
                                    `}
                                    <button onclick="startEditingDescription('${eventForDisplay.id}')" class="btn-edit">
                                        <i class="fas fa-edit"></i> ${newDescription ? 'Editar Descrição' : 'Adicionar Descrição'}
                                    </button>
                                `;
                            }
                            
                            // Atualizar resumo mensal (caso a descrição tenha valores)
                            console.log('🔄 Atualizando resumo mensal...');
                            updateMonthlySummary();
                            
                            // Renderizar calendário novamente
                            console.log('🔄 Renderizando calendário...');
                            renderCalendar();
                            
                            showMessage('Descrição atualizada com sucesso!', 'success');
                            
                        } catch (error) {
                            console.error('❌ Erro ao salvar descrição:', error);
                            
                            let errorMessage = 'Erro ao salvar descrição. ';
                            
                            if (error.status === 401) {
                                errorMessage += 'Sessão expirada. Reconecte-se ao Google Calendar.';
                            } else if (error.status === 403) {
                                errorMessage += 'Sem permissão para editar este evento.';
                            } else if (error.status === 404) {
                                errorMessage += 'Evento não encontrado no Google Calendar.';
                            } else {
                                errorMessage += 'Tente novamente em alguns instantes.';
                            }
                            
                            showMessage(errorMessage, 'error');
                            
                            // Reabilitar botões em caso de erro
                            if (saveBtn) saveBtn.disabled = false;
                            if (cancelBtn) cancelBtn.disabled = false;
                            
                        } finally {
                            // Esconder loading
                            if (loadingIndicator) {
                                loadingIndicator.style.display = 'none';
                            }
                            
                            console.log('🔄 Processo de salvamento finalizado');
                        }
                    }
            
                    /**
                     * Manipulador de eventos de teclado para atalhos
                     */
                    function handleEditingKeyboard(event) {
                        if (!isEditingDescription) return;
                        
                        // Ctrl+Enter para salvar
                        if (event.ctrlKey && event.key === 'Enter') {
                            event.preventDefault();
                            console.log('⌨️ Atalho Ctrl+Enter detectado');
                            saveEventDescription();
                            return;
                        }
                        
                        // Escape para cancelar
                        if (event.key === 'Escape') {
                            event.preventDefault();
                            console.log('⌨️ Atalho Escape detectado');
                            cancelEditingDescription();
                            return;
                        }
                    }
            
                    // Adicionar listener para atalhos de teclado
                    document.addEventListener('keydown', handleEditingKeyboard);

        // =================================================================
        // FUNÇÕES DE RECORRÊNCIA PERSONALIZADA
        // =================================================================
        
        /**
         * Manipula a mudança no dropdown de recorrência
         */
        function handleRecurrenceChange() {
            const select = document.getElementById('eventRecurrence');
            if (select.value === 'CUSTOM') {
                showCustomRecurrenceModal();
            }
        }

        /**
         * Mostra o modal de recorrência personalizada
         */
        function showCustomRecurrenceModal() {
            const modal = document.getElementById('customRecurrenceModal');
            if (modal) {
                modal.style.display = 'flex';
                
                // Configurar data padrão baseada na data do evento
                const eventDate = document.getElementById('eventDate').value;
                if (eventDate) {
                    const date = new Date(eventDate);
                    const dayOfWeek = date.getDay();
                    
                    // Selecionar o dia da semana correspondente
                    document.querySelectorAll('.weekday-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    
                    const weekdayBtn = document.querySelector(`[data-day="${dayOfWeek}"]`);
                    if (weekdayBtn) {
                        weekdayBtn.classList.add('selected');
                    }
                    
                    // Configurar data de término padrão (3 meses depois)
                    const endDate = new Date(date);
                    endDate.setMonth(endDate.getMonth() + 3);
                    document.getElementById('endDateValue').value = endDate.toISOString().split('T')[0];
                }
                
                // Configurar event listeners
                setupCustomRecurrenceListeners();
            }
        }

        /**
         * Configura os event listeners do modal de recorrência
         */
        function setupCustomRecurrenceListeners() {
            // Listener para mudança de unidade de tempo
            const unitSelect = document.getElementById('recurrenceUnit');
            unitSelect.addEventListener('change', function() {
                const weekdaysGroup = document.getElementById('weekdaysGroup');
                if (this.value === 'week') {
                    weekdaysGroup.style.display = 'block';
                } else {
                    weekdaysGroup.style.display = 'none';
                }
            });

            // Listeners para botões de dias da semana
            document.querySelectorAll('.weekday-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.classList.toggle('selected');
                });
            });

            // Listeners para opções de término
            document.querySelectorAll('input[name="endType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    const endDateInput = document.getElementById('endDateValue');
                    const endCountInput = document.getElementById('endCountValue');
                    
                    endDateInput.disabled = this.value !== 'date';
                    endCountInput.disabled = this.value !== 'count';
                });
            });

            // Fechar modal ao clicar fora
            const modal = document.getElementById('customRecurrenceModal');
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeCustomRecurrenceModal();
                }
            });
        }

        /**
         * Fecha o modal de recorrência personalizada
         */
        function closeCustomRecurrenceModal() {
            const modal = document.getElementById('customRecurrenceModal');
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Resetar dropdown para "Não se repete"
            const select = document.getElementById('eventRecurrence');
            select.value = 'NONE';
        }

        /**
         * Confirma a recorrência personalizada e gera RRULE
         */
        function confirmCustomRecurrence() {
            const interval = parseInt(document.getElementById('recurrenceInterval').value) || 1;
            const unit = document.getElementById('recurrenceUnit').value;
            const endType = document.querySelector('input[name="endType"]:checked').value;
            
            let rrule = '';
            let description = '';
            
            // Gerar RRULE baseado na unidade
            switch (unit) {
                case 'day':
                    rrule = `FREQ=DAILY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Todos os dias' : `A cada ${interval} dias`;
                    break;
                    
                case 'week':
                    const selectedDays = [];
                    document.querySelectorAll('.weekday-btn.selected').forEach(btn => {
                        const day = parseInt(btn.dataset.day);
                        const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
                        selectedDays.push(rruleDays[day]);
                    });
                    
                    if (selectedDays.length > 0) {
                        rrule = `FREQ=WEEKLY;INTERVAL=${interval};BYDAY=${selectedDays.join(',')}`;
                        if (interval === 1) {
                            description = selectedDays.length === 7 ? 'Todos os dias' : 
                                         selectedDays.length === 5 && !selectedDays.includes('SU') && !selectedDays.includes('SA') ? 'Dias úteis' :
                                         `Semanal: ${selectedDays.join(', ')}`;
                        } else {
                            description = `A cada ${interval} semanas: ${selectedDays.join(', ')}`;
                        }
                    } else {
                        alert('Selecione pelo menos um dia da semana');
                        return;
                    }
                    break;
                    
                case 'month':
                    rrule = `FREQ=MONTHLY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Mensalmente' : `A cada ${interval} meses`;
                    break;
                    
                case 'year':
                    rrule = `FREQ=YEARLY;INTERVAL=${interval}`;
                    description = interval === 1 ? 'Anualmente' : `A cada ${interval} anos`;
                    break;
            }
            
            // Adicionar término se especificado
            if (endType === 'date') {
                const endDate = document.getElementById('endDateValue').value;
                if (endDate) {
                    const formattedDate = endDate.replace(/-/g, '');
                    rrule += `;UNTIL=${formattedDate}T235959Z`;
                    description += ` até ${new Date(endDate).toLocaleDateString('pt-BR')}`;
                }
            } else if (endType === 'count') {
                const count = parseInt(document.getElementById('endCountValue').value) || 10;
                rrule += `;COUNT=${count}`;
                description += ` por ${count} ocorrências`;
            }
            
            // Salvar RRULE personalizada
            window.customRRule = rrule;
            window.customRecurrenceDescription = description;
            
            // Atualizar dropdown com descrição personalizada
            const select = document.getElementById('eventRecurrence');
            
            // Remover opção personalizada anterior se existir
            const existingCustom = select.querySelector('option[value="CUSTOM_GENERATED"]');
            if (existingCustom) {
                existingCustom.remove();
            }
            
            // Adicionar nova opção personalizada
            const customOption = document.createElement('option');
            customOption.value = 'CUSTOM_GENERATED';
            customOption.textContent = description;
            customOption.selected = true;
            
            // Inserir antes da opção "Personalizar..."
            const personalizeOption = select.querySelector('option[value="CUSTOM"]');
            select.insertBefore(customOption, personalizeOption);
            
            // Fechar modal
            closeCustomRecurrenceModal();
            
            console.log('✅ Recorrência personalizada configurada:', { rrule, description });
        }

        /**
         * Gera RRULE baseado na seleção do dropdown
         */
        function generateRRule(recurrenceType, eventDate) {
            const date = new Date(eventDate);
            const dayOfWeek = date.getDay();
            const dayOfMonth = date.getDate();
            const month = date.getMonth() + 1;
            
            // Mapear dias da semana para RRULE
            const rruleDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
            const currentDay = rruleDays[dayOfWeek];
            
            switch (recurrenceType) {
                case 'NONE':
                    return null;
                    
                case 'DAILY':
                    return 'FREQ=DAILY';
                    
                case 'WEEKLY':
                    return `FREQ=WEEKLY;BYDAY=${currentDay}`;
                    
                case 'MONTHLY':
                    // Calcular qual semana do mês (primeira, segunda, terceira, etc.)
                    const weekOfMonth = Math.ceil(dayOfMonth / 7);
                    return `FREQ=MONTHLY;BYDAY=${weekOfMonth}${currentDay}`;
                    
                case 'YEARLY':
                    return `FREQ=YEARLY;BYMONTH=${month};BYMONTHDAY=${dayOfMonth}`;
                    
                case 'WEEKDAYS':
                    return 'FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR';
                    
                case 'CUSTOM_GENERATED':
                    return window.customRRule || null;
                    
                default:
                    return null;
            }
        }


        
        // =================================================================
        // INICIALIZAÇÃO
        // =================================================================
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Sistema de Fluxo de Caixa HVC inicializado');
            
            // Inicializar estado de conexão
            updateConnectionStatus(false);
            
            // Renderizar calendário inicial (vazio)
            renderCalendar();
            
            // ✅ NOVO: Inicializar filtros de pagamentos
            initializePaymentFilters();
        });
    </script>
</head>

<body>
    <div id="main-content-fluxo-caixa-hvc">
        <!-- Messages Container -->
        <div id="messagesContainer"></div>

        <!-- Header -->
        <div class="hvc-container">
            <h1 class="hvc-title">
                <i class="fas fa-chart-line"></i>
                Fluxo de Caixa HVC - Agenda e Pagamentos
            </h1>
        </div>

        <!-- ✅ NOVO: Seção de Gerenciamento de Contas Google -->
        <div class="accounts-section">
            <h2><i class="fab fa-google"></i> Contas Google Calendar</h2>
            
            <div id="accountsList" class="accounts-list">
                <!-- A lista de contas será renderizada aqui -->
            </div>

            <div class="add-account-section">
                <button id="addAccountButton" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Adicionar Nova Conta
                </button>
                 <button id="syncAllButton" class="btn btn-secondary" disabled>
                    <i class="fas fa-sync-alt"></i> Sincronizar Todas as Contas
                </button>
            </div>
        </div>

        <!-- Filter Information -->
        <div id="filterSection" class="filter-section" style="display: none;">
            <div class="filter-info">
                <i class="fas fa-filter"></i>
                <span>Filtro Ativo: Eventos com palavras-chave relacionadas a pagamentos</span>
            </div>
            <div class="filter-stats" id="filterStats">
                <!-- Stats will be populated here -->
            </div>
        </div>

        <!-- ✅ NOVO: Seção de Criação de Eventos -->
        <div id="eventCreatorSection" class="event-creator-section" style="display: none;">
            <h3><i class="fas fa-plus-circle"></i> Criar Evento de Pagamento</h3>
            
            <!-- Lista de Itens de Pagamento -->
            <div class="payment-items-container">
                <h4><i class="fas fa-list"></i> Itens de Pagamento</h4>
                
                <!-- Formulário para Adicionar Item -->
                <div class="add-item-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tipo</label>
                            <input type="text" id="itemTipo" placeholder="Ex: Despesa, Investimento...">
                        </div>
                        <div class="form-group">
                            <label>Subtipo</label>
                            <input type="text" id="itemSubtipo" placeholder="Ex: Fixa, Variável...">
                        </div>
                        <div class="form-group">
                            <label>Categoria</label>
                            <input type="text" id="itemCategoria" placeholder="Ex: Alimentação, Transporte...">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Nome do Item *</label>
                            <input type="text" id="itemNome" placeholder="Nome do item (obrigatório)" required>
                        </div>
                        <div class="form-group">
                            <label>Valor *</label>
                            <input type="text" id="itemValor" placeholder="R$ 0,00" required>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="itemStatus">
                                <option value="">Selecionar...</option>
                                <option value="PG">PG</option>
                                <option value="PENDENTE">PENDENTE</option>
                                <option value="RECALCULADO">RECALCULADO</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group full-width">
                            <label>Detalhe</label>
                            <input type="text" id="itemDetalhe" placeholder="Detalhes adicionais...">
                        </div>
                    </div>
                    
                    <button type="button" id="addItemBtn" class="add-item-btn">
                        <i class="fas fa-plus"></i> Adicionar Item
                    </button>
                </div>
                
                <!-- Lista de Itens Adicionados -->
                <div id="itemsList" class="items-list">
                    <!-- Itens serão listados aqui -->
                </div>
            </div>
            
            <!-- Formulário para Criar Evento -->
            <div class="create-event-form" style="display: none;" id="createEventForm">
                <h4><i class="fas fa-calendar-plus"></i> Criar Evento no Google Calendar</h4>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Data *</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label>Horário</label>
                        <input type="time" id="eventTime" value="09:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Recorrência *</label>
                    <select id="eventRecurrence" required onchange="handleRecurrenceChange()">
                        <option value="NONE">Não se repete</option>
                        <option value="DAILY">Todos os dias</option>
                        <option value="WEEKLY">Semanal: cada quinta-feira</option>
                        <option value="MONTHLY">Mensal no(a) terceiro(a) quinta-feira</option>
                        <option value="YEARLY">Anual em setembro 18</option>
                        <option value="WEEKDAYS">Todos os dias da semana (segunda a sexta-feira)</option>
                        <option value="CUSTOM">Personalizar...</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="createEventBtn" class="create-event-btn">
                        <i class="fas fa-calendar-check"></i> Criar Evento
                    </button>
                    <button type="button" id="cancelEventBtn" class="cancel-event-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>

        <!-- Calendar View -->
        <div id="calendarSection" class="calendar-section" style="display: none;">
            <div class="calendar-header">
                <div class="calendar-nav">
                    <button onclick="previousMonth()">
                        <i class="fas fa-chevron-left"></i> Anterior
                    </button>
                    <button onclick="goToToday()">
                        <i class="fas fa-calendar-day"></i> Hoje
                    </button>
                    <button onclick="nextMonth()">
                        Próximo <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <h3 id="calendarTitle" class="calendar-title">Carregando...</h3>
            </div>
            
            <div id="calendarGrid" class="calendar-grid">
                <!-- Calendar will be rendered here -->
            </div>
        </div>

        <!-- ✅ NOVO: Resumo Mensal com Montantes -->
        <div id="monthlySummarySection" class="monthly-summary" style="display: none;">
            <h3><i class="fas fa-chart-pie"></i> Resumo do Mês</h3>
            <div id="monthlyTotal" class="monthly-total">R$ 0,00</div>
            
            <div class="monthly-stats">
                <div class="stat-item">
                    <div id="totalEvents" class="stat-value">0</div>
                    <div class="stat-label">Eventos</div>
                </div>
                <div class="stat-item">
                    <div id="totalPayments" class="stat-value">0</div>
                    <div class="stat-label">Pagamentos</div>
                </div>
                <div class="stat-item">
                    <div id="avgPayment" class="stat-value">R$ 0,00</div>
                    <div class="stat-label">Valor Médio</div>
                </div>
            </div>

            <!-- ✅ NOVO: Estatísticas por Status com Montantes -->
            <div class="status-stats">
                <div class="status-stat-item pg">
                    <div id="totalPG" class="status-stat-value">0</div>
                    <div id="amountPG" class="status-stat-amount">R$ 0,00</div>
                    <div class="status-stat-label">PG</div>
                </div>
                <div class="status-stat-item pendente">
                    <div id="totalPendente" class="status-stat-value">0</div>
                    <div id="amountPendente" class="status-stat-amount">R$ 0,00</div>
                    <div class="status-stat-label">Pendente</div>
                </div>
                <div class="status-stat-item recalculado">
                    <div id="totalRecalculado" class="status-stat-value">0</div>
                    <div id="amountRecalculado" class="status-stat-amount">R$ 0,00</div>
                    <div class="status-stat-label">Recalculado</div>
                </div>
            </div>
        </div>

        <!-- ✅ NOVO: Criador de Eventos de Pagamento -->
        <div id="eventCreatorSection" class="event-creator-section" style="display: none;">
            <h3><i class="fas fa-plus-circle"></i> Criar Evento de Pagamento</h3>
            
            <!-- Lista de Itens de Pagamento -->
            <div class="payment-items-container">
                <h4><i class="fas fa-list"></i> Itens de Pagamento</h4>
                
                <!-- Formulário para Adicionar Item -->
                <div class="add-item-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Tipo</label>
                            <input type="text" id="itemTipo" placeholder="Ex: Despesa, Investimento...">
                        </div>
                        <div class="form-group">
                            <label>Subtipo</label>
                            <input type="text" id="itemSubtipo" placeholder="Ex: Fixa, Variável...">
                        </div>
                        <div class="form-group">
                            <label>Categoria</label>
                            <input type="text" id="itemCategoria" placeholder="Ex: Alimentação, Transporte...">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label>Nome do Item *</label>
                            <input type="text" id="itemNome" placeholder="Nome do item (obrigatório)" required>
                        </div>
                        <div class="form-group">
                            <label>Valor *</label>
                            <input type="text" id="itemValor" placeholder="R$ 0,00" required>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="itemStatus">
                                <option value="">Selecionar...</option>
                                <option value="PG">PG</option>
                                <option value="PENDENTE">PENDENTE</option>
                                <option value="RECALCULADO">RECALCULADO</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group full-width">
                            <label>Detalhe</label>
                            <input type="text" id="itemDetalhe" placeholder="Detalhes adicionais...">
                        </div>
                    </div>
                    
                    <button type="button" id="addItemBtn" class="add-item-btn">
                        <i class="fas fa-plus"></i> Adicionar Item
                    </button>
                </div>
                
                <!-- Lista de Itens Adicionados -->
                <div id="itemsList" class="items-list">
                    <!-- Itens serão listados aqui -->
                </div>
            </div>
            
            <!-- Formulário para Criar Evento -->
            <div class="create-event-form" style="display: none;" id="createEventForm">
                <h4><i class="fas fa-calendar-plus"></i> Criar Evento no Google Calendar</h4>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Data *</label>
                        <input type="date" id="eventDate" required>
                    </div>
                    <div class="form-group">
                        <label>Horário</label>
                        <input type="time" id="eventTime" value="09:00">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Recorrência *</label>
                    <select id="eventRecurrence" required onchange="handleRecurrenceChange()">
                        <option value="NONE">Não se repete</option>
                        <option value="DAILY">Todos os dias</option>
                        <option value="WEEKLY">Semanal: cada quinta-feira</option>
                        <option value="MONTHLY">Mensal no(a) terceiro(a) quinta-feira</option>
                        <option value="YEARLY">Anual em setembro 18</option>
                        <option value="WEEKDAYS">Todos os dias da semana (segunda a sexta-feira)</option>
                        <option value="CUSTOM">Personalizar...</option>
                    </select>
                </div>
                
                <div class="form-actions">
                    <button type="button" id="createEventBtn" class="create-event-btn">
                        <i class="fas fa-calendar-check"></i> Criar Evento
                    </button>
                    <button type="button" id="cancelEventBtn" class="cancel-event-btn">
                        <i class="fas fa-times"></i> Cancelar
                    </button>
                </div>
            </div>
        </div>

        <!-- ✅ NOVO: Lista de Pagamentos com Filtros -->
        <div id="paymentsListSection" class="payments-list-section" style="display: none;">
            <h3><i class="fas fa-list-alt"></i> Lista de Pagamentos do Mês</h3>
            
            <!-- ✅ NOVO: Filtros -->
            <div class="payments-filters">
                <div class="filter-group">
                    <label class="filter-label">Nome do Pagamento</label>
                    <input type="text" id="nameFilter" class="filter-input" placeholder="Buscar por nome...">
                </div>
                <div class="filter-group">
                    <label class="filter-label">Data</label>
                    <input type="date" id="dateFilter" class="filter-input">
                </div>
                <div class="filter-group">
                    <label class="filter-label">Status</label>
                    <select id="statusFilter" class="filter-select">
                        <option value="">Todos os status</option>
                        <option value="PG">PG</option>
                        <option value="PENDENTE">Pendente</option>
                        <option value="RECALCULADO">Recalculado</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button id="clearFilters" class="clear-filters-btn">
                        <i class="fas fa-times"></i> Limpar Filtros
                    </button>
                </div>
            </div>
            
            <div id="paymentsList" class="payments-list">
                <!-- Pagamentos serão listados aqui -->
            </div>
        </div>
    </div>

    <!-- Event Details Modal -->
    <div id="eventModal" class="event-modal">
        <div class="event-modal-content">
            <div class="modal-header">
                <h2 id="eventModalTitle">Detalhes do Evento</h2>
                <span class="close" onclick="closeEventModal()">&times;</span>
            </div>
            <div class="modal-body" id="eventModalBody">
                <!-- Event details will be populated here -->
            </div>
        </div>
    </div>

    <!-- Custom Recurrence Modal -->
    <div id="customRecurrenceModal" class="custom-recurrence-modal">
        <div class="custom-recurrence-modal-content">
            <h3>Recorrência personalizada</h3>
            
            <div class="recurrence-form-group">
                <div class="recurrence-form-row">
                    <span>Repetir a cada:</span>
                    <input type="number" id="recurrenceInterval" class="recurrence-input" value="1" min="1" max="999">
                    <select id="recurrenceUnit" class="recurrence-select">
                        <option value="day">dia</option>
                        <option value="week" selected>semana</option>
                        <option value="month">mês</option>
                        <option value="year">ano</option>
                    </select>
                </div>
            </div>

            <div class="recurrence-form-group" id="weekdaysGroup" style="display: block;">
                <label>Repetir:</label>
                <div class="weekdays-selector">
                    <button type="button" class="weekday-btn" data-day="0">D</button>
                    <button type="button" class="weekday-btn" data-day="1">S</button>
                    <button type="button" class="weekday-btn" data-day="2">T</button>
                    <button type="button" class="weekday-btn" data-day="3">Q</button>
                    <button type="button" class="weekday-btn" data-day="4" id="defaultWeekday">Q</button>
                    <button type="button" class="weekday-btn" data-day="5">S</button>
                    <button type="button" class="weekday-btn" data-day="6">S</button>
                </div>
            </div>

            <div class="recurrence-form-group">
                <label>Termina em</label>
                <div class="end-options">
                    <div class="end-option">
                        <input type="radio" id="endNever" name="endType" value="never" checked>
                        <label for="endNever">Nunca</label>
                    </div>
                    <div class="end-option">
                        <input type="radio" id="endDate" name="endType" value="date">
                        <label for="endDate">
                            Em
                            <input type="date" id="endDateValue" class="end-date-input" disabled>
                        </label>
                    </div>
                    <div class="end-option">
                        <input type="radio" id="endCount" name="endType" value="count">
                        <label for="endCount">
                            Após
                            <input type="number" id="endCountValue" class="end-count-input" value="10" min="1" max="999" disabled>
                            ocorrências
                        </label>
                    </div>
                </div>
            </div>

            <div class="custom-recurrence-actions">
                <button type="button" class="custom-recurrence-btn custom-recurrence-cancel" onclick="closeCustomRecurrenceModal()">
                    Cancelar
                </button>
                <button type="button" class="custom-recurrence-btn custom-recurrence-confirm" onclick="confirmCustomRecurrence()">
                    Concluir
                </button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script type="module" src="supabase.js"></script>
    <script type="module" src="dashboard-hvc.js"></script>
    <script src="multi_account_manager.js"></script>
    <script type="module">
        import { injectSidebar } from './sidebar.js';
        injectSidebar("main-content-fluxo-caixa-hvc");
    </script>
    
    <!-- ✅ NOVO: Event Listeners para criação de eventos -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Event listeners para criação de eventos
            const addItemBtn = document.getElementById('addItemBtn');
            const createEventBtn = document.getElementById('createEventBtn');
            const cancelEventBtn = document.getElementById('cancelEventBtn');
            
            if (addItemBtn) {
                addItemBtn.addEventListener('click', addPaymentItem);
            }
            
            if (createEventBtn) {
                createEventBtn.addEventListener('click', createPaymentEvent);
            }
            
            if (cancelEventBtn) {
                cancelEventBtn.addEventListener('click', cancelEventCreation);
            }
            
            // ✅ NOVO: Formatação automática do campo valor
            const itemValorInput = document.getElementById('itemValor');
            if (itemValorInput) {
                itemValorInput.addEventListener('input', function(e) {
                    let value = e.target.value.replace(/\D/g, ''); // Remove tudo que não é dígito
                    
                    if (value === '') {
                        e.target.value = '';
                        return;
                    }
                    
                    // Converte para número e formata
                    const numValue = parseInt(value) / 100;
                    e.target.value = formatCurrency(numValue);
                });
                
                // Limpar formatação ao focar para edição
                itemValorInput.addEventListener('focus', function(e) {
                    const value = e.target.value.replace(/[^\d,]/g, '').replace(',', '.');
                    if (value && !isNaN(parseFloat(value))) {
                        e.target.value = parseFloat(value).toFixed(2).replace('.', ',');
                    }
                });
                
                // Reformatar ao sair do campo
                itemValorInput.addEventListener('blur', function(e) {
                    const value = e.target.value.replace(',', '.');
                    if (value && !isNaN(parseFloat(value))) {
                        e.target.value = formatCurrency(parseFloat(value));
                    }
                });
            }
            
            // Permitir Enter para adicionar item
            const itemForm = document.querySelector('.add-item-form');
            if (itemForm) {
                itemForm.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addPaymentItem();
                    }
                });
            }
        });
    </script>
    
    <!-- Google APIs - Carregar DEPOIS das funções estarem definidas -->
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>
</html>
